{"version":3,"sources":["webpack:///static/js/2.6211802dcc3d9ebf8ca5.js","webpack:///./~/glsl-parser/parser.js"],"names":["webpackJsonp","TFw8","module","exports","__webpack_require__","__extends","derived","base","prototype","Object","create","constructor","__isString","value","assert","truth","Error","__imul","Math","imul","a","b","GLSLX","RenameSymbols","ALL","CompilerOptions","this","compactSyntaxTree","removeWhitespace","renameSymbols","trimSymbols","fileAccess","globals","ExtensionBehavior","DEFAULT","DISABLE","ENABLE","REQUIRE","WARN","CompilerData","currentExtensions","_nextSymbolID","nextSymbolID","extensionBehavior","name","in_StringMap","get","Compiler","typeCheck","log","sources","options","hasErrors","unshift","Source","API","i","list","count","length","source","in_List","tokens","Tokenizer","tokenize","global","Node","NodeKind","GLOBAL","scope","Scope","ScopeKind","data","resolver","Resolver","i1","list1","count1","source1","Parser","parse","resolveGlobal","ControlFlowAnalyzer","_isLoopBreakTarget","_isControlFlowLive","pushBlock","node","parent","push","last","in_NodeKind","isLoop","kind","popBlock","takeLast","hasControlFlowAtEnd","WHILE","whileTest","isTrue","DO_WHILE","doWhileTest","FOR","forTest","setLast","visitStatement","BREAK","RETURN","DISCARD","CONTINUE","IF","test","ifTest","trueValue","ifTrue","falseValue","ifFalse","isFalse","Folder","fold","RELEASE","_fold","folded","UNKNOWN_CONSTANT","_check","INT","resolvedType","Type","hasChildren","BOOL","FLOAT","CALL","target","callTarget","TYPE","componentType","componentCount","childCount","child","nextSibling","struct","symbol","asStruct","variables","child1","type","ERROR","clone","NAME","_foldName","SEQUENCE","_foldSequence","HOOK","_foldHook","DOT","_foldDot","INDEX","_foldIndex","_foldCall","NEGATIVE","_foldUnaryFloatOrInt","x","NOT","_foldUnaryBool","POSITIVE","ADD","_foldBinaryFloatOrInt","SUBTRACT","MULTIPLY","_foldMultiply","DIVIDE","EQUAL","NOT_EQUAL","_foldBinaryEquality","LOGICAL_AND","_foldBinaryBool","LOGICAL_OR","LOGICAL_XOR","GREATER_THAN","_foldBinaryFloatOrIntToBool","GREATER_THAN_OR_EQUAL","LESS_THAN","LESS_THAN_OR_EQUAL","isConst","constantValue","asVariable","VariableKind","ARGUMENT","withType","firstChild","lastChild","foldedTest","hookTest","foldedTrue","hookTrue","foldedFalse","hookFalse","asBool","dotTarget","asString","isVector","i2","Swizzle","strings","count2","set","indexOf","in_string","childAt","remove","swizzleType","result","createConstructorCall","appendChild","isStruct","count3","variable","foldedLeft","binaryLeft","foldedRight","binaryRight","indexCount","index","asInt","isMatrix","indexCount1","index1","indexType","before","matrixStride","$arguments","casted","_castValue","_foldComponentConstructor","_foldStruct","_floatValues","values","asFloat","ref","left","right","leftType","rightType","VEC2","MAT2","VEC3","MAT3","VEC4","MAT4","stride","leftValues","rightValues","total","col","withFloat","stride1","result1","leftValues1","rightValues1","total1","row","stride2","result2","leftValues2","rightValues2","row1","count6","col1","count5","total2","count4","_foldFloat2","_foldInt2","withBool","withInt","argument","first","isOffMatrixDiagonal","argument1","looksTheSameAs","_foldComponentwiseUnary","argumentKind","op","_foldFloat1","_foldInt1","_foldComponentwiseBinary","leftHasComponents","rightHasComponents","leftChild","rightChild","folded1","unaryValue","floatOp","intOp","DiagnosticKind","WARNING","Diagnostic","range","text","noteRange","noteText","Log","diagnostics","warningCount","errorCount","error","warning","note","syntaxWarningUnknownExtension","syntaxErrorInvalidString","syntaxErrorDisabledExtension","extension","syntaxErrorExtraData","syntaxErrorReservedWord","toString","syntaxErrorUnexpectedToken","token","in_TokenKind","_strings","syntaxErrorExpectedToken1","expected","syntaxErrorExpectedToken2","found","syntaxErrorBadSymbolReference","syntaxErrorDuplicateSymbolDefinition","previous","syntaxErrorOutsideLoop","syntaxErrorStructVariableInitializer","syntaxErrorInsideStruct","syntaxErrorInsideFunction","syntaxErrorOutsideFunction","semanticErrorIncludeWithoutFileAccess","semanticErrorIncludeBadPath","path","JSON","stringify","syntaxErrorDifferentReturnType","syntaxErrorBadQualifier","syntaxErrorConstantRequired","syntaxErrorInvalidArraySize","syntaxErrorMissingArraySize","syntaxErrorMultidimensionalArray","syntaxErrorInvalidOperator","semanticErrorBadConversion","from","to","semanticErrorUnexpectedType","semanticErrorBadVariableType","semanticErrorBadMember","semanticErrorBadSwizzle","semanticErrorBadSwizzleAssignment","field","semanticErrorMustCallFunction","semanticErrorBadCall","semanticErrorBadConstructorValue","$constructor","semanticErrorExtraConstructorValue","semanticErrorBadConstructorCount","semanticErrorArgumentCountFunction","$function","semanticErrorArgumentCountConstructor","semanticErrorBadOverloadMatch","semanticErrorBadHookTypes","semanticErrorArrayHook","isArrayOf","semanticErrorArrayAssignment","semanticErrorBadUnaryOperator","operator","semanticErrorBadBinaryOperator","semanticErrorBadIndex","semanticErrorOutOfBoundsIndex","semanticErrorBadStorage","semanticErrorUninitializedConstant","semanticErrorMissingReturn","semanticErrorBadMatrixConstructor","STRUCT_BLOCK","VARIABLE","BLOCK","EXPRESSION","EXTENSION","FUNCTION","MODIFIER_BLOCK","PRECISION","STRUCT","VARIABLES","VERSION","PARSE_ERROR","PREFIX_DECREMENT","PREFIX_INCREMENT","POSTFIX_DECREMENT","POSTFIX_INCREMENT","ASSIGN","ASSIGN_ADD","ASSIGN_DIVIDE","ASSIGN_MULTIPLY","ASSIGN_SUBTRACT","id","_createID","internalRange","_literal","_text","_parent","_firstChild","_lastChild","_previousSibling","_nextSibling","_copyMembersFrom","cloneWithoutChildren","withSymbol","withText","withRange","withInternalRange","insertChildBefore","after","isCallTarget","isAssignTarget","isUnaryAssign","isBinaryAssign","isEmptySequence","isUnary","isBinary","createDoWhile","body","isStatement","isExpression","createExpression","createFor","setup","update","createIf","yes","no","createPrecision","flags","createReturn","createStruct","block","createVariables","createWhile","createCall","createDot","createHook","createUnary","createBinary","doWhileBody","expressionValue","forSetup","forUpdate","forBody","returnValue","variablesType","whileBody","_nextID","typeParselet","context","unaryPrefix","isUnaryPrefix","Range","span","unaryPostfix","isUnaryPostfix","binaryParselet","parseInt","get1","createExpressionParser","pratt","Pratt","invalidUnaryOperator","invalidBinaryOperator","literal","TokenKind","TRUE","FALSE","INT_LITERAL","FLOAT_LITERAL","BVEC2","BVEC3","BVEC4","IVEC2","IVEC3","IVEC4","VOID","prefix","COMPLEMENT","Precedence","UNARY_PREFIX","DECREMENT","INCREMENT","MINUS","PLUS","postfix","UNARY_POSTFIX","infix","COMPARE","REMAINDER","SHIFT_LEFT","SHIFT","SHIFT_RIGHT","BITWISE_AND","BITWISE_OR","BITWISE_XOR","infixRight","ASSIGN_BITWISE_AND","ASSIGN_BITWISE_OR","ASSIGN_BITWISE_XOR","ASSIGN_REMAINDER","ASSIGN_SHIFT_LEFT","ASSIGN_SHIFT_RIGHT","IDENTIFIER","find","requiredExtension","compilationData","COMMA","spanSince","parselet","MEMBER","next","current","expect","LEFT_PARENTHESIS","LOWEST","RIGHT_PARENTHESIS","parseCommaSeparatedList","LEFT_BRACKET","peek","RIGHT_BRACKET","unexpectedToken","QUESTION","middle","COLON","stop","isFirst","eat","parseDoWhile","pushScope","LOOP","parseStatement","LOCAL","popScope","checkForSemicolon","parseExportOrImport","old","EXPORT","SymbolFlags","EXPORTED","IMPORTED","LEFT_BRACE","parseStatements","RIGHT_BRACE","statement","parseExtension","_knownWebGLExtensions","_extensionBehaviors","behavior","parseFor","SEMICOLON","parseFlags","parseType","ParseTypeMode","REPORT_ERRORS","IGNORE_ERRORS","parseAfterType","Allow","AVOID_FUNCTIONS","parseIf","ELSE","parseVersion","parseWhile","parseReturn","parsePrecision","flag","LOWP","MEDIUMP","HIGHP","parseStruct","StructSymbol","tryToDefineUniquelyInScope","END_OF_FILE","parseVariables","checkForLoopAndSemicolon","allow","resume","parseFunction","mode","DO","IMPORT","parseBlock","ALLOW_FUNCTIONS","checkStatementLocation","isOutsideFunction","shouldBeOutsideFunction","parseInclude","STRING_LITERAL","e","nestedContext","ParserContext","ATTRIBUTE","CONST","IN","INOUT","OUT","UNIFORM","VARYING","SAMPLER2D","SAMPLERCUBE","originalScope","FunctionSymbol","returnType","argumentFlags","argumentType","argumentName","VariableSymbol","parseArraySize","symbols","hasBlock","define","isFunction","link","asFunction","previousOverload","hasSameArgumentTypesAs","sibling","redefine","arrayCount","resolveNode","checkConversion","arrayType","assign","INCLUDE","_tokens","_index","_scope","end","start","lineColumn","line","rangeAtEnd","newScope","Parselet","precedence","_table","in_IntMap","created","callback","self","slice2","contents","slice","offsetStart","offsetEnd","indexToLineColumn","_log","_data","_controlFlow","_versions","_generatedExtensions","_returnType","_resolveChildren","_resolveAsExpression","containsArray","_resolveBlockOrStatement","symbol1","type1","containsSampler","_resolveCall","_resolveDot","symbol2","isVariable","_resolveUnary","_resolveBinary","_checkStorage","valueType","isIntOrFloat","isSame","hasFloatComponents","hasIntComponents","canUseEqualityOperators","hasError","_resolveFunctionOverloads","_resolveConstructor","_validateSwizzle","overloaded","overloads","overload","removeIf","overloadsBeforeTypeFilter","fromSize","toSize","overload1","hasMatrixArgument","providedCount","deltaCount","isMatrixMatrixConstructor","variableCount","argumentCount","n","label","LineColumn","column","_lineOffsets","_computeLineOffsets","step","_STRINGS_2","_STRINGS_3","_STRINGS_4","comonentType","Symbol","_resolvedType","call","INVARIANT","Token","parts","split","_tokenRegex","part","c","keyword","keywords","reservedWords","_intRegex","operators","_arrayTypes","_setContainsSampler","Exports","sourcesFromInput","input","Array","main","check","args","disableRewriting","prettyPrint","keepSymbols","charCodeAt","removeLast","pop","key","insert","defaultValue","RegExp"],"mappings":"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","file":"static/js/2.6211802dcc3d9ebf8ca5.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ \"TFw8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n(function() {\r\n  function __extends(derived, base) {\r\n    derived.prototype = Object.create(base.prototype);\r\n    derived.prototype.constructor = derived;\r\n  }\r\n\r\n  var __imul = Math.imul ? Math.imul : function(a, b) {\r\n    return (a * (b >>> 16) << 16) + a * (b & 65535) | 0;\r\n  };\r\n\r\n  function __isString(value) {\r\n    return typeof value === 'string';\r\n  }\r\n\r\n  function assert(truth) {\r\n    if (!truth) {\r\n      throw Error('Assertion failed');\r\n    }\r\n  }\r\n\r\n  var GLSLX = {};\r\n\r\n  GLSLX.RenameSymbols = {\r\n    ALL: 0\r\n  };\r\n\r\n  GLSLX.CompilerOptions = function() {\r\n    this.compactSyntaxTree = true;\r\n    this.removeWhitespace = true;\r\n    this.renameSymbols = GLSLX.RenameSymbols.ALL;\r\n    this.trimSymbols = true;\r\n    this.fileAccess = null;\r\n    this.globals = null;\r\n  };\r\n\r\n  GLSLX.ExtensionBehavior = {\r\n    DEFAULT: 0,\r\n    DISABLE: 1,\r\n    ENABLE: 2,\r\n    REQUIRE: 3,\r\n    WARN: 4\r\n  };\r\n\r\n  GLSLX.CompilerData = function(fileAccess) {\r\n    this.currentExtensions = Object.create(null);\r\n    this.fileAccess = fileAccess;\r\n    this._nextSymbolID = 0;\r\n  };\r\n\r\n  GLSLX.CompilerData.prototype.nextSymbolID = function() {\r\n    this._nextSymbolID = this._nextSymbolID + 1 | 0;\r\n    return this._nextSymbolID;\r\n  };\r\n\r\n  GLSLX.CompilerData.prototype.extensionBehavior = function(name) {\r\n    return in_StringMap.get(this.currentExtensions, name, GLSLX.ExtensionBehavior.DEFAULT);\r\n  };\r\n\r\n  GLSLX.Compiler = {};\r\n\r\n  GLSLX.Compiler.typeCheck = function(log, sources, options) {\r\n    if (log.hasErrors()) {\r\n      return null;\r\n    }\r\n\r\n    // Generate tokens once\r\n    sources.unshift(new GLSLX.Source('<api>', GLSLX.API));\r\n\r\n    if (options.globals != null) {\r\n      sources.unshift(new GLSLX.Source('<externs_globals>', options.globals));\r\n    }\r\n\r\n    for (var i = 0, list = sources, count = list.length; i < count; i = i + 1 | 0) {\r\n      var source = in_List.get(list, i);\r\n      source.tokens = GLSLX.Tokenizer.tokenize(log, source);\r\n    }\r\n\r\n    var global = new GLSLX.Node(GLSLX.NodeKind.GLOBAL);\r\n    var scope = new GLSLX.Scope(GLSLX.ScopeKind.GLOBAL, null);\r\n    var data = new GLSLX.CompilerData(options.fileAccess);\r\n    var resolver = new GLSLX.Resolver(log, data);\r\n\r\n    // Parse everything next\r\n    for (var i1 = 0, list1 = sources, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n      var source1 = in_List.get(list1, i1);\r\n      GLSLX.Parser.parse(log, source1.tokens, global, data, scope, resolver);\r\n    }\r\n\r\n    // Then run type checking\r\n    resolver.resolveGlobal(global);\r\n\r\n    // Always return even when there were errors since the partial result is still useful\r\n    return global;\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer = function() {\r\n    this._isLoopBreakTarget = [];\r\n    this._isControlFlowLive = [];\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer.prototype.pushBlock = function(node) {\r\n    var parent = node.parent();\r\n\r\n    // Push control flow\r\n    this._isControlFlowLive.push(this._isControlFlowLive.length == 0 || in_List.last(this._isControlFlowLive));\r\n\r\n    // Push loop info\r\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind)) {\r\n      this._isLoopBreakTarget.push(false);\r\n    }\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer.prototype.popBlock = function(node) {\r\n    var parent = node.parent();\r\n\r\n    // Pop control flow\r\n    var isLive = in_List.takeLast(this._isControlFlowLive);\r\n\r\n    if (isLive) {\r\n      node.hasControlFlowAtEnd = true;\r\n    }\r\n\r\n    // Pop loop info\r\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind) && !in_List.takeLast(this._isLoopBreakTarget) && (parent.kind == GLSLX.NodeKind.WHILE && parent.whileTest().isTrue() || parent.kind == GLSLX.NodeKind.DO_WHILE && parent.doWhileTest().isTrue() || parent.kind == GLSLX.NodeKind.FOR && (parent.forTest() == null || parent.forTest().isTrue()))) {\r\n      in_List.setLast(this._isControlFlowLive, false);\r\n    }\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer.prototype.visitStatement = function(node) {\r\n    if (!in_List.last(this._isControlFlowLive)) {\r\n      return;\r\n    }\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.BREAK: {\r\n        if (!(this._isLoopBreakTarget.length == 0)) {\r\n          in_List.setLast(this._isLoopBreakTarget, true);\r\n        }\r\n\r\n        in_List.setLast(this._isControlFlowLive, false);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.RETURN:\r\n      case GLSLX.NodeKind.DISCARD:\r\n      case GLSLX.NodeKind.CONTINUE: {\r\n        in_List.setLast(this._isControlFlowLive, false);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.IF: {\r\n        var test = node.ifTest();\r\n        var trueValue = node.ifTrue();\r\n        var falseValue = node.ifFalse();\r\n\r\n        if (test.isTrue()) {\r\n          if (!trueValue.hasControlFlowAtEnd) {\r\n            in_List.setLast(this._isControlFlowLive, false);\r\n          }\r\n        }\r\n\r\n        else if (test.isFalse() && falseValue != null) {\r\n          if (!falseValue.hasControlFlowAtEnd) {\r\n            in_List.setLast(this._isControlFlowLive, false);\r\n          }\r\n        }\r\n\r\n        else if (trueValue != null && falseValue != null) {\r\n          if (!trueValue.hasControlFlowAtEnd && !falseValue.hasControlFlowAtEnd) {\r\n            in_List.setLast(this._isControlFlowLive, false);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Folder = {};\r\n\r\n  GLSLX.Folder.fold = function(node) {\r\n    if (RELEASE) {\r\n      return GLSLX.Folder._fold(node);\r\n    }\r\n\r\n    // Run sanity checks in debug mode\r\n    else {\r\n      var folded = GLSLX.Folder._fold(node);\r\n\r\n      if (folded != null) {\r\n        assert(folded.parent() == null);\r\n\r\n        if (folded.kind != GLSLX.NodeKind.UNKNOWN_CONSTANT) {\r\n          GLSLX.Folder._check(folded);\r\n        }\r\n      }\r\n\r\n      return folded;\r\n    }\r\n  };\r\n\r\n  GLSLX.Folder._check = function(node) {\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.INT: {\r\n        assert(node.resolvedType == GLSLX.Type.INT && !node.hasChildren());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.BOOL: {\r\n        assert(node.resolvedType == GLSLX.Type.BOOL && !node.hasChildren());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FLOAT: {\r\n        assert(node.resolvedType == GLSLX.Type.FLOAT && !node.hasChildren());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.CALL: {\r\n        var target = node.callTarget();\r\n        assert(target.kind == GLSLX.NodeKind.TYPE);\r\n        assert(target.resolvedType == node.resolvedType);\r\n        var componentType = target.resolvedType.componentType();\r\n        var componentCount = target.resolvedType.componentCount();\r\n\r\n        // Native component types\r\n        if (componentType != null) {\r\n          assert(node.childCount() == (1 + componentCount | 0));\r\n          assert(target.resolvedType != GLSLX.Type.INT && target.resolvedType != GLSLX.Type.BOOL && target.resolvedType != GLSLX.Type.FLOAT);\r\n\r\n          for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\r\n            assert(child.resolvedType == componentType);\r\n            assert(child.kind != GLSLX.NodeKind.CALL);\r\n            GLSLX.Folder._check(child);\r\n          }\r\n        }\r\n\r\n        // User-defined structs\r\n        else {\r\n          var struct = target.resolvedType.symbol.asStruct();\r\n          var i = 0;\r\n          assert(node.childCount() == (1 + struct.variables.length | 0));\r\n\r\n          for (var child1 = target.nextSibling(); child1 != null; child1 = child1.nextSibling()) {\r\n            assert(child1.resolvedType == in_List.get(struct.variables, i).type.resolvedType);\r\n            GLSLX.Folder._check(child1);\r\n            i = i + 1 | 0;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        assert(false);\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Folder._fold = function(node) {\r\n    assert(node.resolvedType != null);\r\n\r\n    if (node.resolvedType == GLSLX.Type.ERROR) {\r\n      return null;\r\n    }\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.INT:\r\n      case GLSLX.NodeKind.FLOAT:\r\n      case GLSLX.NodeKind.BOOL: {\r\n        return node.clone();\r\n      }\r\n\r\n      case GLSLX.NodeKind.NAME: {\r\n        return GLSLX.Folder._foldName(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.SEQUENCE: {\r\n        return GLSLX.Folder._foldSequence(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.HOOK: {\r\n        return GLSLX.Folder._foldHook(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.DOT: {\r\n        return GLSLX.Folder._foldDot(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.INDEX: {\r\n        return GLSLX.Folder._foldIndex(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.CALL: {\r\n        return GLSLX.Folder._foldCall(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.NEGATIVE: {\r\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\r\n          return -x;\r\n        }, function(x) {\r\n          return -x | 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.NOT: {\r\n        return GLSLX.Folder._foldUnaryBool(node, function(x) {\r\n          return !x;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.POSITIVE: {\r\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\r\n          return +x;\r\n        }, function(x) {\r\n          return +x;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.ADD: {\r\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\r\n          return a + b;\r\n        }, function(a, b) {\r\n          return a + b | 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.SUBTRACT: {\r\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\r\n          return a - b;\r\n        }, function(a, b) {\r\n          return a - b | 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.MULTIPLY: {\r\n        return GLSLX.Folder._foldMultiply(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.DIVIDE: {\r\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\r\n          return b != 0 ? a / b : 0;\r\n        }, function(a, b) {\r\n          return b != 0 ? a / b | 0 : 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.EQUAL:\r\n      case GLSLX.NodeKind.NOT_EQUAL: {\r\n        return GLSLX.Folder._foldBinaryEquality(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_AND: {\r\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\r\n          return a && b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_OR: {\r\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\r\n          return a || b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_XOR: {\r\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\r\n          return a != b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.GREATER_THAN: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a > b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a >= b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LESS_THAN: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a < b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a <= b;\r\n        });\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldName = function(node) {\r\n    var symbol = node.symbol;\r\n\r\n    if (symbol != null && symbol.isConst()) {\r\n      if (symbol.constantValue != null) {\r\n        return symbol.constantValue.clone();\r\n      }\r\n\r\n      if (symbol.asVariable().kind != GLSLX.VariableKind.ARGUMENT) {\r\n        return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(node.resolvedType);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldSequence = function(node) {\r\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n      var folded = GLSLX.Folder.fold(child);\r\n\r\n      if (folded == null || child == node.lastChild()) {\r\n        return folded;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldHook = function(node) {\r\n    var foldedTest = GLSLX.Folder.fold(node.hookTest());\r\n    var foldedTrue = GLSLX.Folder.fold(node.hookTrue());\r\n    var foldedFalse = GLSLX.Folder.fold(node.hookFalse());\r\n\r\n    if (foldedTest != null && foldedTest.kind == GLSLX.NodeKind.BOOL && foldedTrue != null && foldedFalse != null) {\r\n      return foldedTest.asBool() ? foldedTrue : foldedFalse;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldDot = function(node) {\r\n    var folded = GLSLX.Folder.fold(node.dotTarget());\r\n\r\n    if (folded != null && folded.kind == GLSLX.NodeKind.CALL) {\r\n      var resolvedType = folded.resolvedType;\r\n      var name = node.asString();\r\n\r\n      // Evaluate a swizzle\r\n      if (resolvedType.isVector()) {\r\n        var count = name.length;\r\n        var componentCount = resolvedType.componentCount();\r\n\r\n        // Find the swizzle set\r\n        for (var i2 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i2 < count2; i2 = i2 + 1 | 0) {\r\n          var set = in_List.get(list, i2);\r\n\r\n          if (set.indexOf(in_string.get(name, 0)) != -1) {\r\n            if (count == 1) {\r\n              return folded.childAt(1 + set.indexOf(name) | 0).remove();\r\n            }\r\n\r\n            var swizzleType = GLSLX.Swizzle.type(resolvedType.componentType(), count);\r\n            var result = GLSLX.Node.createConstructorCall(swizzleType);\r\n\r\n            for (var i = 0, count1 = count; i < count1; i = i + 1 | 0) {\r\n              result.appendChild(folded.childAt(1 + set.indexOf(in_string.get(name, i)) | 0).clone());\r\n            }\r\n\r\n            return result;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Evaluate a struct field\r\n      else if (resolvedType.symbol != null && resolvedType.symbol.isStruct()) {\r\n        var symbol = resolvedType.symbol.asStruct();\r\n        var variables = symbol.variables;\r\n        assert(folded.childCount() == (1 + variables.length | 0));\r\n\r\n        // Extract the field from the constructor call\r\n        for (var i1 = 0, count3 = variables.length; i1 < count3; i1 = i1 + 1 | 0) {\r\n          var variable = in_List.get(variables, i1);\r\n\r\n          if (variable.name == name) {\r\n            return folded.childAt(1 + i1 | 0).remove();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldIndex = function(node) {\r\n    var foldedLeft = GLSLX.Folder.fold(node.binaryLeft());\r\n    var foldedRight = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    // Both children must also be constants\r\n    if (foldedLeft != null && foldedLeft.kind == GLSLX.NodeKind.CALL && foldedRight != null && foldedRight.kind == GLSLX.NodeKind.INT) {\r\n      var type = foldedLeft.resolvedType;\r\n\r\n      if (type.isVector()) {\r\n        var indexCount = type.indexCount();\r\n        var index = foldedRight.asInt();\r\n\r\n        // The index must be in range\r\n        if (0 <= index && index < indexCount) {\r\n          return foldedLeft.childAt(index + 1 | 0).remove();\r\n        }\r\n      }\r\n\r\n      // Indexing into a matrix creates a vector\r\n      else if (type.isMatrix()) {\r\n        var indexCount1 = type.indexCount();\r\n        var index1 = foldedRight.asInt();\r\n        assert(foldedLeft.childCount() == (1 + __imul(indexCount1, indexCount1) | 0));\r\n\r\n        // The index must be in range\r\n        if (0 <= index1 && index1 < indexCount1) {\r\n          var indexType = type.indexType();\r\n          var result = GLSLX.Node.createConstructorCall(indexType);\r\n          var before = foldedLeft.childAt(__imul(index1, indexCount1));\r\n\r\n          for (var i = 0, count = indexCount1; i < count; i = i + 1 | 0) {\r\n            result.appendChild(before.nextSibling().remove());\r\n          }\r\n\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldCall = function(node) {\r\n    var target = node.callTarget();\r\n\r\n    // Only constructor calls are considered constants\r\n    if (target.kind != GLSLX.NodeKind.TYPE) {\r\n      return null;\r\n    }\r\n\r\n    var type = target.resolvedType;\r\n    var componentType = type.componentType();\r\n    var matrixStride = 0;\r\n    var $arguments = [];\r\n    var count = 0;\r\n\r\n    // Make sure all arguments are constants\r\n    for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\r\n      var folded = GLSLX.Folder.fold(child);\r\n\r\n      if (folded == null) {\r\n        return null;\r\n      }\r\n\r\n      // Expand values inline from constructed native types\r\n      if (folded.kind == GLSLX.NodeKind.CALL && componentType != null && folded.callTarget().resolvedType.componentType() != null) {\r\n        for (var value = folded.callTarget().nextSibling(); value != null; value = value.nextSibling()) {\r\n          var casted = GLSLX.Folder._castValue(componentType, value);\r\n\r\n          if (casted == null) {\r\n            return null;\r\n          }\r\n\r\n          $arguments.push(casted);\r\n        }\r\n      }\r\n\r\n      // Auto-cast values for primitive types\r\n      else {\r\n        if (componentType != null) {\r\n          folded = GLSLX.Folder._castValue(componentType, folded);\r\n\r\n          if (folded == null) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n        $arguments.push(folded);\r\n      }\r\n\r\n      if (folded.resolvedType.isMatrix()) {\r\n        matrixStride = folded.resolvedType.indexCount();\r\n      }\r\n\r\n      count = count + 1 | 0;\r\n    }\r\n\r\n    // If a matrix argument is given to a matrix constructor, it is an error\r\n    // to have any other arguments\r\n    if (type.isMatrix() && matrixStride != 0 && count != 1) {\r\n      return null;\r\n    }\r\n\r\n    // Native component-based types\r\n    if (type.componentType() != null) {\r\n      return GLSLX.Folder._foldComponentConstructor($arguments, type, type.isMatrix() ? matrixStride : 0);\r\n    }\r\n\r\n    // User-defined struct types\r\n    if (type.symbol != null && type.symbol.isStruct()) {\r\n      return GLSLX.Folder._foldStruct($arguments, type);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._floatValues = function(node) {\r\n    var values = [];\r\n\r\n    for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\r\n      values.push(child.asFloat());\r\n    }\r\n\r\n    return values;\r\n  };\r\n\r\n  GLSLX.Folder._foldMultiply = function(node) {\r\n    var ref;\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n    var leftType = left != null ? left.resolvedType : null;\r\n    var rightType = right != null ? right.resolvedType : null;\r\n\r\n    if (left != null && right != null) {\r\n      // Vector-matrix multiply\r\n      if (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) {\r\n        var stride = leftType.indexCount();\r\n        var result = GLSLX.Node.createConstructorCall(leftType);\r\n        var leftValues = GLSLX.Folder._floatValues(left);\r\n        var rightValues = GLSLX.Folder._floatValues(right);\r\n\r\n        for (var i = 0, count1 = stride; i < count1; i = i + 1 | 0) {\r\n          var total = 0;\r\n\r\n          for (var col = 0, count = stride; col < count; col = col + 1 | 0) {\r\n            total += in_List.get(leftValues, col) * in_List.get(rightValues, col + __imul(i, stride) | 0);\r\n          }\r\n\r\n          result.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total).withType(GLSLX.Type.FLOAT));\r\n        }\r\n\r\n        return result;\r\n      }\r\n\r\n      // Matrix-vector multiply\r\n      if (leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) {\r\n        var stride1 = leftType.indexCount();\r\n        var result1 = GLSLX.Node.createConstructorCall(rightType);\r\n        var leftValues1 = GLSLX.Folder._floatValues(left);\r\n        var rightValues1 = GLSLX.Folder._floatValues(right);\r\n\r\n        for (var i1 = 0, count3 = stride1; i1 < count3; i1 = i1 + 1 | 0) {\r\n          var total1 = 0;\r\n\r\n          for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\r\n            total1 += in_List.get(leftValues1, i1 + __imul(row, stride1) | 0) * in_List.get(rightValues1, row);\r\n          }\r\n\r\n          result1.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total1).withType(GLSLX.Type.FLOAT));\r\n        }\r\n\r\n        return result1;\r\n      }\r\n\r\n      // Matrix-matrix multiply\r\n      if (leftType.isMatrix() && rightType == leftType) {\r\n        var stride2 = leftType.indexCount();\r\n        var result2 = GLSLX.Node.createConstructorCall(leftType);\r\n        var leftValues2 = GLSLX.Folder._floatValues(left);\r\n        var rightValues2 = GLSLX.Folder._floatValues(right);\r\n\r\n        for (var row1 = 0, count6 = stride2; row1 < count6; row1 = row1 + 1 | 0) {\r\n          for (var col1 = 0, count5 = stride2; col1 < count5; col1 = col1 + 1 | 0) {\r\n            var total2 = 0;\r\n\r\n            for (var i2 = 0, count4 = stride2; i2 < count4; i2 = i2 + 1 | 0) {\r\n              total2 += in_List.get(leftValues2, col1 + __imul(i2, stride2) | 0) * in_List.get(rightValues2, i2 + __imul(row1, stride2) | 0);\r\n            }\r\n\r\n            result2.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total2).withType(GLSLX.Type.FLOAT));\r\n          }\r\n        }\r\n\r\n        return result2;\r\n      }\r\n\r\n      return (ref = GLSLX.Folder._foldFloat2(left, right, function(a, b) {\r\n        return a * b;\r\n      })) != null ? ref : GLSLX.Folder._foldInt2(left, right, function(a, b) {\r\n        return __imul(a, b);\r\n      });\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._castValue = function(type, node) {\r\n    var value = 0;\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.BOOL: {\r\n        value = +node.asBool();\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.INT: {\r\n        value = node.asInt();\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FLOAT: {\r\n        value = node.asFloat();\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    switch (type) {\r\n      case GLSLX.Type.BOOL: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(!!value).withType(GLSLX.Type.BOOL);\r\n      }\r\n\r\n      case GLSLX.Type.INT: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(value | 0).withType(GLSLX.Type.INT);\r\n      }\r\n\r\n      case GLSLX.Type.FLOAT: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(value).withType(GLSLX.Type.FLOAT);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldComponentConstructor = function($arguments, type, matrixStride) {\r\n    var componentCount = type.componentCount();\r\n    var componentType = type.componentType();\r\n    var node = GLSLX.Node.createConstructorCall(type);\r\n    assert(componentCount > 0);\r\n\r\n    // Passing a single component as an argument always works\r\n    if ($arguments.length == 1) {\r\n      var argument = in_List.first($arguments);\r\n\r\n      if (argument.resolvedType != componentType) {\r\n        return null;\r\n      }\r\n\r\n      // When doing this with a matrix, only the diagonal is filled\r\n      var isMatrix = type.isMatrix();\r\n      var stride = type.indexCount();\r\n\r\n      // Fill the target by repeating the single component\r\n      for (var i = 0, count = componentCount; i < count; i = i + 1 | 0) {\r\n        var isOffMatrixDiagonal = isMatrix && (i % (stride + 1 | 0) | 0) != 0;\r\n        node.appendChild(isOffMatrixDiagonal ? new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(0).withType(GLSLX.Type.FLOAT) : argument.clone());\r\n      }\r\n    }\r\n\r\n    // If a matrix is constructed from a matrix, then each component (column i,\r\n    // row j) in the result that has a corresponding component (column i, row j)\r\n    // in the argument will be initialized from there. All other components will\r\n    // be initialized to the identity matrix.\r\n    else if (matrixStride != 0) {\r\n      var stride1 = type.indexCount();\r\n      assert(type.isMatrix());\r\n      assert(__imul(stride1, stride1) == componentCount);\r\n\r\n      for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\r\n        for (var col = 0, count1 = stride1; col < count1; col = col + 1 | 0) {\r\n          node.appendChild(col < matrixStride && row < matrixStride ? in_List.get($arguments, col + __imul(row, matrixStride) | 0) : new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(col == row ? 1 : 0).withType(GLSLX.Type.FLOAT));\r\n        }\r\n      }\r\n    }\r\n\r\n    // Multiple arguments are more involved\r\n    else {\r\n      // Extra arguments are ignored\r\n      if ($arguments.length < componentCount) {\r\n        return null;\r\n      }\r\n\r\n      // The constructed value is represented as a constructor call\r\n      for (var i1 = 0, count3 = componentCount; i1 < count3; i1 = i1 + 1 | 0) {\r\n        var argument1 = in_List.get($arguments, i1);\r\n\r\n        // All casts should be resolved by this point\r\n        if (argument1.resolvedType != componentType) {\r\n          return null;\r\n        }\r\n\r\n        node.appendChild(argument1);\r\n      }\r\n    }\r\n\r\n    // Don't wrap primitive types\r\n    if (type.indexType() == null) {\r\n      return node.lastChild().remove();\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n  GLSLX.Folder._foldStruct = function($arguments, type) {\r\n    var variables = type.symbol.asStruct().variables;\r\n    var node = GLSLX.Node.createConstructorCall(type);\r\n\r\n    // Structs can only be constructed with the exact number of arguments\r\n    if ($arguments.length != variables.length) {\r\n      return null;\r\n    }\r\n\r\n    // The constructed value is represented as a constructor call\r\n    for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n      if (in_List.get($arguments, i).resolvedType != in_List.get(variables, i).type.resolvedType) {\r\n        return null;\r\n      }\r\n\r\n      node.appendChild(in_List.get($arguments, i));\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryEquality = function(node) {\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    if (left != null && right != null) {\r\n      var value = left.looksTheSameAs(right);\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(node.kind == GLSLX.NodeKind.EQUAL ? value : !value).withType(GLSLX.Type.BOOL);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldComponentwiseUnary = function(node, componentType, argumentKind, op) {\r\n    if (node.kind == GLSLX.NodeKind.CALL && node.callTarget().kind == GLSLX.NodeKind.TYPE && node.callTarget().resolvedType.componentType() == componentType) {\r\n      var result = GLSLX.Node.createConstructorCall(node.callTarget().resolvedType);\r\n\r\n      for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\r\n        var folded = GLSLX.Folder.fold(child);\r\n\r\n        if (folded == null || folded.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result.appendChild(op(folded));\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldFloat1 = function(node, op) {\r\n    if (node.kind == GLSLX.NodeKind.FLOAT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(node.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(x) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(x.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldInt1 = function(node, op) {\r\n    if (node.kind == GLSLX.NodeKind.INT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(node.asInt())).withType(GLSLX.Type.INT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(x) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(x.asInt())).withType(GLSLX.Type.INT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldComponentwiseBinary = function(left, right, componentType, argumentKind, op) {\r\n    var leftHasComponents = left.kind == GLSLX.NodeKind.CALL && left.callTarget().kind == GLSLX.NodeKind.TYPE && left.callTarget().resolvedType.componentType() == componentType;\r\n    var rightHasComponents = right.kind == GLSLX.NodeKind.CALL && right.callTarget().kind == GLSLX.NodeKind.TYPE && right.callTarget().resolvedType.componentType() == componentType;\r\n\r\n    // Vector-vector binary operator\r\n    if (leftHasComponents && rightHasComponents && right.resolvedType == left.resolvedType) {\r\n      var result = GLSLX.Node.createConstructorCall(left.resolvedType);\r\n      var leftChild = left.callTarget().nextSibling();\r\n      var rightChild = right.callTarget().nextSibling();\r\n\r\n      while (leftChild != null && rightChild != null) {\r\n        var foldedLeft = GLSLX.Folder.fold(leftChild);\r\n        var foldedRight = GLSLX.Folder.fold(rightChild);\r\n\r\n        if (foldedLeft == null || foldedLeft.kind != argumentKind || foldedRight == null || foldedRight.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result.appendChild(op(foldedLeft, foldedRight));\r\n        leftChild = leftChild.nextSibling();\r\n        rightChild = rightChild.nextSibling();\r\n      }\r\n\r\n      if (leftChild == null && rightChild == null) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    // Vector-scalar binary operator\r\n    else if (leftHasComponents && right.kind == argumentKind) {\r\n      var result1 = GLSLX.Node.createConstructorCall(left.resolvedType);\r\n\r\n      for (var child = left.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\r\n        var folded = GLSLX.Folder.fold(child);\r\n\r\n        if (folded == null || folded.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result1.appendChild(op(folded, right));\r\n      }\r\n\r\n      return result1;\r\n    }\r\n\r\n    // Scalar-vector binary operator\r\n    else if (left.kind == argumentKind && rightHasComponents) {\r\n      var result2 = GLSLX.Node.createConstructorCall(right.resolvedType);\r\n\r\n      for (var child1 = right.callTarget().nextSibling(); child1 != null; child1 = child1.nextSibling()) {\r\n        var folded1 = GLSLX.Folder.fold(child1);\r\n\r\n        if (folded1 == null || folded1.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result2.appendChild(op(left, folded1));\r\n      }\r\n\r\n      return result2;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldFloat2 = function(left, right, op) {\r\n    if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(a, b) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(a.asFloat(), b.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldInt2 = function(left, right, op) {\r\n    if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(left.asInt(), right.asInt())).withType(GLSLX.Type.INT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(a, b) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(a.asInt(), b.asInt())).withType(GLSLX.Type.INT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldUnaryBool = function(node, op) {\r\n    var value = GLSLX.Folder.fold(node.unaryValue());\r\n\r\n    if (value != null && value.kind == GLSLX.NodeKind.BOOL) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(value.asBool())).withType(GLSLX.Type.BOOL);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldUnaryFloatOrInt = function(node, floatOp, intOp) {\r\n    var ref;\r\n    var value = GLSLX.Folder.fold(node.unaryValue());\r\n\r\n    if (value != null) {\r\n      return (ref = GLSLX.Folder._foldFloat1(value, floatOp)) != null ? ref : GLSLX.Folder._foldInt1(value, intOp);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryBool = function(node, op) {\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    if (left != null && right != null && left.kind == GLSLX.NodeKind.BOOL && right.kind == GLSLX.NodeKind.BOOL) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asBool(), right.asBool())).withType(GLSLX.Type.BOOL);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryFloatOrInt = function(node, floatOp, intOp) {\r\n    var ref;\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    if (left != null && right != null) {\r\n      return (ref = GLSLX.Folder._foldFloat2(left, right, floatOp)) != null ? ref : GLSLX.Folder._foldInt2(left, right, intOp);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryFloatOrIntToBool = function(node, op) {\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    // The comparison operators only work on scalars in GLSL. To do comparisons\r\n    // on vectors, the functions greaterThan(), lessThan(), greaterThanEqual(),\r\n    // and lessThanEqual() must be used.\r\n    if (left != null && right != null) {\r\n      if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.BOOL);\r\n      }\r\n\r\n      if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asInt(), right.asInt())).withType(GLSLX.Type.BOOL);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.DiagnosticKind = {\r\n    ERROR: 0,\r\n    WARNING: 1\r\n  };\r\n\r\n  GLSLX.Diagnostic = function(kind, range, text) {\r\n    this.kind = kind;\r\n    this.range = range;\r\n    this.text = text;\r\n    this.noteRange = null;\r\n    this.noteText = '';\r\n  };\r\n\r\n  GLSLX.Log = function() {\r\n    this.diagnostics = [];\r\n    this.warningCount = 0;\r\n    this.errorCount = 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.hasErrors = function() {\r\n    return this.errorCount != 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.error = function(range, text) {\r\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.ERROR, range, text));\r\n    this.errorCount = this.errorCount + 1 | 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.warning = function(range, text) {\r\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.WARNING, range, text));\r\n    this.warningCount = this.warningCount + 1 | 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.note = function(range, text) {\r\n    var last = in_List.last(this.diagnostics);\r\n    last.noteRange = range;\r\n    last.noteText = text;\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxWarningUnknownExtension = function(range, name) {\r\n    this.warning(range, 'The extension \"' + name + '\" is not in the known list of valid WebGL extensions');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInvalidString = function(range) {\r\n    this.error(range, 'Invalid string literal');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorDisabledExtension = function(range, name, extension) {\r\n    this.error(range, 'Cannot use \"' + name + '\" from disabled extension \"' + extension + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorExtraData = function(range, text) {\r\n    this.error(range, 'Syntax error \"' + text + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorReservedWord = function(range) {\r\n    this.error(range, '\"' + range.toString() + '\" is a reserved word');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorUnexpectedToken = function(token) {\r\n    this.error(token.range, 'Unexpected ' + in_List.get(GLSLX.in_TokenKind._strings, token.kind));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorExpectedToken1 = function(range, expected) {\r\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorExpectedToken2 = function(range, found, expected) {\r\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected) + ' but found ' + in_List.get(GLSLX.in_TokenKind._strings, found));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorBadSymbolReference = function(range) {\r\n    this.error(range, 'There is no symbol called \"' + range.toString() + '\" in the current scope');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorDuplicateSymbolDefinition = function(range, previous) {\r\n    this.error(range, 'There is already a symbol called \"' + range.toString() + '\" in the current scope');\r\n    this.note(previous, 'The previous definition of \"' + previous.toString() + '\" is here');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorOutsideLoop = function(range) {\r\n    this.error(range, 'This statement cannot be used outside a loop');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorStructVariableInitializer = function(range) {\r\n    this.error(range, 'Cannot initialize struct variables');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInsideStruct = function(range) {\r\n    this.error(range, 'This statement cannot be used inside a struct');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInsideFunction = function(range) {\r\n    this.error(range, 'This statement cannot be used inside a function');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorOutsideFunction = function(range) {\r\n    this.error(range, 'This statement cannot be used outside a function');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorIncludeWithoutFileAccess = function(range) {\r\n    this.error(range, 'Cannot include files without access to a file system');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorIncludeBadPath = function(range, path) {\r\n    this.error(range, 'Cannot read the file ' + JSON.stringify(path));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorDifferentReturnType = function(range, name, type, expected, previous) {\r\n    this.error(range, 'Cannot change the return type of \"' + name + '\" to type \"' + type.toString() + '\"');\r\n    this.note(previous, 'The forward declaration of \"' + name + '\" has a return type of \"' + expected.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorBadQualifier = function(range) {\r\n    this.error(range, 'Cannot use this qualifier here');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorConstantRequired = function(range) {\r\n    this.error(range, 'This value must be a compile-time constant');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInvalidArraySize = function(range, count) {\r\n    this.error(range, 'Cannot declare an array with a size of \"' + count.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorMissingArraySize = function(range) {\r\n    this.error(range, 'All array sizes must be specified');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorMultidimensionalArray = function(range) {\r\n    this.error(range, 'Multidimensional arrays are not a part of the language');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInvalidOperator = function(range) {\r\n    this.error(range, 'The operator \"' + range.toString() + '\" is reserved and cannot be used');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadConversion = function(range, from, to) {\r\n    this.error(range, 'Cannot convert from type \"' + from.toString() + '\" to type \"' + to.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorUnexpectedType = function(range, type) {\r\n    this.error(range, 'Unexpected type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadVariableType = function(range, type) {\r\n    this.error(range, 'Cannot create a variable of type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadMember = function(range, type, name) {\r\n    this.error(range, 'Cannot find \"' + name + '\" on type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadSwizzle = function(range, type, name) {\r\n    this.error(range, 'Invalid swizzle \"' + name + '\" on type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadSwizzleAssignment = function(range, field) {\r\n    this.error(range, 'The field \"' + field + '\" cannot be specified multiple times when used as a storage location');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorMustCallFunction = function(range, name) {\r\n    this.error(range, 'The function \"' + name + '\" must be called');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadCall = function(range, type) {\r\n    this.error(range, 'Cannot call type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadConstructorValue = function(range, type, $constructor) {\r\n    this.error(range, 'Cannot use value of type \"' + type.toString() + '\" when constructing type \"' + $constructor.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorExtraConstructorValue = function(range, type, count, total) {\r\n    this.error(range, 'The constructor for type \"' + type.toString() + '\" only takes ' + count.toString() + ' argument' + (count != 1 ? 's' : '') + ' and this argument would bring the total to ' + total.toString());\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadConstructorCount = function(range, type, count) {\r\n    this.error(range, 'Cannot construct type \"' + type.toString() + '\" with ' + count.toString() + ' argument' + (count != 1 ? 's' : ''));\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArgumentCountFunction = function(range, expected, found, name, $function) {\r\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when calling function \"' + name + '\"');\r\n\r\n    if ($function != null) {\r\n      this.note($function, 'The definition of function \"' + name + '\" is here');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArgumentCountConstructor = function(range, expected, found, name, struct) {\r\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when constructing type \"' + name + '\"');\r\n\r\n    if (struct != null) {\r\n      this.note(struct, 'The definition of struct \"' + name + '\" is here');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadOverloadMatch = function(range, name) {\r\n    this.error(range, 'No matching overload for function \"' + name + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadHookTypes = function(range, left, right) {\r\n    this.error(range, 'Cannot merge type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArrayHook = function(range, type) {\r\n    if (type.isArrayOf != null) {\r\n      this.error(range, 'Cannot use a conditional expression with array type \"' + type.toString() + '\"');\r\n    }\r\n\r\n    else {\r\n      this.error(range, 'Cannot use a conditional expression with type \"' + type.toString() + '\" because it contains an array');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArrayAssignment = function(range, type) {\r\n    if (type.isArrayOf != null) {\r\n      this.error(range, 'Cannot assign to array type \"' + type.toString() + '\"');\r\n    }\r\n\r\n    else {\r\n      this.error(range, 'Cannot assign to type \"' + type.toString() + '\" because it contains an array');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadUnaryOperator = function(range, operator, type) {\r\n    this.error(range, 'No unary operator \"' + operator + '\" for type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadBinaryOperator = function(range, operator, left, right) {\r\n    if (left == right) {\r\n      this.error(range, 'There is no operator \"' + operator + '\" defined for type \"' + left.toString() + '\"');\r\n    }\r\n\r\n    else {\r\n      this.error(range, 'No binary operator \"' + operator + '\" for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadIndex = function(range, left, right) {\r\n    this.error(range, 'No index operator for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorOutOfBoundsIndex = function(range, value, type) {\r\n    this.error(range, 'Index \"' + value.toString() + '\" is out of bounds for type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadStorage = function(range) {\r\n    this.error(range, 'Cannot store to this location');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorUninitializedConstant = function(range) {\r\n    this.error(range, 'Constants must be initialized');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorMissingReturn = function(range, name, type) {\r\n    this.error(range, 'All control paths for \"' + name + '\" must return a value of type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadMatrixConstructor = function(range) {\r\n    this.error(range, 'If a matrix argument is given to a matrix constructor, it is an error to have any other arguments');\r\n  };\r\n\r\n  GLSLX.NodeKind = {\r\n    // Other\r\n    GLOBAL: 0,\r\n    STRUCT_BLOCK: 1,\r\n    VARIABLE: 2,\r\n\r\n    // Statements\r\n    BLOCK: 3,\r\n    BREAK: 4,\r\n    CONTINUE: 5,\r\n    DISCARD: 6,\r\n    DO_WHILE: 7,\r\n    EXPRESSION: 8,\r\n    EXTENSION: 9,\r\n    FOR: 10,\r\n    FUNCTION: 11,\r\n    IF: 12,\r\n    MODIFIER_BLOCK: 13,\r\n    PRECISION: 14,\r\n    RETURN: 15,\r\n    STRUCT: 16,\r\n    VARIABLES: 17,\r\n    VERSION: 18,\r\n    WHILE: 19,\r\n\r\n    // Expressions\r\n    CALL: 20,\r\n    DOT: 21,\r\n    HOOK: 22,\r\n    NAME: 23,\r\n    PARSE_ERROR: 24,\r\n    SEQUENCE: 25,\r\n    TYPE: 26,\r\n    UNKNOWN_CONSTANT: 27,\r\n\r\n    // Literals\r\n    BOOL: 28,\r\n    FLOAT: 29,\r\n    INT: 30,\r\n\r\n    // Unary prefix\r\n    NEGATIVE: 31,\r\n    NOT: 32,\r\n    POSITIVE: 33,\r\n\r\n    // Unary prefix assign\r\n    PREFIX_DECREMENT: 34,\r\n    PREFIX_INCREMENT: 35,\r\n\r\n    // Unary postfix assign\r\n    POSTFIX_DECREMENT: 36,\r\n    POSTFIX_INCREMENT: 37,\r\n\r\n    // Binary\r\n    ADD: 38,\r\n    DIVIDE: 39,\r\n    EQUAL: 40,\r\n    GREATER_THAN: 41,\r\n    GREATER_THAN_OR_EQUAL: 42,\r\n    INDEX: 43,\r\n    LESS_THAN: 44,\r\n    LESS_THAN_OR_EQUAL: 45,\r\n    LOGICAL_AND: 46,\r\n    LOGICAL_OR: 47,\r\n    LOGICAL_XOR: 48,\r\n    MULTIPLY: 49,\r\n    NOT_EQUAL: 50,\r\n    SUBTRACT: 51,\r\n\r\n    // Binary assignment\r\n    ASSIGN: 52,\r\n    ASSIGN_ADD: 53,\r\n    ASSIGN_DIVIDE: 54,\r\n    ASSIGN_MULTIPLY: 55,\r\n    ASSIGN_SUBTRACT: 56\r\n  };\r\n\r\n  GLSLX.Node = function(kind) {\r\n    this.id = GLSLX.Node._createID();\r\n    this.kind = kind;\r\n    this.range = null;\r\n    this.internalRange = null;\r\n    this.symbol = null;\r\n    this.resolvedType = null;\r\n    this._literal = 0;\r\n    this._text = null;\r\n    this._parent = null;\r\n    this._firstChild = null;\r\n    this._lastChild = null;\r\n    this._previousSibling = null;\r\n    this._nextSibling = null;\r\n    this.hasControlFlowAtEnd = false;\r\n  };\r\n\r\n  GLSLX.Node.prototype._copyMembersFrom = function(node) {\r\n    this.kind = node.kind;\r\n    this.range = node.range;\r\n    this.internalRange = node.internalRange;\r\n    this.symbol = node.symbol;\r\n    this.resolvedType = node.resolvedType;\r\n    this._literal = node._literal;\r\n    this._text = node._text;\r\n  };\r\n\r\n  GLSLX.Node.prototype.cloneWithoutChildren = function() {\r\n    var clone = new GLSLX.Node(this.kind);\r\n    clone._copyMembersFrom(this);\r\n    return clone;\r\n  };\r\n\r\n  GLSLX.Node.prototype.clone = function() {\r\n    var clone = this.cloneWithoutChildren();\r\n\r\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\r\n      clone.appendChild(child.clone());\r\n    }\r\n\r\n    return clone;\r\n  };\r\n\r\n  GLSLX.Node.prototype.parent = function() {\r\n    return this._parent;\r\n  };\r\n\r\n  GLSLX.Node.prototype.firstChild = function() {\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.lastChild = function() {\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.nextSibling = function() {\r\n    return this._nextSibling;\r\n  };\r\n\r\n  // This is cheaper than childCount == 0\r\n  GLSLX.Node.prototype.hasChildren = function() {\r\n    return this._firstChild != null;\r\n  };\r\n\r\n  GLSLX.Node.prototype.childCount = function() {\r\n    var count = 0;\r\n\r\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\r\n      count = count + 1 | 0;\r\n    }\r\n\r\n    return count;\r\n  };\r\n\r\n  GLSLX.Node.prototype.childAt = function(index) {\r\n    assert(0 <= index && index < this.childCount());\r\n    var child = this._firstChild;\r\n\r\n    while (index != 0) {\r\n      child = child._nextSibling;\r\n      index = index - 1 | 0;\r\n    }\r\n\r\n    return child;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withType = function(value) {\r\n    this.resolvedType = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withSymbol = function(value) {\r\n    this.symbol = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withBool = function(value) {\r\n    this._literal = +value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withInt = function(value) {\r\n    this._literal = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withFloat = function(value) {\r\n    this._literal = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withText = function(value) {\r\n    this._text = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withRange = function(value) {\r\n    this.range = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withInternalRange = function(value) {\r\n    this.internalRange = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.appendChild = function(node) {\r\n    if (node == null) {\r\n      return this;\r\n    }\r\n\r\n    assert(node != this);\r\n    assert(node._parent == null);\r\n    assert(node._previousSibling == null);\r\n    assert(node._nextSibling == null);\r\n    node._parent = this;\r\n\r\n    if (this.hasChildren()) {\r\n      node._previousSibling = this._lastChild;\r\n      this._lastChild._nextSibling = node;\r\n      this._lastChild = node;\r\n    }\r\n\r\n    else {\r\n      this._lastChild = this._firstChild = node;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.remove = function() {\r\n    assert(this._parent != null);\r\n\r\n    if (this._previousSibling != null) {\r\n      assert(this._previousSibling._nextSibling == this);\r\n      this._previousSibling._nextSibling = this._nextSibling;\r\n    }\r\n\r\n    else {\r\n      assert(this._parent._firstChild == this);\r\n      this._parent._firstChild = this._nextSibling;\r\n    }\r\n\r\n    if (this._nextSibling != null) {\r\n      assert(this._nextSibling._previousSibling == this);\r\n      this._nextSibling._previousSibling = this._previousSibling;\r\n    }\r\n\r\n    else {\r\n      assert(this._parent._lastChild == this);\r\n      this._parent._lastChild = this._previousSibling;\r\n    }\r\n\r\n    this._parent = null;\r\n    this._previousSibling = null;\r\n    this._nextSibling = null;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.insertChildBefore = function(after, before) {\r\n    if (before == null) {\r\n      return this;\r\n    }\r\n\r\n    assert(before != after);\r\n    assert(before._parent == null);\r\n    assert(before._previousSibling == null);\r\n    assert(before._nextSibling == null);\r\n    assert(after == null || after._parent == this);\r\n\r\n    if (after == null) {\r\n      return this.appendChild(before);\r\n    }\r\n\r\n    before._parent = this;\r\n    before._previousSibling = after._previousSibling;\r\n    before._nextSibling = after;\r\n\r\n    if (after._previousSibling != null) {\r\n      assert(after == after._previousSibling._nextSibling);\r\n      after._previousSibling._nextSibling = before;\r\n    }\r\n\r\n    else {\r\n      assert(after == this._firstChild);\r\n      this._firstChild = before;\r\n    }\r\n\r\n    after._previousSibling = before;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.isTrue = function() {\r\n    return this.kind == GLSLX.NodeKind.BOOL && this.asBool();\r\n  };\r\n\r\n  GLSLX.Node.prototype.isFalse = function() {\r\n    return this.kind == GLSLX.NodeKind.BOOL && !this.asBool();\r\n  };\r\n\r\n  GLSLX.Node.prototype.isCallTarget = function() {\r\n    return this.parent() != null && this.parent().kind == GLSLX.NodeKind.CALL && this.parent().callTarget() == this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.isAssignTarget = function() {\r\n    return this.parent() != null && (GLSLX.in_NodeKind.isUnaryAssign(this.parent().kind) || GLSLX.in_NodeKind.isBinaryAssign(this.parent().kind) && this.parent().binaryLeft() == this);\r\n  };\r\n\r\n  GLSLX.Node.prototype.isEmptySequence = function() {\r\n    return this.kind == GLSLX.NodeKind.SEQUENCE && !this.hasChildren();\r\n  };\r\n\r\n  GLSLX.Node.prototype.looksTheSameAs = function(node) {\r\n    if (this.kind == node.kind) {\r\n      switch (this.kind) {\r\n        case GLSLX.NodeKind.BOOL: {\r\n          return this.asBool() == node.asBool();\r\n        }\r\n\r\n        case GLSLX.NodeKind.FLOAT: {\r\n          return this.asFloat() == node.asFloat();\r\n        }\r\n\r\n        case GLSLX.NodeKind.INT: {\r\n          return this.asInt() == node.asInt();\r\n        }\r\n\r\n        case GLSLX.NodeKind.NAME: {\r\n          return this.symbol == node.symbol;\r\n        }\r\n\r\n        case GLSLX.NodeKind.TYPE: {\r\n          return this.resolvedType == node.resolvedType;\r\n        }\r\n\r\n        case GLSLX.NodeKind.DOT: {\r\n          return this.dotTarget().looksTheSameAs(node.dotTarget()) && this.symbol == node.symbol && this.asString() == node.asString();\r\n        }\r\n\r\n        case GLSLX.NodeKind.HOOK: {\r\n          return this.hookTest().looksTheSameAs(node.hookTest()) && this.hookTrue().looksTheSameAs(node.hookTrue()) && this.hookFalse().looksTheSameAs(node.hookFalse());\r\n        }\r\n\r\n        case GLSLX.NodeKind.CALL: {\r\n          var left = this.firstChild();\r\n          var right = node.firstChild();\r\n\r\n          while (left != null && right != null) {\r\n            if (!left.looksTheSameAs(right)) {\r\n              return false;\r\n            }\r\n\r\n            left = left.nextSibling();\r\n            right = right.nextSibling();\r\n          }\r\n\r\n          return left == null && right == null;\r\n        }\r\n\r\n        default: {\r\n          if (GLSLX.in_NodeKind.isUnary(this.kind)) {\r\n            return this.unaryValue().looksTheSameAs(node.unaryValue());\r\n          }\r\n\r\n          if (GLSLX.in_NodeKind.isBinary(this.kind)) {\r\n            return this.binaryLeft().looksTheSameAs(node.binaryLeft()) && this.binaryRight().looksTheSameAs(node.binaryRight());\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  GLSLX.Node.createDoWhile = function(body, test) {\r\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.DO_WHILE).appendChild(body).appendChild(test);\r\n  };\r\n\r\n  GLSLX.Node.createExpression = function(value) {\r\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.EXPRESSION).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createFor = function(setup, test, update, body) {\r\n    assert(setup == null || GLSLX.in_NodeKind.isExpression(setup.kind) || setup.kind == GLSLX.NodeKind.VARIABLES);\r\n    assert(test == null || GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(update == null || GLSLX.in_NodeKind.isExpression(update.kind));\r\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.FOR).appendChild(setup == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : setup).appendChild(test == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : test).appendChild(update == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : update).appendChild(body);\r\n  };\r\n\r\n  GLSLX.Node.createIf = function(test, yes, no) {\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(GLSLX.in_NodeKind.isStatement(yes.kind));\r\n    assert(no == null || GLSLX.in_NodeKind.isStatement(no.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.IF).appendChild(test).appendChild(yes).appendChild(no);\r\n  };\r\n\r\n  GLSLX.Node.createPrecision = function(flags, type) {\r\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.PRECISION).withInt(flags).appendChild(type);\r\n  };\r\n\r\n  GLSLX.Node.createReturn = function(value) {\r\n    assert(value == null || GLSLX.in_NodeKind.isExpression(value.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.RETURN).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createStruct = function(symbol, block, variables) {\r\n    assert(block.kind == GLSLX.NodeKind.STRUCT_BLOCK);\r\n    assert(variables == null || variables.kind == GLSLX.NodeKind.VARIABLES);\r\n    return new GLSLX.Node(GLSLX.NodeKind.STRUCT).withSymbol(symbol).appendChild(block).appendChild(variables);\r\n  };\r\n\r\n  GLSLX.Node.createVariables = function(flags, type) {\r\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.VARIABLES).withInt(flags).appendChild(type);\r\n  };\r\n\r\n  GLSLX.Node.createWhile = function(test, body) {\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.WHILE).appendChild(test).appendChild(body);\r\n  };\r\n\r\n  GLSLX.Node.createCall = function(value) {\r\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.CALL).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createConstructorCall = function(type) {\r\n    return GLSLX.Node.createCall(new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type)).withType(type);\r\n  };\r\n\r\n  GLSLX.Node.createDot = function(value, text) {\r\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\r\n    assert(text != null);\r\n    return new GLSLX.Node(GLSLX.NodeKind.DOT).appendChild(value).withText(text);\r\n  };\r\n\r\n  GLSLX.Node.createHook = function(test, yes, no) {\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(GLSLX.in_NodeKind.isExpression(yes.kind));\r\n    assert(GLSLX.in_NodeKind.isExpression(no.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.HOOK).appendChild(test).appendChild(yes).appendChild(no);\r\n  };\r\n\r\n  GLSLX.Node.createUnary = function(kind, value) {\r\n    assert(GLSLX.in_NodeKind.isUnary(kind));\r\n    return new GLSLX.Node(kind).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createBinary = function(kind, left, right) {\r\n    assert(GLSLX.in_NodeKind.isBinary(kind));\r\n    return new GLSLX.Node(kind).appendChild(left).appendChild(right);\r\n  };\r\n\r\n  GLSLX.Node.prototype.doWhileBody = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.doWhileTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.expressionValue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.EXPRESSION);\r\n    assert(this.childCount() == 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forSetup = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind) || this._firstChild.kind == GLSLX.NodeKind.VARIABLES);\r\n    return this._firstChild.isEmptySequence() ? null : this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind) || this._firstChild._nextSibling.kind == GLSLX.NodeKind.VARIABLES);\r\n    return this._firstChild._nextSibling.isEmptySequence() ? null : this._firstChild._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forUpdate = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild._previousSibling.kind));\r\n    return this._lastChild._previousSibling.isEmptySequence() ? null : this._lastChild._previousSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forBody = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.ifTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.IF);\r\n    assert(this.childCount() == 2 || this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.ifTrue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.IF);\r\n    assert(this.childCount() == 2 || this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling.kind));\r\n    return this._firstChild._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.ifFalse = function() {\r\n    assert(this.kind == GLSLX.NodeKind.IF);\r\n    assert(this.childCount() == 2 || this.childCount() == 3);\r\n    assert(this._firstChild._nextSibling._nextSibling == null || GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling._nextSibling.kind));\r\n    return this._firstChild._nextSibling._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.returnValue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.RETURN);\r\n    assert(this.childCount() <= 1);\r\n    assert(this._firstChild == null || GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.variablesType = function() {\r\n    assert(this.kind == GLSLX.NodeKind.VARIABLES);\r\n    assert(this.childCount() >= 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.whileTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.whileBody = function() {\r\n    assert(this.kind == GLSLX.NodeKind.WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.callTarget = function() {\r\n    assert(this.kind == GLSLX.NodeKind.CALL);\r\n    assert(this.childCount() >= 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.dotTarget = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DOT);\r\n    assert(this.childCount() == 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.hookTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.HOOK);\r\n    assert(this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.hookTrue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.HOOK);\r\n    assert(this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind));\r\n    return this._firstChild._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.hookFalse = function() {\r\n    assert(this.kind == GLSLX.NodeKind.HOOK);\r\n    assert(this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asString = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DOT);\r\n    assert(this._text != null);\r\n    return this._text;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asBool = function() {\r\n    assert(this.kind == GLSLX.NodeKind.BOOL);\r\n    return !!this._literal;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asFloat = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FLOAT);\r\n    return this._literal;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asInt = function() {\r\n    assert(this.kind == GLSLX.NodeKind.INT);\r\n    return this._literal | 0;\r\n  };\r\n\r\n  GLSLX.Node.prototype.unaryValue = function() {\r\n    assert(GLSLX.in_NodeKind.isUnary(this.kind));\r\n    assert(this.childCount() == 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.binaryLeft = function() {\r\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.binaryRight = function() {\r\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node._createID = function() {\r\n    GLSLX.Node._nextID = GLSLX.Node._nextID + 1 | 0;\r\n    return GLSLX.Node._nextID;\r\n  };\r\n\r\n  GLSLX.Parser = {};\r\n\r\n  GLSLX.Parser.typeParselet = function(type) {\r\n    return function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.unaryPrefix = function(kind) {\r\n    assert(GLSLX.in_NodeKind.isUnaryPrefix(kind));\r\n    return function(context, token, value) {\r\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(token.range, value.range)).withInternalRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.unaryPostfix = function(kind) {\r\n    assert(GLSLX.in_NodeKind.isUnaryPostfix(kind));\r\n    return function(context, value, token) {\r\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(value.range, token.range)).withInternalRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.binaryParselet = function(kind) {\r\n    assert(GLSLX.in_NodeKind.isBinary(kind));\r\n    return function(context, left, token, right) {\r\n      return GLSLX.Node.createBinary(kind, left, right).withRange(GLSLX.Range.span(left.range, right.range)).withInternalRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.parseInt = function(text) {\r\n    if (text.length > 1 && in_string.get1(text, 0) == 48 && (in_string.get1(text, 1) != 120 && in_string.get1(text, 1) != 88)) {\r\n      return parseInt(text, 8);\r\n    }\r\n\r\n    return text | 0;\r\n  };\r\n\r\n  GLSLX.Parser.createExpressionParser = function() {\r\n    var pratt = new GLSLX.Pratt();\r\n    var invalidUnaryOperator = function(context, token, value) {\r\n      context.log.syntaxErrorInvalidOperator(token.range);\r\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(token.range, value.range));\r\n    };\r\n    var invalidBinaryOperator = function(context, left, token, right) {\r\n      context.log.syntaxErrorInvalidOperator(token.range);\r\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(left.range, right.range));\r\n    };\r\n    pratt.literal(GLSLX.TokenKind.TRUE, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(true).withType(GLSLX.Type.BOOL).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.FALSE, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(false).withType(GLSLX.Type.BOOL).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.INT_LITERAL, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(GLSLX.Parser.parseInt(token.range.toString())).withType(GLSLX.Type.INT).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.FLOAT_LITERAL, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(+token.range.toString()).withType(GLSLX.Type.FLOAT).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.BOOL, GLSLX.Parser.typeParselet(GLSLX.Type.BOOL));\r\n    pratt.literal(GLSLX.TokenKind.BVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC2));\r\n    pratt.literal(GLSLX.TokenKind.BVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC3));\r\n    pratt.literal(GLSLX.TokenKind.BVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC4));\r\n    pratt.literal(GLSLX.TokenKind.FLOAT, GLSLX.Parser.typeParselet(GLSLX.Type.FLOAT));\r\n    pratt.literal(GLSLX.TokenKind.INT, GLSLX.Parser.typeParselet(GLSLX.Type.INT));\r\n    pratt.literal(GLSLX.TokenKind.IVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC2));\r\n    pratt.literal(GLSLX.TokenKind.IVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC3));\r\n    pratt.literal(GLSLX.TokenKind.IVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC4));\r\n    pratt.literal(GLSLX.TokenKind.MAT2, GLSLX.Parser.typeParselet(GLSLX.Type.MAT2));\r\n    pratt.literal(GLSLX.TokenKind.MAT3, GLSLX.Parser.typeParselet(GLSLX.Type.MAT3));\r\n    pratt.literal(GLSLX.TokenKind.MAT4, GLSLX.Parser.typeParselet(GLSLX.Type.MAT4));\r\n    pratt.literal(GLSLX.TokenKind.VEC2, GLSLX.Parser.typeParselet(GLSLX.Type.VEC2));\r\n    pratt.literal(GLSLX.TokenKind.VEC3, GLSLX.Parser.typeParselet(GLSLX.Type.VEC3));\r\n    pratt.literal(GLSLX.TokenKind.VEC4, GLSLX.Parser.typeParselet(GLSLX.Type.VEC4));\r\n    pratt.literal(GLSLX.TokenKind.VOID, GLSLX.Parser.typeParselet(GLSLX.Type.VOID));\r\n    pratt.prefix(GLSLX.TokenKind.COMPLEMENT, GLSLX.Precedence.UNARY_PREFIX, invalidUnaryOperator);\r\n    pratt.prefix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_DECREMENT));\r\n    pratt.prefix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_INCREMENT));\r\n    pratt.prefix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NEGATIVE));\r\n    pratt.prefix(GLSLX.TokenKind.NOT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NOT));\r\n    pratt.prefix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.POSITIVE));\r\n    pratt.postfix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_DECREMENT));\r\n    pratt.postfix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_INCREMENT));\r\n    pratt.infix(GLSLX.TokenKind.DIVIDE, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.DIVIDE));\r\n    pratt.infix(GLSLX.TokenKind.EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN));\r\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN_OR_EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.LESS_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN));\r\n    pratt.infix(GLSLX.TokenKind.LESS_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN_OR_EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.SUBTRACT));\r\n    pratt.infix(GLSLX.TokenKind.MULTIPLY, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.MULTIPLY));\r\n    pratt.infix(GLSLX.TokenKind.NOT_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.NOT_EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ADD));\r\n    pratt.infix(GLSLX.TokenKind.REMAINDER, GLSLX.Precedence.MULTIPLY, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.SHIFT_LEFT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.SHIFT_RIGHT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.LOGICAL_OR, GLSLX.Precedence.LOGICAL_OR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_OR));\r\n    pratt.infix(GLSLX.TokenKind.LOGICAL_XOR, GLSLX.Precedence.LOGICAL_XOR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_XOR));\r\n    pratt.infix(GLSLX.TokenKind.LOGICAL_AND, GLSLX.Precedence.LOGICAL_AND, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_AND));\r\n    pratt.infix(GLSLX.TokenKind.BITWISE_AND, GLSLX.Precedence.BITWISE_AND, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.BITWISE_OR, GLSLX.Precedence.BITWISE_OR, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.BITWISE_XOR, GLSLX.Precedence.BITWISE_XOR, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_ADD, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_ADD));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_AND, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_OR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_XOR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_DIVIDE, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_DIVIDE));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_MULTIPLY, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_MULTIPLY));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_REMAINDER, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_LEFT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SUBTRACT, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_SUBTRACT));\r\n\r\n    // Name\r\n    pratt.literal(GLSLX.TokenKind.IDENTIFIER, function(context, token) {\r\n      var name = token.range.toString();\r\n      var symbol = context.scope().find(name);\r\n\r\n      if (symbol == null) {\r\n        context.log.syntaxErrorBadSymbolReference(token.range);\r\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(token.range);\r\n      }\r\n\r\n      // Check extension usage\r\n      if (symbol.requiredExtension != null && context.compilationData.extensionBehavior(symbol.requiredExtension) == GLSLX.ExtensionBehavior.DISABLE) {\r\n        context.log.syntaxErrorDisabledExtension(token.range, name, symbol.requiredExtension);\r\n      }\r\n\r\n      return (symbol.isStruct() ? new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()) : new GLSLX.Node(GLSLX.NodeKind.NAME).withSymbol(symbol)).withRange(token.range);\r\n    });\r\n\r\n    // Sequence\r\n    pratt.infix(GLSLX.TokenKind.COMMA, GLSLX.Precedence.COMMA, function(context, left, token, right) {\r\n      if (left.kind != GLSLX.NodeKind.SEQUENCE) {\r\n        left = new GLSLX.Node(GLSLX.NodeKind.SEQUENCE).appendChild(left).withRange(left.range);\r\n      }\r\n\r\n      left.appendChild(right);\r\n      return left.withRange(context.spanSince(left.range));\r\n    });\r\n\r\n    // Dot\r\n    pratt.parselet(GLSLX.TokenKind.DOT, GLSLX.Precedence.MEMBER).infix = function(context, left) {\r\n      context.next();\r\n      var name = context.current().range;\r\n\r\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Node.createDot(left, name.toString()).withRange(context.spanSince(left.range)).withInternalRange(name);\r\n    };\r\n\r\n    // Group\r\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.LOWEST).prefix = function(context) {\r\n      var token = context.next();\r\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n\r\n      return value.withRange(context.spanSince(token.range));\r\n    };\r\n\r\n    // Call\r\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.UNARY_POSTFIX).infix = function(context, left) {\r\n      var token = context.next();\r\n      var node = GLSLX.Node.createCall(left);\r\n\r\n      if (!GLSLX.Parser.parseCommaSeparatedList(context, node, GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n\r\n      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\r\n    };\r\n\r\n    // Index\r\n    pratt.parselet(GLSLX.TokenKind.LEFT_BRACKET, GLSLX.Precedence.MEMBER).infix = function(context, left) {\r\n      var token = context.next();\r\n\r\n      // The \"[]\" syntax isn't valid but skip over it and recover\r\n      if (context.peek(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        context.unexpectedToken();\r\n        context.next();\r\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(context.spanSince(token.range));\r\n      }\r\n\r\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Node.createBinary(GLSLX.NodeKind.INDEX, left, value).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\r\n    };\r\n\r\n    // Hook\r\n    pratt.parselet(GLSLX.TokenKind.QUESTION, GLSLX.Precedence.ASSIGN).infix = function(context, left) {\r\n      context.next();\r\n      var middle = pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n      if (middle == null || !context.expect(GLSLX.TokenKind.COLON)) {\r\n        return null;\r\n      }\r\n\r\n      var right = pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n      if (right == null) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Node.createHook(left, middle, right).withRange(context.spanSince(left.range));\r\n    };\r\n    return pratt;\r\n  };\r\n\r\n  GLSLX.Parser.parseCommaSeparatedList = function(context, parent, stop) {\r\n    var isFirst = true;\r\n\r\n    while (!context.eat(stop)) {\r\n      if (!isFirst && !context.expect(GLSLX.TokenKind.COMMA)) {\r\n        return false;\r\n      }\r\n\r\n      var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n      if (value == null) {\r\n        return false;\r\n      }\r\n\r\n      parent.appendChild(value);\r\n      isFirst = false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseDoWhile = function(context) {\r\n    var token = context.next();\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\r\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (body == null || !context.expect(GLSLX.TokenKind.WHILE) || !context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (test == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createDoWhile(body, test));\r\n  };\r\n\r\n  GLSLX.Parser.parseExportOrImport = function(context) {\r\n    var token = context.next();\r\n    var old = context.flags;\r\n    context.flags |= token.kind == GLSLX.TokenKind.EXPORT ? GLSLX.SymbolFlags.EXPORTED : GLSLX.SymbolFlags.IMPORTED;\r\n\r\n    // Parse a modifier block\r\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\r\n      var node = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\r\n\r\n      if (!GLSLX.Parser.parseStatements(context, node, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n        return null;\r\n      }\r\n\r\n      context.flags = old;\r\n      return node.withRange(context.spanSince(token.range));\r\n    }\r\n\r\n    // Just parse a single statement\r\n    var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.GLOBAL);\r\n\r\n    if (statement == null) {\r\n      return null;\r\n    }\r\n\r\n    context.flags = old;\r\n    return statement;\r\n  };\r\n\r\n  GLSLX.Parser.parseExtension = function(context) {\r\n    var token = context.next();\r\n    var range = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n      return null;\r\n    }\r\n\r\n    var name = range.toString();\r\n\r\n    // Parse an extension block (a non-standard addition)\r\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\r\n      if (!(name in context.compilationData.currentExtensions)) {\r\n        // Silence warnings about this name\r\n        context.compilationData.currentExtensions[name] = GLSLX.ExtensionBehavior.DEFAULT;\r\n      }\r\n\r\n      var block = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\r\n\r\n      if (!GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n        return null;\r\n      }\r\n\r\n      for (var child = block.firstChild(); child != null; child = child.nextSibling()) {\r\n        if (child.kind == GLSLX.NodeKind.VARIABLES) {\r\n          for (var variable = child.variablesType().nextSibling(); variable != null; variable = variable.nextSibling()) {\r\n            variable.symbol.requiredExtension = name;\r\n          }\r\n        }\r\n\r\n        else if (child.symbol != null) {\r\n          child.symbol.requiredExtension = name;\r\n        }\r\n      }\r\n\r\n      return block.withRange(context.spanSince(token.range));\r\n    }\r\n\r\n    // Warn about typos\r\n    if (!(name in GLSLX.Parser._knownWebGLExtensions) && !(name in context.compilationData.currentExtensions)) {\r\n      context.log.syntaxWarningUnknownExtension(range, name);\r\n    }\r\n\r\n    // Parse a regular extension pragma\r\n    if (!context.expect(GLSLX.TokenKind.COLON)) {\r\n      return null;\r\n    }\r\n\r\n    var text = context.current().range.toString();\r\n\r\n    if (!(text in GLSLX.Parser._extensionBehaviors)) {\r\n      context.unexpectedToken();\r\n      return null;\r\n    }\r\n\r\n    context.next();\r\n\r\n    // Activate or deactivate the extension\r\n    var behavior = in_StringMap.get1(GLSLX.Parser._extensionBehaviors, text);\r\n    context.compilationData.currentExtensions[name] = behavior;\r\n    return new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(behavior).withRange(context.spanSince(token.range)).withInternalRange(range);\r\n  };\r\n\r\n  GLSLX.Parser.parseFor = function(context) {\r\n    var token = context.next();\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    // Setup\r\n    var setup = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\r\n      // Check for a type\r\n      var flags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.LOCAL);\r\n      var type = null;\r\n\r\n      if (flags != 0) {\r\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n        if (type == null) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      else {\r\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\r\n      }\r\n\r\n      // Try to parse a variable\r\n      if (type != null) {\r\n        setup = GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.AVOID_FUNCTIONS);\r\n\r\n        if (setup == null) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      else {\r\n        setup = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n        if (setup == null) {\r\n          return null;\r\n        }\r\n\r\n        if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Test\r\n    var test = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\r\n      test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (test == null) {\r\n        return null;\r\n      }\r\n\r\n      if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Update\r\n    var update = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      update = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (update == null) {\r\n        return null;\r\n      }\r\n\r\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Body\r\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (body == null) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return GLSLX.Node.createFor(setup, test, update, body).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseIf = function(context) {\r\n    var token = context.next();\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (test == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var yes = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (yes == null) {\r\n      return null;\r\n    }\r\n\r\n    var no = null;\r\n\r\n    if (context.eat(GLSLX.TokenKind.ELSE)) {\r\n      no = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n      if (no == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return GLSLX.Node.createIf(test, yes, no).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseVersion = function(context) {\r\n    var token = context.next();\r\n    var range = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.INT_LITERAL)) {\r\n      return null;\r\n    }\r\n\r\n    return new GLSLX.Node(GLSLX.NodeKind.VERSION).withInt(range.toString() | 0).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseWhile = function(context) {\r\n    var token = context.next();\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (test == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (body == null) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return GLSLX.Node.createWhile(test, body).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseReturn = function(context) {\r\n    var token = context.next();\r\n    var value = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\r\n      value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n\r\n      context.expect(GLSLX.TokenKind.SEMICOLON);\r\n    }\r\n\r\n    return GLSLX.Node.createReturn(value).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parsePrecision = function(context) {\r\n    var token = context.next();\r\n    var flag = 0;\r\n\r\n    switch (context.current().kind) {\r\n      case GLSLX.TokenKind.LOWP: {\r\n        flag = GLSLX.SymbolFlags.LOWP;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MEDIUMP: {\r\n        flag = GLSLX.SymbolFlags.MEDIUMP;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.HIGHP: {\r\n        flag = GLSLX.SymbolFlags.HIGHP;\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        context.unexpectedToken();\r\n        return null;\r\n      }\r\n    }\r\n\r\n    context.next();\r\n    var type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n    if (type == null) {\r\n      return null;\r\n    }\r\n\r\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createPrecision(flag, type));\r\n  };\r\n\r\n  GLSLX.Parser.parseStruct = function(context, flags) {\r\n    var name = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n      return null;\r\n    }\r\n\r\n    var symbol = new GLSLX.StructSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.STRUCT, context.scope()));\r\n    symbol.flags |= context.flags | flags;\r\n\r\n    if (!GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol)) {\r\n      return null;\r\n    }\r\n\r\n    var range = context.current().range;\r\n    var block = new GLSLX.Node(GLSLX.NodeKind.STRUCT_BLOCK);\r\n    var variables = null;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE)) {\r\n      return null;\r\n    }\r\n\r\n    context.pushScope(symbol.scope);\r\n\r\n    while (!context.peek(GLSLX.TokenKind.RIGHT_BRACE) && !context.peek(GLSLX.TokenKind.END_OF_FILE)) {\r\n      var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.STRUCT);\r\n\r\n      if (statement == null) {\r\n        return null;\r\n      }\r\n\r\n      if (statement.kind != GLSLX.NodeKind.VARIABLES) {\r\n        context.log.syntaxErrorInsideStruct(statement.range);\r\n        continue;\r\n      }\r\n\r\n      block.appendChild(statement);\r\n\r\n      for (var child = statement.variablesType().nextSibling(); child != null; child = child.nextSibling()) {\r\n        var variable = child.symbol.asVariable();\r\n        symbol.variables.push(variable);\r\n\r\n        if (variable.value != null) {\r\n          context.log.syntaxErrorStructVariableInitializer(variable.value.range);\r\n        }\r\n      }\r\n    }\r\n\r\n    context.popScope();\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n      return null;\r\n    }\r\n\r\n    block.withRange(context.spanSince(range));\r\n\r\n    // Parse weird struct-variable hybrid things\r\n    //\r\n    //   struct S { int x; } y, z[2];\r\n    //\r\n    if (context.peek(GLSLX.TokenKind.IDENTIFIER)) {\r\n      variables = GLSLX.Parser.parseVariables(0, new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()), context.next().range, context);\r\n\r\n      if (variables == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    else {\r\n      context.expect(GLSLX.TokenKind.SEMICOLON);\r\n    }\r\n\r\n    return GLSLX.Node.createStruct(symbol, block, variables);\r\n  };\r\n\r\n  GLSLX.Parser.checkForLoopAndSemicolon = function(context, range, node) {\r\n    var found = false;\r\n\r\n    for (var scope = context.scope(); scope != null; scope = scope.parent) {\r\n      if (scope.kind == GLSLX.ScopeKind.LOOP) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!found) {\r\n      context.log.syntaxErrorOutsideLoop(range);\r\n    }\r\n\r\n    return GLSLX.Parser.checkForSemicolon(context, range, node);\r\n  };\r\n\r\n  GLSLX.Parser.checkForSemicolon = function(context, range, node) {\r\n    context.expect(GLSLX.TokenKind.SEMICOLON);\r\n    return node.withRange(context.spanSince(range));\r\n  };\r\n\r\n  GLSLX.Parser.parseAfterType = function(context, range, flags, type, allow) {\r\n    var name = context.current().range;\r\n\r\n    if (flags == 0 && !context.peek(GLSLX.TokenKind.IDENTIFIER)) {\r\n      var value = GLSLX.Parser.pratt.resume(context, GLSLX.Precedence.LOWEST, type);\r\n\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Parser.checkForSemicolon(context, range, GLSLX.Node.createExpression(value));\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n      return null;\r\n    }\r\n\r\n    if (context.eat(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return GLSLX.Parser.parseFunction(flags, type, name, context);\r\n    }\r\n\r\n    var variables = GLSLX.Parser.parseVariables(flags, type, name, context);\r\n\r\n    if (variables == null) {\r\n      return null;\r\n    }\r\n\r\n    return variables.withRange(context.spanSince(range));\r\n  };\r\n\r\n  GLSLX.Parser.parseStatement = function(context, mode) {\r\n    var token = context.current();\r\n\r\n    switch (token.kind) {\r\n      case GLSLX.TokenKind.BREAK: {\r\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.BREAK));\r\n      }\r\n\r\n      case GLSLX.TokenKind.CONTINUE: {\r\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.CONTINUE));\r\n      }\r\n\r\n      case GLSLX.TokenKind.DISCARD: {\r\n        return GLSLX.Parser.checkForSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.DISCARD));\r\n      }\r\n\r\n      case GLSLX.TokenKind.DO: {\r\n        return GLSLX.Parser.parseDoWhile(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.EXPORT:\r\n      case GLSLX.TokenKind.IMPORT: {\r\n        return GLSLX.Parser.parseExportOrImport(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.EXTENSION: {\r\n        return GLSLX.Parser.parseExtension(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.FOR: {\r\n        return GLSLX.Parser.parseFor(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.IF: {\r\n        return GLSLX.Parser.parseIf(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.LEFT_BRACE: {\r\n        return GLSLX.Parser.parseBlock(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.PRECISION: {\r\n        return GLSLX.Parser.parsePrecision(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.RETURN: {\r\n        return GLSLX.Parser.parseReturn(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.SEMICOLON: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BLOCK).withRange(context.next().range);\r\n      }\r\n\r\n      case GLSLX.TokenKind.VERSION: {\r\n        return GLSLX.Parser.parseVersion(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.WHILE: {\r\n        return GLSLX.Parser.parseWhile(context);\r\n      }\r\n    }\r\n\r\n    // Try to parse a variable or function\r\n    var flags = GLSLX.Parser.parseFlags(context, mode);\r\n    var type = null;\r\n\r\n    if (context.eat(GLSLX.TokenKind.STRUCT)) {\r\n      var struct = GLSLX.Parser.parseStruct(context, flags);\r\n\r\n      if (struct == null) {\r\n        return null;\r\n      }\r\n\r\n      return struct.withRange(context.spanSince(token.range));\r\n    }\r\n\r\n    if (flags != 0) {\r\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n      if (type == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    else {\r\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\r\n    }\r\n\r\n    if (type != null) {\r\n      return GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.ALLOW_FUNCTIONS);\r\n    }\r\n\r\n    // Parse an expression\r\n    var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (value == null) {\r\n      return null;\r\n    }\r\n\r\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createExpression(value));\r\n  };\r\n\r\n  GLSLX.Parser.checkStatementLocation = function(context, node) {\r\n    if (node.kind == GLSLX.NodeKind.VARIABLES || node.kind == GLSLX.NodeKind.STRUCT) {\r\n      return;\r\n    }\r\n\r\n    var isOutsideFunction = context.scope().kind == GLSLX.ScopeKind.GLOBAL || context.scope().kind == GLSLX.ScopeKind.STRUCT;\r\n    var shouldBeOutsideFunction = node.kind == GLSLX.NodeKind.EXTENSION || node.kind == GLSLX.NodeKind.FUNCTION || node.kind == GLSLX.NodeKind.PRECISION || node.kind == GLSLX.NodeKind.VERSION;\r\n\r\n    if (shouldBeOutsideFunction && !isOutsideFunction) {\r\n      context.log.syntaxErrorInsideFunction(node.range);\r\n    }\r\n\r\n    else if (!shouldBeOutsideFunction && isOutsideFunction) {\r\n      context.log.syntaxErrorOutsideFunction(node.range);\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.parseInclude = function(context, parent) {\r\n    // See if there is a string literal\r\n    var range = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.STRING_LITERAL)) {\r\n      return false;\r\n    }\r\n\r\n    // Decode the escapes\r\n    var path = null;\r\n\r\n    try {\r\n      path = JSON.parse(range.toString());\r\n    }\r\n\r\n    catch (e) {\r\n      context.log.syntaxErrorInvalidString(range);\r\n      return false;\r\n    }\r\n\r\n    // Must have access to the file system\r\n    var fileAccess = context.compilationData.fileAccess;\r\n\r\n    if (fileAccess == null) {\r\n      context.log.semanticErrorIncludeWithoutFileAccess(range);\r\n      return false;\r\n    }\r\n\r\n    // Must be able to read the file\r\n    var source = fileAccess(path, range.source.name);\r\n\r\n    if (source == null) {\r\n      context.log.semanticErrorIncludeBadPath(range, path);\r\n      return false;\r\n    }\r\n\r\n    // Parse the file and insert it into the parent\r\n    var tokens = GLSLX.Tokenizer.tokenize(context.log, source);\r\n    var nestedContext = new GLSLX.ParserContext(context.log, tokens, context.compilationData, context.resolver);\r\n    nestedContext.pushScope(context.scope());\r\n\r\n    if (!GLSLX.Parser.parseStatements(nestedContext, parent, GLSLX.VariableKind.GLOBAL) || !nestedContext.expect(GLSLX.TokenKind.END_OF_FILE)) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseBlock = function(context) {\r\n    var token = context.current();\r\n    var block = new GLSLX.Node(GLSLX.NodeKind.BLOCK);\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOCAL, context.scope()));\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE) || !GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.LOCAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return block.withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseFlags = function(context, mode) {\r\n    var flags = 0;\r\n\r\n    while (true) {\r\n      var kind = context.current().kind;\r\n\r\n      switch (kind) {\r\n        case GLSLX.TokenKind.ATTRIBUTE: {\r\n          flags |= GLSLX.SymbolFlags.ATTRIBUTE;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.CONST: {\r\n          flags |= GLSLX.SymbolFlags.CONST;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.HIGHP: {\r\n          flags |= GLSLX.SymbolFlags.HIGHP;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.IN: {\r\n          flags |= GLSLX.SymbolFlags.IN;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.INOUT: {\r\n          flags |= GLSLX.SymbolFlags.INOUT;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.LOWP: {\r\n          flags |= GLSLX.SymbolFlags.LOWP;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.MEDIUMP: {\r\n          flags |= GLSLX.SymbolFlags.MEDIUMP;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.OUT: {\r\n          flags |= GLSLX.SymbolFlags.OUT;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.UNIFORM: {\r\n          flags |= GLSLX.SymbolFlags.UNIFORM;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.VARYING: {\r\n          flags |= GLSLX.SymbolFlags.VARYING;\r\n          break;\r\n        }\r\n\r\n        default: {\r\n          return flags;\r\n        }\r\n      }\r\n\r\n      if (mode == GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.ATTRIBUTE || kind == GLSLX.TokenKind.UNIFORM || kind == GLSLX.TokenKind.VARYING) || mode == GLSLX.VariableKind.STRUCT && kind != GLSLX.TokenKind.LOWP && kind != GLSLX.TokenKind.MEDIUMP && kind != GLSLX.TokenKind.HIGHP || mode != GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.IN || kind == GLSLX.TokenKind.OUT || kind == GLSLX.TokenKind.INOUT)) {\r\n        context.log.syntaxErrorBadQualifier(context.current().range);\r\n      }\r\n\r\n      context.next();\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.parseType = function(context, mode) {\r\n    var token = context.current();\r\n    var type = null;\r\n\r\n    switch (token.kind) {\r\n      case GLSLX.TokenKind.BOOL: {\r\n        type = GLSLX.Type.BOOL;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.BVEC2: {\r\n        type = GLSLX.Type.BVEC2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.BVEC3: {\r\n        type = GLSLX.Type.BVEC3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.BVEC4: {\r\n        type = GLSLX.Type.BVEC4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.FLOAT: {\r\n        type = GLSLX.Type.FLOAT;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.INT: {\r\n        type = GLSLX.Type.INT;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IVEC2: {\r\n        type = GLSLX.Type.IVEC2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IVEC3: {\r\n        type = GLSLX.Type.IVEC3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IVEC4: {\r\n        type = GLSLX.Type.IVEC4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MAT2: {\r\n        type = GLSLX.Type.MAT2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MAT3: {\r\n        type = GLSLX.Type.MAT3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MAT4: {\r\n        type = GLSLX.Type.MAT4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.SAMPLER2D: {\r\n        type = GLSLX.Type.SAMPLER2D;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.SAMPLERCUBE: {\r\n        type = GLSLX.Type.SAMPLERCUBE;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VEC2: {\r\n        type = GLSLX.Type.VEC2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VEC3: {\r\n        type = GLSLX.Type.VEC3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VEC4: {\r\n        type = GLSLX.Type.VEC4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VOID: {\r\n        type = GLSLX.Type.VOID;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IDENTIFIER: {\r\n        var symbol = context.scope().find(token.range.toString());\r\n\r\n        if (symbol == null || !symbol.isStruct()) {\r\n          if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\r\n            context.unexpectedToken();\r\n          }\r\n\r\n          return null;\r\n        }\r\n\r\n        type = symbol.resolvedType();\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\r\n          context.unexpectedToken();\r\n        }\r\n\r\n        return null;\r\n      }\r\n    }\r\n\r\n    context.next();\r\n    return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseFunction = function(flags, type, name, context) {\r\n    var originalScope = context.scope();\r\n    var $function = new GLSLX.FunctionSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.FUNCTION, originalScope));\r\n    $function.flags |= context.flags | flags | ($function.name == 'main' ? GLSLX.SymbolFlags.EXPORTED : 0);\r\n    $function.returnType = type;\r\n    context.pushScope($function.scope);\r\n\r\n    // Takes no arguments\r\n    if (context.eat(GLSLX.TokenKind.VOID)) {\r\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Takes arguments\r\n    else if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      while (true) {\r\n        // Parse leading flags\r\n        var argumentFlags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.ARGUMENT);\r\n\r\n        // Parse the type\r\n        var argumentType = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n        if (argumentType == null) {\r\n          return null;\r\n        }\r\n\r\n        // Parse the identifier\r\n        var argumentName = context.current().range;\r\n\r\n        if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n          return null;\r\n        }\r\n\r\n        // Create the argument\r\n        var argument = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), argumentName, argumentName.toString(), context.scope(), GLSLX.VariableKind.ARGUMENT);\r\n        argument.flags |= argumentFlags;\r\n        argument.type = argumentType;\r\n        $function.$arguments.push(argument);\r\n        GLSLX.Parser.tryToDefineUniquelyInScope(context, argument);\r\n\r\n        // Array size\r\n        if (!GLSLX.Parser.parseArraySize(context, argument)) {\r\n          return null;\r\n        }\r\n\r\n        // Parse another argument?\r\n        if (!context.eat(GLSLX.TokenKind.COMMA)) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var previous = in_StringMap.get(originalScope.symbols, name.toString(), null);\r\n    var hasBlock = !context.eat(GLSLX.TokenKind.SEMICOLON);\r\n\r\n    // Merge adjacent function symbols to support overloading\r\n    if (previous == null) {\r\n      originalScope.define($function);\r\n    }\r\n\r\n    else if (previous.isFunction()) {\r\n      for (var link = previous.asFunction(); link != null; link = link.previousOverload) {\r\n        if (!link.hasSameArgumentTypesAs($function)) {\r\n          continue;\r\n        }\r\n\r\n        // Overloading by return type is not allowed\r\n        if (link.returnType.resolvedType != $function.returnType.resolvedType) {\r\n          context.log.syntaxErrorDifferentReturnType($function.returnType.range, $function.name, $function.returnType.resolvedType, link.returnType.resolvedType, link.returnType.range);\r\n        }\r\n\r\n        // Defining a function more than once is not allowed\r\n        else if (link.block != null || !hasBlock) {\r\n          context.log.syntaxErrorDuplicateSymbolDefinition($function.range, link.range);\r\n        }\r\n\r\n        // Merge the function with its forward declaration\r\n        else {\r\n          assert(link.sibling == null);\r\n          assert($function.sibling == null);\r\n          link.sibling = $function;\r\n          $function.sibling = link;\r\n          $function.flags |= link.flags;\r\n          link.flags = $function.flags;\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      // Use a singly-linked list to store the function overloads\r\n      $function.previousOverload = previous.asFunction();\r\n      originalScope.redefine($function);\r\n    }\r\n\r\n    else {\r\n      context.log.syntaxErrorDuplicateSymbolDefinition(name, previous.range);\r\n      return null;\r\n    }\r\n\r\n    if (hasBlock) {\r\n      var old = context.flags;\r\n      context.flags &= ~(GLSLX.SymbolFlags.EXPORTED | GLSLX.SymbolFlags.IMPORTED);\r\n      $function.block = GLSLX.Parser.parseBlock(context);\r\n      context.flags &= old;\r\n\r\n      if ($function.block == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    context.popScope();\r\n    return new GLSLX.Node(GLSLX.NodeKind.FUNCTION).withSymbol($function).withRange(context.spanSince(type.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseArraySize = function(context, variable) {\r\n    var token = context.current();\r\n\r\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACKET)) {\r\n      // The \"[]\" syntax isn't valid but skip over it and recover\r\n      if (context.eat(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        context.log.syntaxErrorMissingArraySize(context.spanSince(token.range));\r\n        return true;\r\n      }\r\n\r\n      variable.arrayCount = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (variable.arrayCount == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        return false;\r\n      }\r\n\r\n      // The array size must be resolved immediately\r\n      var count = 0;\r\n      context.resolver.resolveNode(variable.arrayCount);\r\n      context.resolver.checkConversion(variable.arrayCount, GLSLX.Type.INT);\r\n\r\n      if (variable.arrayCount.resolvedType != GLSLX.Type.ERROR) {\r\n        var folded = GLSLX.Folder.fold(variable.arrayCount);\r\n\r\n        if (folded == null) {\r\n          context.log.syntaxErrorConstantRequired(variable.arrayCount.range);\r\n        }\r\n\r\n        else if (folded.kind == GLSLX.NodeKind.INT) {\r\n          var value = folded.asInt();\r\n\r\n          if (value < 1) {\r\n            context.log.syntaxErrorInvalidArraySize(variable.arrayCount.range, value);\r\n          }\r\n\r\n          else {\r\n            count = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Multidimensional arrays are not supported\r\n      while (context.peek(GLSLX.TokenKind.LEFT_BRACKET)) {\r\n        token = context.next();\r\n\r\n        if (!context.peek(GLSLX.TokenKind.RIGHT_BRACKET) && GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST) == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n          return false;\r\n        }\r\n\r\n        context.log.syntaxErrorMultidimensionalArray(context.spanSince(token.range));\r\n      }\r\n\r\n      variable.type = new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(variable.type.resolvedType.arrayType(count)).withRange(variable.type.range);\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseVariables = function(flags, type, name, context) {\r\n    var variables = GLSLX.Node.createVariables(context.flags | flags, type);\r\n\r\n    while (true) {\r\n      var symbol = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), name, name.toString(), context.scope(), context.scope().kind == GLSLX.ScopeKind.GLOBAL ? GLSLX.VariableKind.GLOBAL : context.scope().kind == GLSLX.ScopeKind.STRUCT ? GLSLX.VariableKind.STRUCT : GLSLX.VariableKind.LOCAL);\r\n      symbol.flags |= context.flags | flags;\r\n      symbol.type = type;\r\n\r\n      // Array size\r\n      if (!GLSLX.Parser.parseArraySize(context, symbol)) {\r\n        return null;\r\n      }\r\n\r\n      // Initial value\r\n      var assign = context.current().range;\r\n\r\n      if (context.eat(GLSLX.TokenKind.ASSIGN)) {\r\n        symbol.value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n        if (symbol.value == null) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      else {\r\n        assign = null;\r\n      }\r\n\r\n      // Constants must be resolved immediately\r\n      var variable = new GLSLX.Node(GLSLX.NodeKind.VARIABLE).withSymbol(symbol).withRange(context.spanSince(symbol.range)).withInternalRange(assign);\r\n\r\n      if (symbol.isConst()) {\r\n        context.resolver.resolveNode(variable);\r\n      }\r\n\r\n      variables.appendChild(variable);\r\n      GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol);\r\n\r\n      // Are there more variables in this statement?\r\n      if (!context.eat(GLSLX.TokenKind.COMMA)) {\r\n        context.expect(GLSLX.TokenKind.SEMICOLON);\r\n        return variables;\r\n      }\r\n\r\n      name = context.current().range;\r\n\r\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.tryToDefineUniquelyInScope = function(context, symbol) {\r\n    var previous = in_StringMap.get(context.scope().symbols, symbol.name, null);\r\n\r\n    if (previous != null) {\r\n      context.log.syntaxErrorDuplicateSymbolDefinition(symbol.range, previous.range);\r\n      return false;\r\n    }\r\n\r\n    context.scope().define(symbol);\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseStatements = function(context, parent, mode) {\r\n    while (!context.peek(GLSLX.TokenKind.END_OF_FILE) && !context.peek(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n      if (context.eat(GLSLX.TokenKind.INCLUDE)) {\r\n        if (!GLSLX.Parser.parseInclude(context, parent)) {\r\n          return false;\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      var statement = GLSLX.Parser.parseStatement(context, mode);\r\n\r\n      if (statement == null) {\r\n        return false;\r\n      }\r\n\r\n      // Extension blocks are temporary and don't exist in the parsed result\r\n      if (statement.kind == GLSLX.NodeKind.MODIFIER_BLOCK) {\r\n        while (statement.hasChildren()) {\r\n          var child = statement.firstChild().remove();\r\n          GLSLX.Parser.checkStatementLocation(context, child);\r\n          parent.appendChild(child);\r\n        }\r\n      }\r\n\r\n      else {\r\n        GLSLX.Parser.checkStatementLocation(context, statement);\r\n        parent.appendChild(statement);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parse = function(log, tokens, global, data, scope, resolver) {\r\n    if (GLSLX.Parser.pratt == null) {\r\n      GLSLX.Parser.pratt = GLSLX.Parser.createExpressionParser();\r\n    }\r\n\r\n    var context = new GLSLX.ParserContext(log, tokens, data, resolver);\r\n    context.pushScope(scope);\r\n\r\n    if (GLSLX.Parser.parseStatements(context, global, GLSLX.VariableKind.GLOBAL)) {\r\n      context.expect(GLSLX.TokenKind.END_OF_FILE);\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.Allow = {\r\n    AVOID_FUNCTIONS: 0,\r\n    ALLOW_FUNCTIONS: 1\r\n  };\r\n\r\n  GLSLX.Parser.ParseTypeMode = {\r\n    IGNORE_ERRORS: 0,\r\n    REPORT_ERRORS: 1\r\n  };\r\n\r\n  // The same operator precedence as C for the most part\r\n  GLSLX.Precedence = {\r\n    LOWEST: 0,\r\n    COMMA: 1,\r\n    ASSIGN: 2,\r\n    LOGICAL_OR: 3,\r\n    LOGICAL_XOR: 4,\r\n    LOGICAL_AND: 5,\r\n    BITWISE_OR: 6,\r\n    BITWISE_XOR: 7,\r\n    BITWISE_AND: 8,\r\n    COMPARE: 10,\r\n    SHIFT: 11,\r\n    ADD: 12,\r\n    MULTIPLY: 13,\r\n    UNARY_PREFIX: 14,\r\n    UNARY_POSTFIX: 15,\r\n    MEMBER: 16\r\n  };\r\n\r\n  GLSLX.ParserContext = function(log, _tokens, compilationData, resolver) {\r\n    this.log = log;\r\n    this._tokens = _tokens;\r\n    this.compilationData = compilationData;\r\n    this.resolver = resolver;\r\n    this.flags = 0;\r\n    this._index = 0;\r\n    this._scope = null;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.current = function() {\r\n    return in_List.get(this._tokens, this._index);\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.next = function() {\r\n    var token = this.current();\r\n\r\n    if ((this._index + 1 | 0) < this._tokens.length) {\r\n      this._index = this._index + 1 | 0;\r\n    }\r\n\r\n    return token;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.spanSince = function(range) {\r\n    var previous = in_List.get(this._tokens, this._index > 0 ? this._index - 1 | 0 : 0);\r\n    return previous.range.end < range.start ? range : GLSLX.Range.span(range, previous.range);\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.peek = function(kind) {\r\n    return this.current().kind == kind;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.eat = function(kind) {\r\n    if (this.peek(kind)) {\r\n      this.next();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.expect = function(kind) {\r\n    if (this.eat(kind)) {\r\n      return true;\r\n    }\r\n\r\n    var token = this.current();\r\n    var range = token.range;\r\n    var previous = (this._index > 0 ? in_List.get(this._tokens, this._index - 1 | 0) : token).range;\r\n\r\n    // Put errors about missing semicolons and about tokens on the next line\r\n    // after the previous token instead of at the next token\r\n    if (kind == GLSLX.TokenKind.SEMICOLON || previous.lineColumn().line != range.lineColumn().line) {\r\n      this.log.syntaxErrorExpectedToken1(previous.rangeAtEnd(), kind);\r\n    }\r\n\r\n    else {\r\n      this.log.syntaxErrorExpectedToken2(range, token.kind, kind);\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.unexpectedToken = function() {\r\n    this.log.syntaxErrorUnexpectedToken(this.current());\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.scope = function() {\r\n    return this._scope;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.pushScope = function(newScope) {\r\n    assert(newScope.parent == this._scope);\r\n    this._scope = newScope;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.popScope = function() {\r\n    assert(this._scope != null);\r\n    this._scope = this._scope.parent;\r\n  };\r\n\r\n  GLSLX.Parselet = function(precedence) {\r\n    this.precedence = precedence;\r\n    this.prefix = null;\r\n    this.infix = null;\r\n  };\r\n\r\n  // A Pratt parser is a parser that associates up to two operations per token,\r\n  // each with its own precedence. Pratt parsers excel at parsing expression\r\n  // trees with deeply nested precedence levels. For an excellent writeup, see:\r\n  //\r\n  //   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\r\n  //\r\n  GLSLX.Pratt = function() {\r\n    this._table = {};\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.parselet = function(kind, precedence) {\r\n    var parselet = in_IntMap.get(this._table, kind, null);\r\n\r\n    if (parselet == null) {\r\n      var created = new GLSLX.Parselet(precedence);\r\n      parselet = created;\r\n      this._table[kind] = created;\r\n    }\r\n\r\n    else if (precedence > parselet.precedence) {\r\n      parselet.precedence = precedence;\r\n    }\r\n\r\n    return parselet;\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.parse = function(context, precedence) {\r\n    var token = context.current();\r\n    var parselet = in_IntMap.get(this._table, token.kind, null);\r\n\r\n    if (parselet == null || parselet.prefix == null) {\r\n      context.unexpectedToken();\r\n      return null;\r\n    }\r\n\r\n    var node = this.resume(context, precedence, parselet.prefix(context));\r\n\r\n    // Parselets must set the range of every node\r\n    assert(node == null || node.range != null);\r\n    return node;\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.resume = function(context, precedence, left) {\r\n    while (left != null) {\r\n      var kind = context.current().kind;\r\n      var parselet = in_IntMap.get(this._table, kind, null);\r\n\r\n      if (parselet == null || parselet.infix == null || parselet.precedence <= precedence) {\r\n        break;\r\n      }\r\n\r\n      left = parselet.infix(context, left);\r\n\r\n      // Parselets must set the range of every node\r\n      assert(left == null || left.range != null);\r\n    }\r\n\r\n    return left;\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.literal = function(kind, callback) {\r\n    this.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\r\n      return callback(context, context.next());\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.prefix = function(kind, precedence, callback) {\r\n    var self = this;\r\n    self.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\r\n      var token = context.next();\r\n      var value = self.parse(context, precedence);\r\n      return value != null ? callback(context, token, value) : null;\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.postfix = function(kind, precedence, callback) {\r\n    this.parselet(kind, precedence).infix = function(context, left) {\r\n      return callback(context, left, context.next());\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.infix = function(kind, precedence, callback) {\r\n    var self = this;\r\n    self.parselet(kind, precedence).infix = function(context, left) {\r\n      var token = context.next();\r\n      var right = self.parse(context, precedence);\r\n      return right != null ? callback(context, left, token, right) : null;\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.infixRight = function(kind, precedence, callback) {\r\n    var self = this;\r\n    self.parselet(kind, precedence).infix = function(context, left) {\r\n      var token = context.next();\r\n\r\n      // Subtract 1 for right-associativity\r\n      var right = self.parse(context, precedence - 1 | 0);\r\n      return right != null ? callback(context, left, token, right) : null;\r\n    };\r\n  };\r\n\r\n  GLSLX.Range = function(source, start, end) {\r\n    this.source = source;\r\n    this.start = start;\r\n    this.end = end;\r\n  };\r\n\r\n  GLSLX.Range.prototype.toString = function() {\r\n    return in_string.slice2(this.source.contents, this.start, this.end);\r\n  };\r\n\r\n  GLSLX.Range.prototype.slice = function(offsetStart, offsetEnd) {\r\n    assert(offsetStart >= 0 && offsetStart <= offsetEnd && offsetEnd <= (this.end - this.start | 0));\r\n    return new GLSLX.Range(this.source, this.start + offsetStart | 0, this.start + offsetEnd | 0);\r\n  };\r\n\r\n  GLSLX.Range.prototype.lineColumn = function() {\r\n    return this.source.indexToLineColumn(this.start);\r\n  };\r\n\r\n  GLSLX.Range.prototype.rangeAtEnd = function() {\r\n    return new GLSLX.Range(this.source, this.end, this.end);\r\n  };\r\n\r\n  GLSLX.Range.span = function(start, end) {\r\n    assert(start.source == end.source);\r\n    assert(start.start <= end.end);\r\n    return new GLSLX.Range(start.source, start.start, end.end);\r\n  };\r\n\r\n  GLSLX.Resolver = function(_log, _data) {\r\n    this._log = _log;\r\n    this._data = _data;\r\n    this._controlFlow = new GLSLX.ControlFlowAnalyzer();\r\n    this._versions = [];\r\n    this._generatedExtensions = Object.create(null);\r\n    this._returnType = null;\r\n  };\r\n\r\n  GLSLX.Resolver.prototype.resolveGlobal = function(global) {\r\n    this.resolveNode(global);\r\n\r\n    // Remove all version statements\r\n    for (var i = 0, list = this._versions, count = list.length; i < count; i = i + 1 | 0) {\r\n      var version = in_List.get(list, i);\r\n      version.remove();\r\n    }\r\n\r\n    // Re-insert the first version statement\r\n    var first = global.firstChild();\r\n\r\n    if (!(this._versions.length == 0)) {\r\n      global.insertChildBefore(first, in_List.first(this._versions));\r\n    }\r\n\r\n    // Insert all automatically generated extensions\r\n    for (var i1 = 0, list1 = in_StringMap.values(this._generatedExtensions), count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n      var extension = in_List.get(list1, i1);\r\n      global.insertChildBefore(first, extension);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype.resolveNode = function(node) {\r\n    if (node.resolvedType != null) {\r\n      return;\r\n    }\r\n\r\n    node.resolvedType = GLSLX.Type.ERROR;\r\n    var kind = node.kind;\r\n\r\n    switch (kind) {\r\n      case GLSLX.NodeKind.GLOBAL:\r\n      case GLSLX.NodeKind.STRUCT_BLOCK: {\r\n        this._resolveChildren(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.VARIABLE: {\r\n        var symbol = node.symbol.asVariable();\r\n        this.resolveNode(symbol.type);\r\n\r\n        // Variables must have a type\r\n        var type = symbol.type.resolvedType;\r\n\r\n        if (type == GLSLX.Type.VOID) {\r\n          this._log.semanticErrorBadVariableType(symbol.type.range, type);\r\n          type = GLSLX.Type.ERROR;\r\n        }\r\n\r\n        // Array size\r\n        if (symbol.arrayCount != null) {\r\n          this._resolveAsExpression(symbol.arrayCount);\r\n          this.checkConversion(symbol.arrayCount, GLSLX.Type.INT);\r\n        }\r\n\r\n        // Initial value\r\n        if (symbol.value != null) {\r\n          this._resolveAsExpression(symbol.value);\r\n          this.checkConversion(symbol.value, type);\r\n\r\n          if (type.containsArray) {\r\n            this._log.semanticErrorArrayAssignment(node.internalRange, type);\r\n          }\r\n        }\r\n\r\n        // Constants must be initialized\r\n        if (symbol.isConst()) {\r\n          if (symbol.value != null) {\r\n            if (symbol.value.resolvedType != GLSLX.Type.ERROR) {\r\n              var folded = GLSLX.Folder.fold(symbol.value);\r\n\r\n              if (folded == null) {\r\n                this._log.syntaxErrorConstantRequired(symbol.value.range);\r\n              }\r\n\r\n              else {\r\n                assert(folded.parent() == null);\r\n                assert(folded.resolvedType != null);\r\n                symbol.constantValue = folded;\r\n              }\r\n            }\r\n          }\r\n\r\n          else if (symbol.kind == GLSLX.VariableKind.LOCAL) {\r\n            this._log.semanticErrorUninitializedConstant(symbol.range);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.BLOCK: {\r\n        this._resolveBlockOrStatement(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.BREAK:\r\n      case GLSLX.NodeKind.CONTINUE:\r\n      case GLSLX.NodeKind.DISCARD: {\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.DO_WHILE: {\r\n        this._resolveBlockOrStatement(node.doWhileBody());\r\n        this.resolveNode(node.doWhileTest());\r\n        this.checkConversion(node.doWhileTest(), GLSLX.Type.BOOL);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.EXPRESSION: {\r\n        this.resolveNode(node.expressionValue());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.EXTENSION: {\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FOR: {\r\n        if (node.forSetup() != null) {\r\n          this._resolveAsExpression(node.forSetup());\r\n        }\r\n\r\n        if (node.forTest() != null) {\r\n          this._resolveAsExpression(node.forTest());\r\n          this.checkConversion(node.forTest(), GLSLX.Type.BOOL);\r\n        }\r\n\r\n        if (node.forUpdate() != null) {\r\n          this._resolveAsExpression(node.forUpdate());\r\n        }\r\n\r\n        this._resolveBlockOrStatement(node.forBody());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FUNCTION: {\r\n        var symbol1 = node.symbol.asFunction();\r\n\r\n        for (var i = 0, list = symbol1.$arguments, count = list.length; i < count; i = i + 1 | 0) {\r\n          var argument = in_List.get(list, i);\r\n          this.resolveNode(argument.type);\r\n        }\r\n\r\n        this.resolveNode(symbol1.returnType);\r\n\r\n        if (symbol1.block != null) {\r\n          this._returnType = symbol1.returnType.resolvedType;\r\n          this._resolveBlockOrStatement(symbol1.block);\r\n\r\n          // Missing a return statement is an error\r\n          if (this._returnType != GLSLX.Type.VOID && symbol1.block.hasControlFlowAtEnd) {\r\n            this._log.semanticErrorMissingReturn(symbol1.range, symbol1.name, this._returnType);\r\n          }\r\n\r\n          this._returnType = null;\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.IF: {\r\n        this.resolveNode(node.ifTest());\r\n        this.checkConversion(node.ifTest(), GLSLX.Type.BOOL);\r\n        this._resolveBlockOrStatement(node.ifTrue());\r\n\r\n        if (node.ifFalse() != null) {\r\n          this._resolveBlockOrStatement(node.ifFalse());\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.PRECISION: {\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.RETURN: {\r\n        if (node.returnValue() != null) {\r\n          this.resolveNode(node.returnValue());\r\n          this.checkConversion(node.returnValue(), this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\r\n        }\r\n\r\n        else {\r\n          node.resolvedType = GLSLX.Type.VOID;\r\n          this.checkConversion(node, this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.STRUCT: {\r\n        this._resolveChildren(node);\r\n\r\n        // A struct loses operator \"==\" and \"!=\" when it contains a type without those operators\r\n        var resolvedType = node.symbol.resolvedType();\r\n\r\n        for (var i1 = 0, list1 = node.symbol.asStruct().variables, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n          var variable = in_List.get(list1, i1);\r\n          var type1 = variable.type.resolvedType;\r\n\r\n          if (type1.containsArray) {\r\n            resolvedType.containsArray = true;\r\n          }\r\n\r\n          if (type1.containsSampler) {\r\n            resolvedType.containsSampler = true;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.VARIABLES: {\r\n        this._resolveChildren(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.VERSION: {\r\n        this._versions.push(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.WHILE: {\r\n        this.resolveNode(node.whileTest());\r\n        this.checkConversion(node.whileTest(), GLSLX.Type.BOOL);\r\n        this._resolveBlockOrStatement(node.whileBody());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.CALL: {\r\n        this._resolveCall(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.DOT: {\r\n        this._resolveDot(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.HOOK: {\r\n        var test = node.hookTest();\r\n        var no = node.hookFalse();\r\n        var yes = node.hookTrue();\r\n        this._resolveAsExpression(test);\r\n        this.checkConversion(test, GLSLX.Type.BOOL);\r\n        this._resolveAsExpression(yes);\r\n        this._resolveAsExpression(no);\r\n\r\n        if (yes.resolvedType != no.resolvedType) {\r\n          this._log.semanticErrorBadHookTypes(GLSLX.Range.span(yes.range, no.range), yes.resolvedType, no.resolvedType);\r\n        }\r\n\r\n        else if (yes.resolvedType.containsArray) {\r\n          this._log.semanticErrorArrayHook(GLSLX.Range.span(yes.range, no.range), yes.resolvedType);\r\n        }\r\n\r\n        else {\r\n          node.resolvedType = yes.resolvedType;\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.NAME: {\r\n        var symbol2 = node.symbol;\r\n\r\n        if (symbol2.isVariable()) {\r\n          this.resolveNode(symbol2.asVariable().type);\r\n          node.resolvedType = symbol2.asVariable().type.resolvedType;\r\n        }\r\n\r\n        else if (symbol2.isFunction() && !node.isCallTarget()) {\r\n          this._log.semanticErrorMustCallFunction(node.range, symbol2.name);\r\n        }\r\n\r\n        else {\r\n          node.resolvedType = symbol2.resolvedType();\r\n        }\r\n\r\n        // Make sure the extension is enabled if it hasn't been specified\r\n        var name = symbol2.requiredExtension;\r\n\r\n        if (name != null && !(name in this._generatedExtensions) && this._data.extensionBehavior(name) == GLSLX.ExtensionBehavior.DEFAULT) {\r\n          this._generatedExtensions[name] = new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(GLSLX.ExtensionBehavior.ENABLE);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.SEQUENCE: {\r\n        for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n          this._resolveAsExpression(child);\r\n        }\r\n\r\n        node.resolvedType = node.lastChild().resolvedType;\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        if (GLSLX.in_NodeKind.isUnary(kind)) {\r\n          this._resolveUnary(node);\r\n        }\r\n\r\n        else if (GLSLX.in_NodeKind.isBinary(kind)) {\r\n          this._resolveBinary(node);\r\n        }\r\n\r\n        else {\r\n          assert(false);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    assert(node.resolvedType != null);\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveBlockOrStatement = function(node) {\r\n    assert(GLSLX.in_NodeKind.isStatement(node.kind));\r\n    this._controlFlow.pushBlock(node);\r\n\r\n    if (node.kind == GLSLX.NodeKind.BLOCK) {\r\n      for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n        this.resolveNode(child);\r\n        this._controlFlow.visitStatement(child);\r\n      }\r\n    }\r\n\r\n    else {\r\n      this.resolveNode(node);\r\n      this._controlFlow.visitStatement(node);\r\n    }\r\n\r\n    this._controlFlow.popBlock(node);\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveUnary = function(node) {\r\n    var value = node.unaryValue();\r\n    this._resolveAsExpression(value);\r\n\r\n    if (GLSLX.in_NodeKind.isUnaryAssign(node.kind)) {\r\n      this._checkStorage(value);\r\n    }\r\n\r\n    var valueType = value.resolvedType;\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.NEGATIVE:\r\n      case GLSLX.NodeKind.POSITIVE:\r\n      case GLSLX.NodeKind.PREFIX_DECREMENT:\r\n      case GLSLX.NodeKind.PREFIX_INCREMENT:\r\n      case GLSLX.NodeKind.POSTFIX_DECREMENT:\r\n      case GLSLX.NodeKind.POSTFIX_INCREMENT: {\r\n        node.resolvedType = valueType.isIntOrFloat() ? valueType : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.NOT: {\r\n        node.resolvedType = valueType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (node.resolvedType == GLSLX.Type.ERROR && valueType != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorBadUnaryOperator(node.internalRange, node.internalRange.toString(), valueType);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveBinary = function(node) {\r\n    var left = node.binaryLeft();\r\n    var right = node.binaryRight();\r\n    this._resolveAsExpression(left);\r\n    this._resolveAsExpression(right);\r\n\r\n    if (GLSLX.in_NodeKind.isBinaryAssign(node.kind)) {\r\n      this._checkStorage(left);\r\n    }\r\n\r\n    var leftType = left.resolvedType;\r\n    var rightType = right.resolvedType;\r\n    var isSame = leftType == rightType;\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.ADD:\r\n      case GLSLX.NodeKind.SUBTRACT:\r\n      case GLSLX.NodeKind.MULTIPLY:\r\n      case GLSLX.NodeKind.DIVIDE: {\r\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : leftType == GLSLX.Type.FLOAT && rightType.hasFloatComponents() ? rightType : leftType == GLSLX.Type.INT && rightType.hasIntComponents() ? rightType : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2) ? GLSLX.Type.VEC2 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3) ? GLSLX.Type.VEC3 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) ? GLSLX.Type.VEC4 : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.EQUAL:\r\n      case GLSLX.NodeKind.NOT_EQUAL: {\r\n        node.resolvedType = isSame && leftType.canUseEqualityOperators() ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_AND:\r\n      case GLSLX.NodeKind.LOGICAL_OR:\r\n      case GLSLX.NodeKind.LOGICAL_XOR: {\r\n        node.resolvedType = isSame && leftType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.LESS_THAN:\r\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL:\r\n      case GLSLX.NodeKind.GREATER_THAN:\r\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\r\n        node.resolvedType = isSame && (leftType == GLSLX.Type.FLOAT || leftType == GLSLX.Type.INT) ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.ASSIGN: {\r\n        node.resolvedType = leftType;\r\n\r\n        if (leftType.containsArray) {\r\n          this._log.semanticErrorArrayAssignment(node.internalRange, leftType);\r\n        }\r\n\r\n        this.checkConversion(right, leftType);\r\n        return;\r\n      }\r\n\r\n      case GLSLX.NodeKind.ASSIGN_ADD:\r\n      case GLSLX.NodeKind.ASSIGN_SUBTRACT:\r\n      case GLSLX.NodeKind.ASSIGN_MULTIPLY:\r\n      case GLSLX.NodeKind.ASSIGN_DIVIDE: {\r\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : node.kind == GLSLX.NodeKind.ASSIGN_MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) ? leftType : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.INDEX: {\r\n        if (rightType == GLSLX.Type.INT) {\r\n          var indexType = leftType.indexType();\r\n\r\n          if (indexType != null) {\r\n            node.resolvedType = indexType;\r\n          }\r\n\r\n          // Run bounds checking on the constant-folded value\r\n          var folded = GLSLX.Folder.fold(right);\r\n\r\n          if (folded != null && folded.kind == GLSLX.NodeKind.INT) {\r\n            var value = folded.asInt();\r\n            var count = leftType.indexCount();\r\n\r\n            // Negative indices are always invalid even if the array size is unknown\r\n            if (value < 0 || count != 0 && value >= count) {\r\n              this._log.semanticErrorOutOfBoundsIndex(right.range, value, leftType);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If we get here, show an error about an invalid operator\r\n    if (node.resolvedType == GLSLX.Type.ERROR && leftType != GLSLX.Type.ERROR && rightType != GLSLX.Type.ERROR) {\r\n      if (node.kind == GLSLX.NodeKind.INDEX) {\r\n        this._log.semanticErrorBadIndex(node.internalRange, leftType, rightType);\r\n      }\r\n\r\n      else {\r\n        this._log.semanticErrorBadBinaryOperator(node.internalRange, node.internalRange.toString(), leftType, rightType);\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveCall = function(node) {\r\n    var callTarget = node.callTarget();\r\n    this.resolveNode(callTarget);\r\n    var type = callTarget.resolvedType;\r\n    var symbol = type.symbol;\r\n    var $arguments = [];\r\n    var hasError = false;\r\n\r\n    for (var child = callTarget.nextSibling(); child != null; child = child.nextSibling()) {\r\n      this._resolveAsExpression(child);\r\n      $arguments.push(child);\r\n\r\n      if (child.resolvedType == GLSLX.Type.ERROR) {\r\n        hasError = true;\r\n      }\r\n    }\r\n\r\n    if (hasError) {\r\n      return;\r\n    }\r\n\r\n    if (symbol != null) {\r\n      if (symbol.isFunction()) {\r\n        this._resolveFunctionOverloads(symbol.asFunction(), node, $arguments);\r\n        return;\r\n      }\r\n\r\n      if (symbol.isStruct()) {\r\n        this._resolveConstructor(type, node, $arguments);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (type != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorBadCall(callTarget.range, type);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveDot = function(node) {\r\n    var dotTarget = node.dotTarget();\r\n    var name = node.asString();\r\n    var range = node.internalRange;\r\n    this._resolveAsExpression(dotTarget);\r\n    var type = dotTarget.resolvedType;\r\n    var isAssignTarget = node.isAssignTarget();\r\n\r\n    switch (type) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.VEC4: {\r\n        node.resolvedType = this._validateSwizzle(range, type, name, isAssignTarget);\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        if (type.symbol != null && type.symbol.isStruct()) {\r\n          for (var i = 0, list = type.symbol.asStruct().variables, count = list.length; i < count; i = i + 1 | 0) {\r\n            var variable = in_List.get(list, i);\r\n\r\n            if (variable.name == name) {\r\n              node.symbol = variable;\r\n              this.resolveNode(variable.type);\r\n              node.resolvedType = variable.type.resolvedType;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (node.symbol == null) {\r\n          this._log.semanticErrorBadMember(range, type, name);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveFunctionOverloads = function(overloaded, node, $arguments) {\r\n    var overloads = [];\r\n\r\n    // Collect all relevant overloads but ignore forward-declared functions that also have an implementation\r\n    for (var overload = overloaded; overload != null; overload = overload.previousOverload) {\r\n      if (!(overloads.indexOf(overload.sibling) != -1)) {\r\n        overloads.push(overload);\r\n      }\r\n    }\r\n\r\n    // Narrow down by argument count\r\n    if (overloads.length != 1) {\r\n      overloads = overloads.slice();\r\n      in_List.removeIf(overloads, function(overload) {\r\n        return overload.$arguments.length != $arguments.length;\r\n      });\r\n\r\n      // Narrow down by argument types\r\n      if (overloads.length != 1) {\r\n        var overloadsBeforeTypeFilter = overloads.slice();\r\n        in_List.removeIf(overloads, function(overload) {\r\n          for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n            if (in_List.get(overload.$arguments, i).type.resolvedType != in_List.get($arguments, i).resolvedType) {\r\n              return true;\r\n            }\r\n          }\r\n\r\n          return false;\r\n        });\r\n\r\n        // Narrow down by argument types with \"conversions\" to get better error messages\r\n        if (overloads.length != 1) {\r\n          overloads = overloadsBeforeTypeFilter;\r\n          in_List.removeIf(overloads, function(overload) {\r\n            for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n              var from = in_List.get(overload.$arguments, i).type.resolvedType;\r\n              var to = in_List.get($arguments, i).resolvedType;\r\n              var fromSize = from.componentCount();\r\n              var toSize = to.componentCount();\r\n\r\n              if (from != to && (fromSize == 0 || toSize == 0 || fromSize != toSize)) {\r\n                return true;\r\n              }\r\n            }\r\n\r\n            return false;\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Match failure\r\n    if (overloads.length != 1) {\r\n      this._log.semanticErrorBadOverloadMatch(node.callTarget().range, overloaded.name);\r\n      return;\r\n    }\r\n\r\n    // Match success\r\n    var overload1 = in_List.first(overloads);\r\n\r\n    if (overload1.$arguments.length != $arguments.length) {\r\n      this._log.semanticErrorArgumentCountFunction(node.internalRange, overload1.$arguments.length, $arguments.length, overload1.name, overload1.range);\r\n    }\r\n\r\n    else {\r\n      for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n        this.checkConversion(in_List.get($arguments, i), in_List.get(overload1.$arguments, i).type.resolvedType);\r\n      }\r\n    }\r\n\r\n    node.callTarget().symbol = overload1;\r\n    node.resolvedType = overload1.returnType.resolvedType;\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveConstructor = function(type, node, $arguments) {\r\n    node.resolvedType = type;\r\n\r\n    if (type == GLSLX.Type.ERROR) {\r\n      return;\r\n    }\r\n\r\n    if (type.componentType() != null) {\r\n      var count = type.componentCount();\r\n      var hasMatrixArgument = false;\r\n\r\n      // Visit each argument and make sure it's useful toward construction\r\n      var providedCount = 0;\r\n\r\n      for (var i1 = 0, list = $arguments, count1 = list.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n        var argument = in_List.get(list, i1);\r\n        var argumentType = argument.resolvedType;\r\n        var deltaCount = argumentType.componentCount();\r\n\r\n        // Each type in a component-based types must be able to itself be unpacked into components\r\n        if (argumentType.componentType() == null) {\r\n          if (argumentType != GLSLX.Type.ERROR) {\r\n            this._log.semanticErrorBadConstructorValue(argument.range, argumentType, type);\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // Passing extra values to a constructor is allowed sometimes\r\n        //\r\n        // Allowed:\r\n        //\r\n        //   vec3(vec4(1.0));\r\n        //   vec3(1.0, vec4(1.0));\r\n        //\r\n        // Not allowed:\r\n        //\r\n        //   vec3(vec4(1.0), 1.0);\r\n        //   vec3(vec3(1.0), vec3(1.0));\r\n        //\r\n        if (providedCount >= count) {\r\n          this._log.semanticErrorExtraConstructorValue(argument.range, type, count, providedCount + deltaCount | 0);\r\n        }\r\n\r\n        if (argumentType.isMatrix()) {\r\n          hasMatrixArgument = true;\r\n        }\r\n\r\n        providedCount = providedCount + deltaCount | 0;\r\n      }\r\n\r\n      // If a matrix argument is given to a matrix constructor, it is an error\r\n      // to have any other arguments\r\n      var isMatrixMatrixConstructor = type.isMatrix() && hasMatrixArgument;\r\n\r\n      if (isMatrixMatrixConstructor && $arguments.length != 1) {\r\n        this._log.semanticErrorBadMatrixConstructor(node.internalRange);\r\n      }\r\n\r\n      // Validate the count (constructing a matrix using a matrix should always work)\r\n      else if (providedCount < count && providedCount != 1 && !isMatrixMatrixConstructor) {\r\n        this._log.semanticErrorBadConstructorCount(node.internalRange, type, providedCount);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    var symbol = type.symbol.asStruct();\r\n    var variables = symbol.variables;\r\n    var variableCount = variables.length;\r\n    var argumentCount = $arguments.length;\r\n\r\n    // Validate argument count\r\n    if (variableCount != argumentCount) {\r\n      this._log.semanticErrorArgumentCountConstructor(node.internalRange, variableCount, argumentCount, symbol.name, symbol.range);\r\n      return;\r\n    }\r\n\r\n    // Validate argument types\r\n    for (var i = 0, count2 = variableCount; i < count2; i = i + 1 | 0) {\r\n      this.checkConversion(in_List.get($arguments, i), in_List.get(variables, i).type.resolvedType);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._validateSwizzle = function(range, type, name, isAssignTarget) {\r\n    var count = name.length;\r\n\r\n    if (count > 4) {\r\n      this._log.semanticErrorBadSwizzle(range, type, name);\r\n      return GLSLX.Type.ERROR;\r\n    }\r\n\r\n    var componentCount = type.componentCount();\r\n\r\n    for (var i1 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i1 < count2; i1 = i1 + 1 | 0) {\r\n      var set = in_List.get(list, i1);\r\n\r\n      if (set.indexOf(in_string.get(name, 0)) != -1) {\r\n        for (var i = 1, count1 = count; i < count1; i = i + 1 | 0) {\r\n          if (!(set.indexOf(in_string.get(name, i)) != -1)) {\r\n            this._log.semanticErrorBadSwizzle(range, type, name);\r\n            return GLSLX.Type.ERROR;\r\n          }\r\n\r\n          if (isAssignTarget && in_string.slice2(name, 0, i).indexOf(in_string.get(name, i)) != -1) {\r\n            this._log.semanticErrorBadSwizzleAssignment(range.slice(i, i + 1 | 0), in_string.get(name, i));\r\n            return GLSLX.Type.ERROR;\r\n          }\r\n        }\r\n\r\n        return GLSLX.Swizzle.type(type.componentType(), count);\r\n      }\r\n    }\r\n\r\n    this._log.semanticErrorBadSwizzle(range, type, name);\r\n    return GLSLX.Type.ERROR;\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveAsExpression = function(node) {\r\n    this.resolveNode(node);\r\n\r\n    if (node.kind == GLSLX.NodeKind.TYPE && node.resolvedType != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorUnexpectedType(node.range, node.resolvedType);\r\n      node.resolvedType = GLSLX.Type.ERROR;\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveChildren = function(node) {\r\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n      this.resolveNode(child);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._checkStorage = function(node) {\r\n    var n = node;\r\n    assert(GLSLX.in_NodeKind.isExpression(node.kind));\r\n\r\n    label: while (true) {\r\n      if (n.resolvedType == GLSLX.Type.ERROR) {\r\n        break;\r\n      }\r\n\r\n      switch (n.kind) {\r\n        case GLSLX.NodeKind.NAME: {\r\n          if (n.symbol.isConst()) {\r\n            this._log.semanticErrorBadStorage(node.range);\r\n          }\r\n\r\n          break label;\r\n        }\r\n\r\n        case GLSLX.NodeKind.DOT: {\r\n          n = n.dotTarget();\r\n          break;\r\n        }\r\n\r\n        case GLSLX.NodeKind.INDEX: {\r\n          n = n.binaryLeft();\r\n          break;\r\n        }\r\n\r\n        default: {\r\n          this._log.semanticErrorBadStorage(node.range);\r\n          break label;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype.checkConversion = function(node, type) {\r\n    if (node.resolvedType != type && node.resolvedType != GLSLX.Type.ERROR && type != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorBadConversion(node.range, node.resolvedType, type);\r\n      node.resolvedType = GLSLX.Type.ERROR;\r\n    }\r\n  };\r\n\r\n  GLSLX.ScopeKind = {\r\n    FUNCTION: 0,\r\n    GLOBAL: 1,\r\n    LOCAL: 2,\r\n    LOOP: 3,\r\n    STRUCT: 4\r\n  };\r\n\r\n  GLSLX.Scope = function(kind, parent) {\r\n    this.kind = kind;\r\n    this.parent = parent;\r\n    this.symbols = Object.create(null);\r\n  };\r\n\r\n  GLSLX.Scope.prototype.define = function(symbol) {\r\n    assert(!(symbol.name in this.symbols));\r\n    this.symbols[symbol.name] = symbol;\r\n  };\r\n\r\n  GLSLX.Scope.prototype.redefine = function(symbol) {\r\n    assert(symbol.name in this.symbols);\r\n    assert(in_StringMap.get1(this.symbols, symbol.name) != symbol);\r\n    this.symbols[symbol.name] = symbol;\r\n  };\r\n\r\n  GLSLX.Scope.prototype.find = function(name) {\r\n    var symbol = in_StringMap.get(this.symbols, name, null);\r\n\r\n    if (symbol != null) {\r\n      return symbol;\r\n    }\r\n\r\n    if (this.parent != null) {\r\n      return this.parent.find(name);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.LineColumn = function(line, column) {\r\n    this.line = line;\r\n    this.column = column;\r\n  };\r\n\r\n  GLSLX.Source = function(name, contents) {\r\n    this.name = name;\r\n    this.contents = contents;\r\n    this.tokens = null;\r\n    this._lineOffsets = null;\r\n  };\r\n\r\n  GLSLX.Source.prototype.indexToLineColumn = function(index) {\r\n    this._computeLineOffsets();\r\n\r\n    // Binary search to find the line\r\n    var count = this._lineOffsets.length;\r\n    var line = 0;\r\n\r\n    while (count > 0) {\r\n      var step = count / 2 | 0;\r\n      var i = line + step | 0;\r\n\r\n      if (in_List.get(this._lineOffsets, i) <= index) {\r\n        line = i + 1 | 0;\r\n        count = (count - step | 0) - 1 | 0;\r\n      }\r\n\r\n      else {\r\n        count = step;\r\n      }\r\n    }\r\n\r\n    // Use the line to compute the column\r\n    var column = line > 0 ? index - in_List.get(this._lineOffsets, line - 1 | 0) | 0 : index;\r\n    return new GLSLX.LineColumn(line - 1 | 0, column);\r\n  };\r\n\r\n  GLSLX.Source.prototype._computeLineOffsets = function() {\r\n    if (this._lineOffsets == null) {\r\n      this._lineOffsets = [0];\r\n\r\n      for (var i = 0, count = this.contents.length; i < count; i = i + 1 | 0) {\r\n        if (in_string.get1(this.contents, i) == 10) {\r\n          this._lineOffsets.push(i + 1 | 0);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Swizzle = {};\r\n\r\n  GLSLX.Swizzle.strings = function(componentCount) {\r\n    switch (componentCount) {\r\n      case 2: {\r\n        return GLSLX.Swizzle._STRINGS_2;\r\n      }\r\n\r\n      case 3: {\r\n        return GLSLX.Swizzle._STRINGS_3;\r\n      }\r\n\r\n      case 4: {\r\n        return GLSLX.Swizzle._STRINGS_4;\r\n      }\r\n    }\r\n\r\n    assert(false);\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Swizzle.type = function(comonentType, componentCount) {\r\n    switch (comonentType) {\r\n      case GLSLX.Type.BOOL: {\r\n        switch (componentCount) {\r\n          case 1: {\r\n            return GLSLX.Type.BOOL;\r\n          }\r\n\r\n          case 2: {\r\n            return GLSLX.Type.BVEC2;\r\n          }\r\n\r\n          case 3: {\r\n            return GLSLX.Type.BVEC3;\r\n          }\r\n\r\n          case 4: {\r\n            return GLSLX.Type.BVEC4;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.Type.FLOAT: {\r\n        switch (componentCount) {\r\n          case 1: {\r\n            return GLSLX.Type.FLOAT;\r\n          }\r\n\r\n          case 2: {\r\n            return GLSLX.Type.VEC2;\r\n          }\r\n\r\n          case 3: {\r\n            return GLSLX.Type.VEC3;\r\n          }\r\n\r\n          case 4: {\r\n            return GLSLX.Type.VEC4;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.Type.INT: {\r\n        switch (componentCount) {\r\n          case 1: {\r\n            return GLSLX.Type.INT;\r\n          }\r\n\r\n          case 2: {\r\n            return GLSLX.Type.IVEC2;\r\n          }\r\n\r\n          case 3: {\r\n            return GLSLX.Type.IVEC3;\r\n          }\r\n\r\n          case 4: {\r\n            return GLSLX.Type.IVEC4;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    assert(false);\r\n    return null;\r\n  };\r\n\r\n  GLSLX.SymbolFlags = {\r\n    // Keyword modifiers\r\n    ATTRIBUTE: 1,\r\n    CONST: 2,\r\n    HIGHP: 4,\r\n    IN: 8,\r\n    INOUT: 16,\r\n    LOWP: 32,\r\n    MEDIUMP: 64,\r\n    OUT: 128,\r\n    UNIFORM: 256,\r\n    VARYING: 512,\r\n\r\n    // Internal compiler flags\r\n    EXPORTED: 1024,\r\n    IMPORTED: 2048\r\n  };\r\n\r\n  GLSLX.Symbol = function(id, range, name, scope) {\r\n    this.id = id;\r\n    this.range = range;\r\n    this.name = name;\r\n    this.scope = scope;\r\n    this.flags = 0;\r\n    this.constantValue = null;\r\n    this.requiredExtension = null;\r\n    this._resolvedType = null;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isConst = function() {\r\n    return (GLSLX.SymbolFlags.CONST & this.flags) != 0;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isStruct = function() {\r\n    return this instanceof GLSLX.StructSymbol;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isFunction = function() {\r\n    return this instanceof GLSLX.FunctionSymbol;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isVariable = function() {\r\n    return this instanceof GLSLX.VariableSymbol;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.asStruct = function() {\r\n    assert(this.isStruct());\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.asFunction = function() {\r\n    assert(this.isFunction());\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.asVariable = function() {\r\n    assert(this.isVariable());\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.resolvedType = function() {\r\n    if (this._resolvedType == null) {\r\n      this._resolvedType = new GLSLX.Type(this, null, 0);\r\n    }\r\n\r\n    return this._resolvedType;\r\n  };\r\n\r\n  GLSLX.StructSymbol = function(id, range, name, scope) {\r\n    GLSLX.Symbol.call(this, id, range, name, scope);\r\n    this.variables = [];\r\n  };\r\n\r\n  __extends(GLSLX.StructSymbol, GLSLX.Symbol);\r\n\r\n  GLSLX.FunctionSymbol = function(id, range, name, scope) {\r\n    GLSLX.Symbol.call(this, id, range, name, scope);\r\n    this.$arguments = [];\r\n    this.returnType = null;\r\n    this.block = null;\r\n    this.previousOverload = null;\r\n    this.sibling = null;\r\n  };\r\n\r\n  __extends(GLSLX.FunctionSymbol, GLSLX.Symbol);\r\n\r\n  GLSLX.FunctionSymbol.prototype.hasSameArgumentTypesAs = function($function) {\r\n    if (this.$arguments.length != $function.$arguments.length) {\r\n      return false;\r\n    }\r\n\r\n    for (var i = 0, count = this.$arguments.length; i < count; i = i + 1 | 0) {\r\n      if (in_List.get(this.$arguments, i).type.resolvedType != in_List.get($function.$arguments, i).type.resolvedType) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.VariableKind = {\r\n    ARGUMENT: 0,\r\n    GLOBAL: 1,\r\n    LOCAL: 2,\r\n    STRUCT: 3\r\n  };\r\n\r\n  GLSLX.VariableSymbol = function(id, range, name, scope, kind) {\r\n    GLSLX.Symbol.call(this, id, range, name, scope);\r\n    this.kind = kind;\r\n    this.type = null;\r\n    this.value = null;\r\n    this.arrayCount = null;\r\n  };\r\n\r\n  __extends(GLSLX.VariableSymbol, GLSLX.Symbol);\r\n\r\n  GLSLX.TokenKind = {\r\n    // Standard keywords\r\n    ATTRIBUTE: 0,\r\n    BOOL: 1,\r\n    BREAK: 2,\r\n    BVEC2: 3,\r\n    BVEC3: 4,\r\n    BVEC4: 5,\r\n    CONST: 6,\r\n    CONTINUE: 7,\r\n    DISCARD: 8,\r\n    DO: 9,\r\n    ELSE: 10,\r\n    FALSE: 11,\r\n    FLOAT: 12,\r\n    FOR: 13,\r\n    HIGHP: 14,\r\n    IF: 15,\r\n    IN: 16,\r\n    INOUT: 17,\r\n    INT: 18,\r\n    INVARIANT: 19,\r\n    IVEC2: 20,\r\n    IVEC3: 21,\r\n    IVEC4: 22,\r\n    LOWP: 23,\r\n    MAT2: 24,\r\n    MAT3: 25,\r\n    MAT4: 26,\r\n    MEDIUMP: 27,\r\n    OUT: 28,\r\n    PRECISION: 29,\r\n    RETURN: 30,\r\n    SAMPLER2D: 31,\r\n    SAMPLERCUBE: 32,\r\n    STRUCT: 33,\r\n    TRUE: 34,\r\n    UNIFORM: 35,\r\n    VARYING: 36,\r\n    VEC2: 37,\r\n    VEC3: 38,\r\n    VEC4: 39,\r\n    VOID: 40,\r\n    WHILE: 41,\r\n\r\n    // Non-standard keywords\r\n    EXPORT: 42,\r\n    IMPORT: 43,\r\n\r\n    // Unary\r\n    COMPLEMENT: 44,\r\n    DECREMENT: 45,\r\n    INCREMENT: 46,\r\n    NOT: 47,\r\n\r\n    // Binary\r\n    BITWISE_AND: 48,\r\n    BITWISE_OR: 49,\r\n    BITWISE_XOR: 50,\r\n    DIVIDE: 51,\r\n    EQUAL: 52,\r\n    GREATER_THAN: 53,\r\n    GREATER_THAN_OR_EQUAL: 54,\r\n    LESS_THAN: 55,\r\n    LESS_THAN_OR_EQUAL: 56,\r\n    LOGICAL_AND: 57,\r\n    LOGICAL_OR: 58,\r\n    LOGICAL_XOR: 59,\r\n    MINUS: 60,\r\n    MULTIPLY: 61,\r\n    NOT_EQUAL: 62,\r\n    PLUS: 63,\r\n    REMAINDER: 64,\r\n    SHIFT_LEFT: 65,\r\n    SHIFT_RIGHT: 66,\r\n\r\n    // Binary assignment\r\n    ASSIGN: 67,\r\n    ASSIGN_ADD: 68,\r\n    ASSIGN_BITWISE_AND: 69,\r\n    ASSIGN_BITWISE_OR: 70,\r\n    ASSIGN_BITWISE_XOR: 71,\r\n    ASSIGN_DIVIDE: 72,\r\n    ASSIGN_MULTIPLY: 73,\r\n    ASSIGN_REMAINDER: 74,\r\n    ASSIGN_SHIFT_LEFT: 75,\r\n    ASSIGN_SHIFT_RIGHT: 76,\r\n    ASSIGN_SUBTRACT: 77,\r\n\r\n    // Other operators\r\n    COLON: 78,\r\n    COMMA: 79,\r\n    DOT: 80,\r\n    LEFT_BRACE: 81,\r\n    LEFT_BRACKET: 82,\r\n    LEFT_PARENTHESIS: 83,\r\n    QUESTION: 84,\r\n    RIGHT_BRACE: 85,\r\n    RIGHT_BRACKET: 86,\r\n    RIGHT_PARENTHESIS: 87,\r\n    SEMICOLON: 88,\r\n\r\n    // Pragmas\r\n    EXTENSION: 89,\r\n    VERSION: 90,\r\n    INCLUDE: 91,\r\n\r\n    // Literals\r\n    FLOAT_LITERAL: 92,\r\n    IDENTIFIER: 93,\r\n    INT_LITERAL: 94,\r\n    STRING_LITERAL: 95,\r\n\r\n    // This is always at the end of the token stream\r\n    END_OF_FILE: 96\r\n  };\r\n\r\n  GLSLX.Token = function(range, kind) {\r\n    this.range = range;\r\n    this.kind = kind;\r\n  };\r\n\r\n  GLSLX.Tokenizer = {};\r\n\r\n  GLSLX.Tokenizer.tokenize = function(log, source) {\r\n    var parts = source.contents.split(GLSLX.Tokenizer._tokenRegex);\r\n    var tokens = [];\r\n    var start = 0;\r\n\r\n    for (var i = 0, count1 = parts.length; i < count1; i = i + 1 | 0) {\r\n      var part = in_List.get(parts, i);\r\n      var count = part.length;\r\n      var end = start + count | 0;\r\n      var range = new GLSLX.Range(source, start, end);\r\n\r\n      if (i % 2 != 0) {\r\n        var c = in_string.get1(part, 0);\r\n\r\n        // Identifier\r\n        if (c >= 65 && c <= 90 || c >= 97 && c <= 122 || c == 95) {\r\n          var keyword = in_StringMap.get(GLSLX.Tokenizer.keywords, part, GLSLX.TokenKind.END_OF_FILE);\r\n\r\n          if (keyword != GLSLX.TokenKind.END_OF_FILE) {\r\n            tokens.push(new GLSLX.Token(range, keyword));\r\n          }\r\n\r\n          else if (part in GLSLX.Tokenizer.reservedWords) {\r\n            log.syntaxErrorReservedWord(range);\r\n          }\r\n\r\n          else {\r\n            tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.IDENTIFIER));\r\n          }\r\n        }\r\n\r\n        // Number\r\n        else if (c >= 48 && c <= 57 || c == 46 && count > 1) {\r\n          tokens.push(new GLSLX.Token(range, GLSLX.Tokenizer._intRegex.test(part) ? GLSLX.TokenKind.INT_LITERAL : GLSLX.TokenKind.FLOAT_LITERAL));\r\n        }\r\n\r\n        // Pragma\r\n        else if (c == 35) {\r\n          tokens.push(new GLSLX.Token(range, in_string.get1(part, 1) == 118 ? GLSLX.TokenKind.VERSION : in_string.get1(part, 1) == 101 ? GLSLX.TokenKind.EXTENSION : GLSLX.TokenKind.INCLUDE));\r\n        }\r\n\r\n        // String literal\r\n        else if (c == 34) {\r\n          tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.STRING_LITERAL));\r\n        }\r\n\r\n        // Operator\r\n        else {\r\n          var kind = in_StringMap.get(GLSLX.Tokenizer.operators, part, GLSLX.TokenKind.END_OF_FILE);\r\n\r\n          if (kind != GLSLX.TokenKind.END_OF_FILE) {\r\n            tokens.push(new GLSLX.Token(range, kind));\r\n          }\r\n        }\r\n      }\r\n\r\n      else if (part != '') {\r\n        log.syntaxErrorExtraData(range, part);\r\n        break;\r\n      }\r\n\r\n      start = end;\r\n    }\r\n\r\n    tokens.push(new GLSLX.Token(new GLSLX.Range(source, start, start), GLSLX.TokenKind.END_OF_FILE));\r\n    return tokens;\r\n  };\r\n\r\n  GLSLX.Type = function(symbol, isArrayOf, arrayCount) {\r\n    this.symbol = symbol;\r\n    this.isArrayOf = isArrayOf;\r\n    this.arrayCount = arrayCount;\r\n    this.containsArray = false;\r\n    this.containsSampler = false;\r\n    this._arrayTypes = null;\r\n  };\r\n\r\n  // A count of \"0\" means an array with an unknown size\r\n  GLSLX.Type.prototype.arrayType = function(count) {\r\n    assert(count >= 0);\r\n\r\n    if (this._arrayTypes == null) {\r\n      this._arrayTypes = {};\r\n    }\r\n\r\n    var arrayType = in_IntMap.get(this._arrayTypes, count, null);\r\n\r\n    if (arrayType == null) {\r\n      this._arrayTypes[count] = arrayType = new GLSLX.Type(null, this, count);\r\n      arrayType.containsArray = true;\r\n      arrayType.containsSampler = this.containsSampler;\r\n    }\r\n\r\n    return arrayType;\r\n  };\r\n\r\n  GLSLX.Type.prototype.toString = function() {\r\n    if (this.isArrayOf != null) {\r\n      return this.arrayCount != 0 ? this.isArrayOf.toString() + '[' + this.arrayCount.toString() + ']' : this.isArrayOf.toString() + '[]';\r\n    }\r\n\r\n    return this.symbol.name;\r\n  };\r\n\r\n  // For index expressions where \"0 <= index < indexCount\" (so indexCount == 0 means this type is un-indexable)\r\n  GLSLX.Type.prototype.indexCount = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.MAT2: {\r\n        return 2;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.MAT3: {\r\n        return 3;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.VEC4:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.MAT4: {\r\n        return 4;\r\n      }\r\n\r\n      default: {\r\n        return this.arrayCount;\r\n      }\r\n    }\r\n  };\r\n\r\n  // For index expressions\r\n  GLSLX.Type.prototype.indexType = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.BVEC4: {\r\n        return GLSLX.Type.BOOL;\r\n      }\r\n\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4: {\r\n        return GLSLX.Type.FLOAT;\r\n      }\r\n\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4: {\r\n        return GLSLX.Type.INT;\r\n      }\r\n\r\n      case GLSLX.Type.MAT2: {\r\n        return GLSLX.Type.VEC2;\r\n      }\r\n\r\n      case GLSLX.Type.MAT3: {\r\n        return GLSLX.Type.VEC3;\r\n      }\r\n\r\n      case GLSLX.Type.MAT4: {\r\n        return GLSLX.Type.VEC4;\r\n      }\r\n\r\n      default: {\r\n        return this.isArrayOf;\r\n      }\r\n    }\r\n  };\r\n\r\n  // For constructor expressions, returns the number of required elements\r\n  GLSLX.Type.prototype.componentCount = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BOOL:\r\n      case GLSLX.Type.FLOAT:\r\n      case GLSLX.Type.INT: {\r\n        return 1;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.IVEC2: {\r\n        return 2;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.IVEC3: {\r\n        return 3;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.VEC4:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.MAT2: {\r\n        return 4;\r\n      }\r\n\r\n      case GLSLX.Type.MAT3: {\r\n        return 9;\r\n      }\r\n\r\n      case GLSLX.Type.MAT4: {\r\n        return 16;\r\n      }\r\n\r\n      default: {\r\n        return 0;\r\n      }\r\n    }\r\n  };\r\n\r\n  // For constructor expressions, returns the base element type corresponding to componentCount\r\n  GLSLX.Type.prototype.componentType = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BOOL:\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.BVEC4: {\r\n        return GLSLX.Type.BOOL;\r\n      }\r\n\r\n      case GLSLX.Type.FLOAT:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4:\r\n      case GLSLX.Type.MAT2:\r\n      case GLSLX.Type.MAT3:\r\n      case GLSLX.Type.MAT4: {\r\n        return GLSLX.Type.FLOAT;\r\n      }\r\n\r\n      case GLSLX.Type.INT:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4: {\r\n        return GLSLX.Type.INT;\r\n      }\r\n\r\n      default: {\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Vector types are the only ones with swizzles\r\n  GLSLX.Type.prototype.isVector = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.isMatrix = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.MAT2:\r\n      case GLSLX.Type.MAT3:\r\n      case GLSLX.Type.MAT4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.hasIntComponents = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.INT:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.hasFloatComponents = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.FLOAT:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4: {\r\n        return true;\r\n      }\r\n\r\n      case GLSLX.Type.MAT2:\r\n      case GLSLX.Type.MAT3:\r\n      case GLSLX.Type.MAT4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.isIntOrFloat = function() {\r\n    return this.hasIntComponents() || this.hasFloatComponents();\r\n  };\r\n\r\n  GLSLX.Type.prototype.canUseEqualityOperators = function() {\r\n    return !this.containsSampler && !this.containsArray;\r\n  };\r\n\r\n  GLSLX.Type.prototype._setContainsSampler = function() {\r\n    this.containsSampler = true;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Exports = {};\r\n\r\n  GLSLX.Exports.sourcesFromInput = function(input) {\r\n    if (__isString(input)) {\r\n      return [new GLSLX.Source('<stdin>', input)];\r\n    }\r\n\r\n    if (input instanceof Array) {\r\n      var sources = [];\r\n\r\n      for (var i = 0, count = input.length; i < count; i = i + 1 | 0) {\r\n        sources.push(new GLSLX.Source(input[i].name, input[i].contents));\r\n      }\r\n\r\n      return sources;\r\n    }\r\n\r\n    return [new GLSLX.Source(input.name, input.contents)];\r\n  };\r\n\r\n  GLSLX.Exports.main = function() {\r\n    var $this = (function() {\r\n      return this;\r\n    })();\r\n    var root =  true ? exports : $this.GLSLX = {};\r\n\r\n    // API exports\r\n    root.check = GLSLX.Exports.check;\r\n  };\r\n\r\n  GLSLX.Exports.check = function(input, args) {\r\n    args = args || {};\r\n    var sources = GLSLX.Exports.sourcesFromInput(input);\r\n    var log = new GLSLX.Log();\r\n    var options = new GLSLX.CompilerOptions();\r\n\r\n    if (args.disableRewriting) {\r\n      options.compactSyntaxTree = false;\r\n    }\r\n\r\n    if (args.prettyPrint) {\r\n      options.removeWhitespace = false;\r\n    }\r\n\r\n    if (args.keepSymbols) {\r\n      options.trimSymbols = false;\r\n    }\r\n\r\n    if (args.globals) {\r\n      options.globals = args.globals;\r\n    }\r\n\r\n    var result = GLSLX.Compiler.typeCheck(log, sources, options);\r\n    return {'log': log, 'result': result};\r\n  };\r\n\r\n  GLSLX.in_NodeKind = {};\r\n\r\n  GLSLX.in_NodeKind.isStatement = function(self) {\r\n    return self >= GLSLX.NodeKind.BLOCK && self <= GLSLX.NodeKind.WHILE;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isExpression = function(self) {\r\n    return self >= GLSLX.NodeKind.CALL && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnary = function(self) {\r\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnaryPrefix = function(self) {\r\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.PREFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnaryPostfix = function(self) {\r\n    return self >= GLSLX.NodeKind.POSTFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnaryAssign = function(self) {\r\n    return self >= GLSLX.NodeKind.PREFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isBinary = function(self) {\r\n    return self >= GLSLX.NodeKind.ADD && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isBinaryAssign = function(self) {\r\n    return self >= GLSLX.NodeKind.ASSIGN && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isLoop = function(self) {\r\n    return self == GLSLX.NodeKind.DO_WHILE || self == GLSLX.NodeKind.FOR || self == GLSLX.NodeKind.WHILE;\r\n  };\r\n\r\n  GLSLX.in_TokenKind = {};\r\n  var in_string = {};\r\n\r\n  in_string.slice2 = function(self, start, end) {\r\n    assert(0 <= start && start <= end && end <= self.length);\r\n    return self.slice(start, end);\r\n  };\r\n\r\n  in_string.get1 = function(self, index) {\r\n    assert(0 <= index && index < self.length);\r\n    return self.charCodeAt(index);\r\n  };\r\n\r\n  in_string.get = function(self, index) {\r\n    assert(0 <= index && index < self.length);\r\n    return self[index];\r\n  };\r\n\r\n  var in_List = {};\r\n\r\n  in_List.setLast = function(self, x) {\r\n    return in_List.set(self, self.length - 1 | 0, x);\r\n  };\r\n\r\n  in_List.get = function(self, index) {\r\n    assert(0 <= index && index < self.length);\r\n    return self[index];\r\n  };\r\n\r\n  in_List.set = function(self, index, value) {\r\n    assert(0 <= index && index < self.length);\r\n    return self[index] = value;\r\n  };\r\n\r\n  in_List.first = function(self) {\r\n    assert(!(self.length == 0));\r\n    return in_List.get(self, 0);\r\n  };\r\n\r\n  in_List.last = function(self) {\r\n    assert(!(self.length == 0));\r\n    return in_List.get(self, self.length - 1 | 0);\r\n  };\r\n\r\n  in_List.removeLast = function(self) {\r\n    assert(!(self.length == 0));\r\n    self.pop();\r\n  };\r\n\r\n  in_List.takeLast = function(self) {\r\n    assert(!(self.length == 0));\r\n    return self.pop();\r\n  };\r\n\r\n  in_List.removeIf = function(self, callback) {\r\n    var index = 0;\r\n\r\n    // Remove elements in place\r\n    for (var i = 0, count1 = self.length; i < count1; i = i + 1 | 0) {\r\n      if (!callback(in_List.get(self, i))) {\r\n        if (index < i) {\r\n          in_List.set(self, index, in_List.get(self, i));\r\n        }\r\n\r\n        index = index + 1 | 0;\r\n      }\r\n    }\r\n\r\n    // Shrink the array to the correct size\r\n    while (index < self.length) {\r\n      in_List.removeLast(self);\r\n    }\r\n  };\r\n\r\n  var in_StringMap = {};\r\n\r\n  in_StringMap.get1 = function(self, key) {\r\n    assert(key in self);\r\n    return self[key];\r\n  };\r\n\r\n  in_StringMap.insert = function(self, key, value) {\r\n    self[key] = value;\r\n    return self;\r\n  };\r\n\r\n  in_StringMap.get = function(self, key, defaultValue) {\r\n    var value = self[key];\r\n\r\n    // Compare against undefined so the key is only hashed once for speed\r\n    return value !== void 0 ? value : defaultValue;\r\n  };\r\n\r\n  in_StringMap.values = function(self) {\r\n    var values = [];\r\n\r\n    for (var key in self) {\r\n      values.push(in_StringMap.get1(self, key));\r\n    }\r\n\r\n    return values;\r\n  };\r\n\r\n  var in_IntMap = {};\r\n\r\n  in_IntMap.get = function(self, key, defaultValue) {\r\n    var value = self[key];\r\n\r\n    // Compare against undefined so the key is only hashed once for speed\r\n    return value !== void 0 ? value : defaultValue;\r\n  };\r\n\r\n  var RELEASE = false;\r\n\r\n  // This is from https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\r\n  GLSLX.API = '\\nimport {\\n  highp vec4 gl_Position; // should be written to\\n  mediump float gl_PointSize; // may be written to\\n\\n  const int gl_MaxVertexAttribs;\\n  const int gl_MaxVertexUniformVectors;\\n  const int gl_MaxVaryingVectors;\\n  const int gl_MaxVertexTextureImageUnits;\\n  const int gl_MaxCombinedTextureImageUnits;\\n  const int gl_MaxTextureImageUnits;\\n  const int gl_MaxFragmentUniformVectors;\\n  const int gl_MaxDrawBuffers;\\n\\n  const bool gl_FrontFacing;\\n  const mediump vec2 gl_PointCoord;\\n  const mediump vec4 gl_FragCoord;\\n  mediump vec4 gl_FragColor;\\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\\n\\n  struct gl_DepthRangeParameters {\\n    float near; // n\\n    float far; // f\\n    float diff; // f - n\\n  };\\n\\n  uniform gl_DepthRangeParameters gl_DepthRange;\\n\\n  // Angle and Trigonometry Functions\\n  float acos(float x);\\n  float asin(float x);\\n  float atan(float y, float x);\\n  float atan(float y_over_x);\\n  float cos(float angle);\\n  float degrees(float radians);\\n  float radians(float degrees);\\n  float sin(float angle);\\n  float tan(float angle);\\n  vec2 acos(vec2 x);\\n  vec2 asin(vec2 x);\\n  vec2 atan(vec2 y, vec2 x);\\n  vec2 atan(vec2 y_over_x);\\n  vec2 cos(vec2 angle);\\n  vec2 degrees(vec2 radians);\\n  vec2 radians(vec2 degrees);\\n  vec2 sin(vec2 angle);\\n  vec2 tan(vec2 angle);\\n  vec3 acos(vec3 x);\\n  vec3 asin(vec3 x);\\n  vec3 atan(vec3 y, vec3 x);\\n  vec3 atan(vec3 y_over_x);\\n  vec3 cos(vec3 angle);\\n  vec3 degrees(vec3 radians);\\n  vec3 radians(vec3 degrees);\\n  vec3 sin(vec3 angle);\\n  vec3 tan(vec3 angle);\\n  vec4 acos(vec4 x);\\n  vec4 asin(vec4 x);\\n  vec4 atan(vec4 y, vec4 x);\\n  vec4 atan(vec4 y_over_x);\\n  vec4 cos(vec4 angle);\\n  vec4 sin(vec4 angle);\\n  vec4 tan(vec4 angle);\\n\\n  // Exponential Functions\\n  float exp(float x);\\n  float exp2(float x);\\n  float inversesqrt(float x);\\n  float log(float x);\\n  float log2(float x);\\n  float pow(float x, float y);\\n  float sqrt(float x);\\n  vec2 exp(vec2 x);\\n  vec2 exp2(vec2 x);\\n  vec2 inversesqrt(vec2 x);\\n  vec2 log(vec2 x);\\n  vec2 log2(vec2 x);\\n  vec2 pow(vec2 x, vec2 y);\\n  vec2 sqrt(vec2 x);\\n  vec3 exp(vec3 x);\\n  vec3 exp2(vec3 x);\\n  vec3 inversesqrt(vec3 x);\\n  vec3 log(vec3 x);\\n  vec3 log2(vec3 x);\\n  vec3 pow(vec3 x, vec3 y);\\n  vec3 sqrt(vec3 x);\\n  vec4 exp(vec4 x);\\n  vec4 exp2(vec4 x);\\n  vec4 inversesqrt(vec4 x);\\n  vec4 log(vec4 x);\\n  vec4 log2(vec4 x);\\n  vec4 pow(vec4 x, vec4 y);\\n  vec4 sqrt(vec4 x);\\n\\n  // Common Functions\\n  float abs(float x);\\n  float ceil(float x);\\n  float clamp(float x, float minVal, float maxVal);\\n  float floor(float x);\\n  float fract(float x);\\n  float max(float x, float y);\\n  float min(float x, float y);\\n  float mix(float x, float y, float a);\\n  float mod(float x, float y);\\n  float sign(float x);\\n  float smoothstep(float edge0, float edge1, float x);\\n  float step(float edge, float x);\\n  vec2 abs(vec2 x);\\n  vec2 ceil(vec2 x);\\n  vec2 clamp(vec2 x, float minVal, float maxVal);\\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\\n  vec2 floor(vec2 x);\\n  vec2 fract(vec2 x);\\n  vec2 max(vec2 x, float y);\\n  vec2 max(vec2 x, vec2 y);\\n  vec2 min(vec2 x, float y);\\n  vec2 min(vec2 x, vec2 y);\\n  vec2 mix(vec2 x, vec2 y, float a);\\n  vec2 mix(vec2 x, vec2 y, vec2 a);\\n  vec2 mod(vec2 x, float y);\\n  vec2 mod(vec2 x, vec2 y);\\n  vec2 sign(vec2 x);\\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\\n  vec2 step(float edge, vec2 x);\\n  vec2 step(vec2 edge, vec2 x);\\n  vec3 abs(vec3 x);\\n  vec3 ceil(vec3 x);\\n  vec3 clamp(vec3 x, float minVal, float maxVal);\\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\\n  vec3 floor(vec3 x);\\n  vec3 fract(vec3 x);\\n  vec3 max(vec3 x, float y);\\n  vec3 max(vec3 x, vec3 y);\\n  vec3 min(vec3 x, float y);\\n  vec3 min(vec3 x, vec3 y);\\n  vec3 mix(vec3 x, vec3 y, float a);\\n  vec3 mix(vec3 x, vec3 y, vec3 a);\\n  vec3 mod(vec3 x, float y);\\n  vec3 mod(vec3 x, vec3 y);\\n  vec3 sign(vec3 x);\\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\\n  vec3 step(float edge, vec3 x);\\n  vec3 step(vec3 edge, vec3 x);\\n  vec4 abs(vec4 x);\\n  vec4 ceil(vec4 x);\\n  vec4 clamp(vec4 x, float minVal, float maxVal);\\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\\n  vec4 floor(vec4 x);\\n  vec4 fract(vec4 x);\\n  vec4 max(vec4 x, float y);\\n  vec4 max(vec4 x, vec4 y);\\n  vec4 min(vec4 x, float y);\\n  vec4 min(vec4 x, vec4 y);\\n  vec4 mix(vec4 x, vec4 y, float a);\\n  vec4 mix(vec4 x, vec4 y, vec4 a);\\n  vec4 mod(vec4 x, float y);\\n  vec4 mod(vec4 x, vec4 y);\\n  vec4 sign(vec4 x);\\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\\n  vec4 step(float edge, vec4 x);\\n  vec4 step(vec4 edge, vec4 x);\\n\\n  // Geometric Functions\\n  float distance(float p0, float p1);\\n  float distance(vec2 p0, vec2 p1);\\n  float distance(vec3 p0, vec3 p1);\\n  float distance(vec4 p0, vec4 p1);\\n  float dot(float x, float y);\\n  float dot(vec2 x, vec2 y);\\n  float dot(vec3 x, vec3 y);\\n  float dot(vec4 x, vec4 y);\\n  float faceforward(float N, float I, float Nref);\\n  float length(float x);\\n  float length(vec2 x);\\n  float length(vec3 x);\\n  float length(vec4 x);\\n  float normalize(float x);\\n  float reflect(float I, float N);\\n  float refract(float I, float N, float eta);\\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\\n  vec2 normalize(vec2 x);\\n  vec2 reflect(vec2 I, vec2 N);\\n  vec2 refract(vec2 I, vec2 N, float eta);\\n  vec3 cross(vec3 x, vec3 y);\\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\\n  vec3 normalize(vec3 x);\\n  vec3 reflect(vec3 I, vec3 N);\\n  vec3 refract(vec3 I, vec3 N, float eta);\\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\\n  vec4 normalize(vec4 x);\\n  vec4 reflect(vec4 I, vec4 N);\\n  vec4 refract(vec4 I, vec4 N, float eta);\\n\\n  // Matrix Functions\\n  mat2 matrixCompMult(mat2 x, mat2 y);\\n  mat3 matrixCompMult(mat3 x, mat3 y);\\n  mat4 matrixCompMult(mat4 x, mat4 y);\\n\\n  // Vector Relational Functions\\n  bool all(bvec2 x);\\n  bool all(bvec3 x);\\n  bool all(bvec4 x);\\n  bool any(bvec2 x);\\n  bool any(bvec3 x);\\n  bool any(bvec4 x);\\n  bvec2 equal(bvec2 x, bvec2 y);\\n  bvec2 equal(ivec2 x, ivec2 y);\\n  bvec2 equal(vec2 x, vec2 y);\\n  bvec2 greaterThan(ivec2 x, ivec2 y);\\n  bvec2 greaterThan(vec2 x, vec2 y);\\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\\n  bvec2 lessThan(ivec2 x, ivec2 y);\\n  bvec2 lessThan(vec2 x, vec2 y);\\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\\n  bvec2 lessThanEqual(vec2 x, vec2 y);\\n  bvec2 not(bvec2 x);\\n  bvec2 notEqual(bvec2 x, bvec2 y);\\n  bvec2 notEqual(ivec2 x, ivec2 y);\\n  bvec2 notEqual(vec2 x, vec2 y);\\n  bvec3 equal(bvec3 x, bvec3 y);\\n  bvec3 equal(ivec3 x, ivec3 y);\\n  bvec3 equal(vec3 x, vec3 y);\\n  bvec3 greaterThan(ivec3 x, ivec3 y);\\n  bvec3 greaterThan(vec3 x, vec3 y);\\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\\n  bvec3 lessThan(ivec3 x, ivec3 y);\\n  bvec3 lessThan(vec3 x, vec3 y);\\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\\n  bvec3 lessThanEqual(vec3 x, vec3 y);\\n  bvec3 not(bvec3 x);\\n  bvec3 notEqual(bvec3 x, bvec3 y);\\n  bvec3 notEqual(ivec3 x, ivec3 y);\\n  bvec3 notEqual(vec3 x, vec3 y);\\n  bvec4 equal(bvec4 x, bvec4 y);\\n  bvec4 equal(ivec4 x, ivec4 y);\\n  bvec4 equal(vec4 x, vec4 y);\\n  bvec4 greaterThan(ivec4 x, ivec4 y);\\n  bvec4 greaterThan(vec4 x, vec4 y);\\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\\n  bvec4 lessThan(ivec4 x, ivec4 y);\\n  bvec4 lessThan(vec4 x, vec4 y);\\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\\n  bvec4 lessThanEqual(vec4 x, vec4 y);\\n  bvec4 not(bvec4 x);\\n  bvec4 notEqual(bvec4 x, bvec4 y);\\n  bvec4 notEqual(ivec4 x, ivec4 y);\\n  bvec4 notEqual(vec4 x, vec4 y);\\n\\n  // Texture Lookup Functions\\n  vec4 texture2D(sampler2D sampler, vec2 coord);\\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\\n  vec4 textureCube(samplerCube sampler, vec3 coord);\\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\\n\\n  #extension GL_OES_standard_derivatives {\\n    float dFdx(float v);\\n    float dFdy(float v);\\n    float fwidth(float v);\\n    vec2 dFdx(vec2 v);\\n    vec2 dFdy(vec2 v);\\n    vec2 fwidth(vec2 v);\\n    vec3 dFdx(vec3 v);\\n    vec3 dFdy(vec3 v);\\n    vec3 fwidth(vec3 v);\\n    vec4 dFdx(vec4 v);\\n    vec4 dFdy(vec4 v);\\n    vec4 fwidth(vec4 v);\\n  }\\n\\n  #extension GL_EXT_frag_depth {\\n    float gl_FragDepthEXT;\\n  }\\n\\n  #extension GL_EXT_shader_texture_lod {\\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\\n  }\\n}\\n';\r\n  GLSLX.Node._nextID = 0;\r\n  GLSLX.Parser.pratt = null;\r\n  GLSLX.Parser._extensionBehaviors = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'disable', GLSLX.ExtensionBehavior.DISABLE), 'enable', GLSLX.ExtensionBehavior.ENABLE), 'require', GLSLX.ExtensionBehavior.REQUIRE), 'warn', GLSLX.ExtensionBehavior.WARN);\r\n\r\n  // From https://www.khronos.org/registry/webgl/extensions/\r\n  GLSLX.Parser._knownWebGLExtensions = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'GL_OES_standard_derivatives', 0), 'GL_EXT_frag_depth', 0), 'GL_EXT_draw_buffers', 0), 'GL_EXT_shader_texture_lod', 0);\r\n  GLSLX.Swizzle._STRINGS_2 = ['xy', 'st', 'rg'];\r\n  GLSLX.Swizzle._STRINGS_3 = ['xyz', 'stp', 'rgb'];\r\n  GLSLX.Swizzle._STRINGS_4 = ['xyzw', 'stpq', 'rgba'];\r\n\r\n  // The order matters here due to greedy matching\r\n  GLSLX.Tokenizer._tokenRegex = new RegExp('(' + '\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.|' + '[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[1-9][0-9]*\\\\b|' + '0[0-7]*\\\\b|' + '0[xX][0-9A-Fa-f]+\\\\b|' + '[ \\t\\r\\n]|' + '/\\\\*(?:.|\\r\\n|\\n)*?\\\\*/|' + '//.*|' + '&&|\\\\|\\\\||\\\\^\\\\^|\\\\+\\\\+|--|<<=?|>>=?|[()[\\\\]{}\\\\.,?:;]|[+\\\\-*/%=!<>&|^~]=?|' + '[A-Za-z_][A-Za-z0-9_]*\\\\b|' + '#(?:version|extension|include)\\\\b|' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')');\r\n  GLSLX.Tokenizer._intRegex = new RegExp('^(' + '[1-9][0-9]*|' + '0[0-7]*|' + '0[xX][0-9A-Fa-f]+' + ')$');\r\n  GLSLX.Tokenizer.keywords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'attribute', GLSLX.TokenKind.ATTRIBUTE), 'bool', GLSLX.TokenKind.BOOL), 'break', GLSLX.TokenKind.BREAK), 'bvec2', GLSLX.TokenKind.BVEC2), 'bvec3', GLSLX.TokenKind.BVEC3), 'bvec4', GLSLX.TokenKind.BVEC4), 'const', GLSLX.TokenKind.CONST), 'continue', GLSLX.TokenKind.CONTINUE), 'discard', GLSLX.TokenKind.DISCARD), 'do', GLSLX.TokenKind.DO), 'else', GLSLX.TokenKind.ELSE), 'false', GLSLX.TokenKind.FALSE), 'float', GLSLX.TokenKind.FLOAT), 'for', GLSLX.TokenKind.FOR), 'highp', GLSLX.TokenKind.HIGHP), 'if', GLSLX.TokenKind.IF), 'in', GLSLX.TokenKind.IN), 'inout', GLSLX.TokenKind.INOUT), 'int', GLSLX.TokenKind.INT), 'invariant', GLSLX.TokenKind.INVARIANT), 'ivec2', GLSLX.TokenKind.IVEC2), 'ivec3', GLSLX.TokenKind.IVEC3), 'ivec4', GLSLX.TokenKind.IVEC4), 'lowp', GLSLX.TokenKind.LOWP), 'mat2', GLSLX.TokenKind.MAT2), 'mat3', GLSLX.TokenKind.MAT3), 'mat4', GLSLX.TokenKind.MAT4), 'mediump', GLSLX.TokenKind.MEDIUMP), 'out', GLSLX.TokenKind.OUT), 'precision', GLSLX.TokenKind.PRECISION), 'return', GLSLX.TokenKind.RETURN), 'sampler2D', GLSLX.TokenKind.SAMPLER2D), 'samplerCube', GLSLX.TokenKind.SAMPLERCUBE), 'struct', GLSLX.TokenKind.STRUCT), 'true', GLSLX.TokenKind.TRUE), 'uniform', GLSLX.TokenKind.UNIFORM), 'varying', GLSLX.TokenKind.VARYING), 'vec2', GLSLX.TokenKind.VEC2), 'vec3', GLSLX.TokenKind.VEC3), 'vec4', GLSLX.TokenKind.VEC4), 'void', GLSLX.TokenKind.VOID), 'while', GLSLX.TokenKind.WHILE), 'export', GLSLX.TokenKind.EXPORT), 'import', GLSLX.TokenKind.IMPORT);\r\n  GLSLX.Tokenizer.operators = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), '~', GLSLX.TokenKind.COMPLEMENT), '--', GLSLX.TokenKind.DECREMENT), '++', GLSLX.TokenKind.INCREMENT), '!', GLSLX.TokenKind.NOT), '&', GLSLX.TokenKind.BITWISE_AND), '|', GLSLX.TokenKind.BITWISE_OR), '^', GLSLX.TokenKind.BITWISE_XOR), '/', GLSLX.TokenKind.DIVIDE), '==', GLSLX.TokenKind.EQUAL), '>', GLSLX.TokenKind.GREATER_THAN), '>=', GLSLX.TokenKind.GREATER_THAN_OR_EQUAL), '<', GLSLX.TokenKind.LESS_THAN), '<=', GLSLX.TokenKind.LESS_THAN_OR_EQUAL), '&&', GLSLX.TokenKind.LOGICAL_AND), '||', GLSLX.TokenKind.LOGICAL_OR), '^^', GLSLX.TokenKind.LOGICAL_XOR), '-', GLSLX.TokenKind.MINUS), '*', GLSLX.TokenKind.MULTIPLY), '!=', GLSLX.TokenKind.NOT_EQUAL), '+', GLSLX.TokenKind.PLUS), '%', GLSLX.TokenKind.REMAINDER), '<<', GLSLX.TokenKind.SHIFT_LEFT), '>>', GLSLX.TokenKind.SHIFT_RIGHT), '=', GLSLX.TokenKind.ASSIGN), '+=', GLSLX.TokenKind.ASSIGN_ADD), '&=', GLSLX.TokenKind.ASSIGN_BITWISE_AND), '|=', GLSLX.TokenKind.ASSIGN_BITWISE_OR), '^=', GLSLX.TokenKind.ASSIGN_BITWISE_XOR), '/=', GLSLX.TokenKind.ASSIGN_DIVIDE), '*=', GLSLX.TokenKind.ASSIGN_MULTIPLY), '%=', GLSLX.TokenKind.ASSIGN_REMAINDER), '<<=', GLSLX.TokenKind.ASSIGN_SHIFT_LEFT), '>>=', GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT), '-=', GLSLX.TokenKind.ASSIGN_SUBTRACT), ':', GLSLX.TokenKind.COLON), ',', GLSLX.TokenKind.COMMA), '.', GLSLX.TokenKind.DOT), '{', GLSLX.TokenKind.LEFT_BRACE), '[', GLSLX.TokenKind.LEFT_BRACKET), '(', GLSLX.TokenKind.LEFT_PARENTHESIS), '?', GLSLX.TokenKind.QUESTION), '}', GLSLX.TokenKind.RIGHT_BRACE), ']', GLSLX.TokenKind.RIGHT_BRACKET), ')', GLSLX.TokenKind.RIGHT_PARENTHESIS), ';', GLSLX.TokenKind.SEMICOLON);\r\n  GLSLX.Tokenizer.reservedWords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'asm', 0), 'cast', 0), 'class', 0), 'default', 0), 'double', 0), 'dvec2', 0), 'dvec3', 0), 'dvec4', 0), 'enum', 0), 'extern', 0), 'external', 0), 'fixed', 0), 'flat', 0), 'fvec2', 0), 'fvec3', 0), 'fvec4', 0), 'goto', 0), 'half', 0), 'hvec2', 0), 'hvec3', 0), 'hvec4', 0), 'inline', 0), 'input', 0), 'interface', 0), 'long', 0), 'namespace', 0), 'noinline', 0), 'output', 0), 'packed', 0), 'public', 0), 'sampler1D', 0), 'sampler1DShadow', 0), 'sampler2DRect', 0), 'sampler2DRectShadow', 0), 'sampler2DShadow', 0), 'sampler3D', 0), 'sampler3DRect', 0), 'short', 0), 'sizeof', 0), 'static', 0), 'superp', 0), 'switch', 0), 'template', 0), 'this', 0), 'typedef', 0), 'union', 0), 'unsigned', 0), 'using', 0), 'volatile', 0);\r\n  GLSLX.Type.BOOL = new GLSLX.StructSymbol(-1, null, 'bool', null).resolvedType();\r\n  GLSLX.Type.BVEC2 = new GLSLX.StructSymbol(-2, null, 'bvec2', null).resolvedType();\r\n  GLSLX.Type.BVEC3 = new GLSLX.StructSymbol(-3, null, 'bvec3', null).resolvedType();\r\n  GLSLX.Type.BVEC4 = new GLSLX.StructSymbol(-4, null, 'bvec4', null).resolvedType();\r\n  GLSLX.Type.ERROR = new GLSLX.StructSymbol(-5, null, '<error>', null).resolvedType();\r\n  GLSLX.Type.FLOAT = new GLSLX.StructSymbol(-6, null, 'float', null).resolvedType();\r\n  GLSLX.Type.INT = new GLSLX.StructSymbol(-7, null, 'int', null).resolvedType();\r\n  GLSLX.Type.IVEC2 = new GLSLX.StructSymbol(-8, null, 'ivec2', null).resolvedType();\r\n  GLSLX.Type.IVEC3 = new GLSLX.StructSymbol(-9, null, 'ivec3', null).resolvedType();\r\n  GLSLX.Type.IVEC4 = new GLSLX.StructSymbol(-10, null, 'ivec4', null).resolvedType();\r\n  GLSLX.Type.MAT2 = new GLSLX.StructSymbol(-11, null, 'mat2', null).resolvedType();\r\n  GLSLX.Type.MAT3 = new GLSLX.StructSymbol(-12, null, 'mat3', null).resolvedType();\r\n  GLSLX.Type.MAT4 = new GLSLX.StructSymbol(-13, null, 'mat4', null).resolvedType();\r\n  GLSLX.Type.SAMPLER2D = new GLSLX.StructSymbol(-14, null, 'sampler2D', null).resolvedType()._setContainsSampler();\r\n  GLSLX.Type.SAMPLERCUBE = new GLSLX.StructSymbol(-15, null, 'samplerCube', null).resolvedType()._setContainsSampler();\r\n  GLSLX.Type.VEC2 = new GLSLX.StructSymbol(-16, null, 'vec2', null).resolvedType();\r\n  GLSLX.Type.VEC3 = new GLSLX.StructSymbol(-17, null, 'vec3', null).resolvedType();\r\n  GLSLX.Type.VEC4 = new GLSLX.StructSymbol(-18, null, 'vec4', null).resolvedType();\r\n  GLSLX.Type.VOID = new GLSLX.StructSymbol(-19, null, 'void', null).resolvedType();\r\n  GLSLX.in_TokenKind._strings = ['ATTRIBUTE', 'BOOL', 'BREAK', 'BVEC2', 'BVEC3', 'BVEC4', 'CONST', 'CONTINUE', 'DISCARD', 'DO', 'ELSE', 'FALSE', 'FLOAT', 'FOR', 'HIGHP', 'IF', 'IN', 'INOUT', 'INT', 'INVARIANT', 'IVEC2', 'IVEC3', 'IVEC4', 'LOWP', 'MAT2', 'MAT3', 'MAT4', 'MEDIUMP', 'OUT', 'PRECISION', 'RETURN', 'SAMPLER2D', 'SAMPLERCUBE', 'STRUCT', 'TRUE', 'UNIFORM', 'VARYING', 'VEC2', 'VEC3', 'VEC4', 'VOID', 'WHILE', 'EXPORT', 'IMPORT', 'COMPLEMENT', 'DECREMENT', 'INCREMENT', 'NOT', 'BITWISE_AND', 'BITWISE_OR', 'BITWISE_XOR', 'DIVIDE', 'EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'LOGICAL_AND', 'LOGICAL_OR', 'LOGICAL_XOR', 'MINUS', 'MULTIPLY', 'NOT_EQUAL', 'PLUS', 'REMAINDER', 'SHIFT_LEFT', 'SHIFT_RIGHT', 'ASSIGN', 'ASSIGN_ADD', 'ASSIGN_BITWISE_AND', 'ASSIGN_BITWISE_OR', 'ASSIGN_BITWISE_XOR', 'ASSIGN_DIVIDE', 'ASSIGN_MULTIPLY', 'ASSIGN_REMAINDER', 'ASSIGN_SHIFT_LEFT', 'ASSIGN_SHIFT_RIGHT', 'ASSIGN_SUBTRACT', 'COLON', 'COMMA', 'DOT', 'LEFT_BRACE', 'LEFT_BRACKET', 'LEFT_PARENTHESIS', 'QUESTION', 'RIGHT_BRACE', 'RIGHT_BRACKET', 'RIGHT_PARENTHESIS', 'SEMICOLON', 'EXTENSION', 'VERSION', 'INCLUDE', 'FLOAT_LITERAL', 'IDENTIFIER', 'INT_LITERAL', 'STRING_LITERAL', 'END_OF_FILE'];\r\n\r\n  GLSLX.Exports.main();\r\n})();\r\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/2.6211802dcc3d9ebf8ca5.js","(function() {\r\n  function __extends(derived, base) {\r\n    derived.prototype = Object.create(base.prototype);\r\n    derived.prototype.constructor = derived;\r\n  }\r\n\r\n  var __imul = Math.imul ? Math.imul : function(a, b) {\r\n    return (a * (b >>> 16) << 16) + a * (b & 65535) | 0;\r\n  };\r\n\r\n  function __isString(value) {\r\n    return typeof value === 'string';\r\n  }\r\n\r\n  function assert(truth) {\r\n    if (!truth) {\r\n      throw Error('Assertion failed');\r\n    }\r\n  }\r\n\r\n  var GLSLX = {};\r\n\r\n  GLSLX.RenameSymbols = {\r\n    ALL: 0\r\n  };\r\n\r\n  GLSLX.CompilerOptions = function() {\r\n    this.compactSyntaxTree = true;\r\n    this.removeWhitespace = true;\r\n    this.renameSymbols = GLSLX.RenameSymbols.ALL;\r\n    this.trimSymbols = true;\r\n    this.fileAccess = null;\r\n    this.globals = null;\r\n  };\r\n\r\n  GLSLX.ExtensionBehavior = {\r\n    DEFAULT: 0,\r\n    DISABLE: 1,\r\n    ENABLE: 2,\r\n    REQUIRE: 3,\r\n    WARN: 4\r\n  };\r\n\r\n  GLSLX.CompilerData = function(fileAccess) {\r\n    this.currentExtensions = Object.create(null);\r\n    this.fileAccess = fileAccess;\r\n    this._nextSymbolID = 0;\r\n  };\r\n\r\n  GLSLX.CompilerData.prototype.nextSymbolID = function() {\r\n    this._nextSymbolID = this._nextSymbolID + 1 | 0;\r\n    return this._nextSymbolID;\r\n  };\r\n\r\n  GLSLX.CompilerData.prototype.extensionBehavior = function(name) {\r\n    return in_StringMap.get(this.currentExtensions, name, GLSLX.ExtensionBehavior.DEFAULT);\r\n  };\r\n\r\n  GLSLX.Compiler = {};\r\n\r\n  GLSLX.Compiler.typeCheck = function(log, sources, options) {\r\n    if (log.hasErrors()) {\r\n      return null;\r\n    }\r\n\r\n    // Generate tokens once\r\n    sources.unshift(new GLSLX.Source('<api>', GLSLX.API));\r\n\r\n    if (options.globals != null) {\r\n      sources.unshift(new GLSLX.Source('<externs_globals>', options.globals));\r\n    }\r\n\r\n    for (var i = 0, list = sources, count = list.length; i < count; i = i + 1 | 0) {\r\n      var source = in_List.get(list, i);\r\n      source.tokens = GLSLX.Tokenizer.tokenize(log, source);\r\n    }\r\n\r\n    var global = new GLSLX.Node(GLSLX.NodeKind.GLOBAL);\r\n    var scope = new GLSLX.Scope(GLSLX.ScopeKind.GLOBAL, null);\r\n    var data = new GLSLX.CompilerData(options.fileAccess);\r\n    var resolver = new GLSLX.Resolver(log, data);\r\n\r\n    // Parse everything next\r\n    for (var i1 = 0, list1 = sources, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n      var source1 = in_List.get(list1, i1);\r\n      GLSLX.Parser.parse(log, source1.tokens, global, data, scope, resolver);\r\n    }\r\n\r\n    // Then run type checking\r\n    resolver.resolveGlobal(global);\r\n\r\n    // Always return even when there were errors since the partial result is still useful\r\n    return global;\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer = function() {\r\n    this._isLoopBreakTarget = [];\r\n    this._isControlFlowLive = [];\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer.prototype.pushBlock = function(node) {\r\n    var parent = node.parent();\r\n\r\n    // Push control flow\r\n    this._isControlFlowLive.push(this._isControlFlowLive.length == 0 || in_List.last(this._isControlFlowLive));\r\n\r\n    // Push loop info\r\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind)) {\r\n      this._isLoopBreakTarget.push(false);\r\n    }\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer.prototype.popBlock = function(node) {\r\n    var parent = node.parent();\r\n\r\n    // Pop control flow\r\n    var isLive = in_List.takeLast(this._isControlFlowLive);\r\n\r\n    if (isLive) {\r\n      node.hasControlFlowAtEnd = true;\r\n    }\r\n\r\n    // Pop loop info\r\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind) && !in_List.takeLast(this._isLoopBreakTarget) && (parent.kind == GLSLX.NodeKind.WHILE && parent.whileTest().isTrue() || parent.kind == GLSLX.NodeKind.DO_WHILE && parent.doWhileTest().isTrue() || parent.kind == GLSLX.NodeKind.FOR && (parent.forTest() == null || parent.forTest().isTrue()))) {\r\n      in_List.setLast(this._isControlFlowLive, false);\r\n    }\r\n  };\r\n\r\n  GLSLX.ControlFlowAnalyzer.prototype.visitStatement = function(node) {\r\n    if (!in_List.last(this._isControlFlowLive)) {\r\n      return;\r\n    }\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.BREAK: {\r\n        if (!(this._isLoopBreakTarget.length == 0)) {\r\n          in_List.setLast(this._isLoopBreakTarget, true);\r\n        }\r\n\r\n        in_List.setLast(this._isControlFlowLive, false);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.RETURN:\r\n      case GLSLX.NodeKind.DISCARD:\r\n      case GLSLX.NodeKind.CONTINUE: {\r\n        in_List.setLast(this._isControlFlowLive, false);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.IF: {\r\n        var test = node.ifTest();\r\n        var trueValue = node.ifTrue();\r\n        var falseValue = node.ifFalse();\r\n\r\n        if (test.isTrue()) {\r\n          if (!trueValue.hasControlFlowAtEnd) {\r\n            in_List.setLast(this._isControlFlowLive, false);\r\n          }\r\n        }\r\n\r\n        else if (test.isFalse() && falseValue != null) {\r\n          if (!falseValue.hasControlFlowAtEnd) {\r\n            in_List.setLast(this._isControlFlowLive, false);\r\n          }\r\n        }\r\n\r\n        else if (trueValue != null && falseValue != null) {\r\n          if (!trueValue.hasControlFlowAtEnd && !falseValue.hasControlFlowAtEnd) {\r\n            in_List.setLast(this._isControlFlowLive, false);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Folder = {};\r\n\r\n  GLSLX.Folder.fold = function(node) {\r\n    if (RELEASE) {\r\n      return GLSLX.Folder._fold(node);\r\n    }\r\n\r\n    // Run sanity checks in debug mode\r\n    else {\r\n      var folded = GLSLX.Folder._fold(node);\r\n\r\n      if (folded != null) {\r\n        assert(folded.parent() == null);\r\n\r\n        if (folded.kind != GLSLX.NodeKind.UNKNOWN_CONSTANT) {\r\n          GLSLX.Folder._check(folded);\r\n        }\r\n      }\r\n\r\n      return folded;\r\n    }\r\n  };\r\n\r\n  GLSLX.Folder._check = function(node) {\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.INT: {\r\n        assert(node.resolvedType == GLSLX.Type.INT && !node.hasChildren());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.BOOL: {\r\n        assert(node.resolvedType == GLSLX.Type.BOOL && !node.hasChildren());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FLOAT: {\r\n        assert(node.resolvedType == GLSLX.Type.FLOAT && !node.hasChildren());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.CALL: {\r\n        var target = node.callTarget();\r\n        assert(target.kind == GLSLX.NodeKind.TYPE);\r\n        assert(target.resolvedType == node.resolvedType);\r\n        var componentType = target.resolvedType.componentType();\r\n        var componentCount = target.resolvedType.componentCount();\r\n\r\n        // Native component types\r\n        if (componentType != null) {\r\n          assert(node.childCount() == (1 + componentCount | 0));\r\n          assert(target.resolvedType != GLSLX.Type.INT && target.resolvedType != GLSLX.Type.BOOL && target.resolvedType != GLSLX.Type.FLOAT);\r\n\r\n          for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\r\n            assert(child.resolvedType == componentType);\r\n            assert(child.kind != GLSLX.NodeKind.CALL);\r\n            GLSLX.Folder._check(child);\r\n          }\r\n        }\r\n\r\n        // User-defined structs\r\n        else {\r\n          var struct = target.resolvedType.symbol.asStruct();\r\n          var i = 0;\r\n          assert(node.childCount() == (1 + struct.variables.length | 0));\r\n\r\n          for (var child1 = target.nextSibling(); child1 != null; child1 = child1.nextSibling()) {\r\n            assert(child1.resolvedType == in_List.get(struct.variables, i).type.resolvedType);\r\n            GLSLX.Folder._check(child1);\r\n            i = i + 1 | 0;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        assert(false);\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Folder._fold = function(node) {\r\n    assert(node.resolvedType != null);\r\n\r\n    if (node.resolvedType == GLSLX.Type.ERROR) {\r\n      return null;\r\n    }\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.INT:\r\n      case GLSLX.NodeKind.FLOAT:\r\n      case GLSLX.NodeKind.BOOL: {\r\n        return node.clone();\r\n      }\r\n\r\n      case GLSLX.NodeKind.NAME: {\r\n        return GLSLX.Folder._foldName(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.SEQUENCE: {\r\n        return GLSLX.Folder._foldSequence(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.HOOK: {\r\n        return GLSLX.Folder._foldHook(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.DOT: {\r\n        return GLSLX.Folder._foldDot(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.INDEX: {\r\n        return GLSLX.Folder._foldIndex(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.CALL: {\r\n        return GLSLX.Folder._foldCall(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.NEGATIVE: {\r\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\r\n          return -x;\r\n        }, function(x) {\r\n          return -x | 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.NOT: {\r\n        return GLSLX.Folder._foldUnaryBool(node, function(x) {\r\n          return !x;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.POSITIVE: {\r\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\r\n          return +x;\r\n        }, function(x) {\r\n          return +x;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.ADD: {\r\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\r\n          return a + b;\r\n        }, function(a, b) {\r\n          return a + b | 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.SUBTRACT: {\r\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\r\n          return a - b;\r\n        }, function(a, b) {\r\n          return a - b | 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.MULTIPLY: {\r\n        return GLSLX.Folder._foldMultiply(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.DIVIDE: {\r\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\r\n          return b != 0 ? a / b : 0;\r\n        }, function(a, b) {\r\n          return b != 0 ? a / b | 0 : 0;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.EQUAL:\r\n      case GLSLX.NodeKind.NOT_EQUAL: {\r\n        return GLSLX.Folder._foldBinaryEquality(node);\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_AND: {\r\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\r\n          return a && b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_OR: {\r\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\r\n          return a || b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_XOR: {\r\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\r\n          return a != b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.GREATER_THAN: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a > b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a >= b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LESS_THAN: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a < b;\r\n        });\r\n      }\r\n\r\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL: {\r\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\r\n          return a <= b;\r\n        });\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldName = function(node) {\r\n    var symbol = node.symbol;\r\n\r\n    if (symbol != null && symbol.isConst()) {\r\n      if (symbol.constantValue != null) {\r\n        return symbol.constantValue.clone();\r\n      }\r\n\r\n      if (symbol.asVariable().kind != GLSLX.VariableKind.ARGUMENT) {\r\n        return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(node.resolvedType);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldSequence = function(node) {\r\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n      var folded = GLSLX.Folder.fold(child);\r\n\r\n      if (folded == null || child == node.lastChild()) {\r\n        return folded;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldHook = function(node) {\r\n    var foldedTest = GLSLX.Folder.fold(node.hookTest());\r\n    var foldedTrue = GLSLX.Folder.fold(node.hookTrue());\r\n    var foldedFalse = GLSLX.Folder.fold(node.hookFalse());\r\n\r\n    if (foldedTest != null && foldedTest.kind == GLSLX.NodeKind.BOOL && foldedTrue != null && foldedFalse != null) {\r\n      return foldedTest.asBool() ? foldedTrue : foldedFalse;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldDot = function(node) {\r\n    var folded = GLSLX.Folder.fold(node.dotTarget());\r\n\r\n    if (folded != null && folded.kind == GLSLX.NodeKind.CALL) {\r\n      var resolvedType = folded.resolvedType;\r\n      var name = node.asString();\r\n\r\n      // Evaluate a swizzle\r\n      if (resolvedType.isVector()) {\r\n        var count = name.length;\r\n        var componentCount = resolvedType.componentCount();\r\n\r\n        // Find the swizzle set\r\n        for (var i2 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i2 < count2; i2 = i2 + 1 | 0) {\r\n          var set = in_List.get(list, i2);\r\n\r\n          if (set.indexOf(in_string.get(name, 0)) != -1) {\r\n            if (count == 1) {\r\n              return folded.childAt(1 + set.indexOf(name) | 0).remove();\r\n            }\r\n\r\n            var swizzleType = GLSLX.Swizzle.type(resolvedType.componentType(), count);\r\n            var result = GLSLX.Node.createConstructorCall(swizzleType);\r\n\r\n            for (var i = 0, count1 = count; i < count1; i = i + 1 | 0) {\r\n              result.appendChild(folded.childAt(1 + set.indexOf(in_string.get(name, i)) | 0).clone());\r\n            }\r\n\r\n            return result;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Evaluate a struct field\r\n      else if (resolvedType.symbol != null && resolvedType.symbol.isStruct()) {\r\n        var symbol = resolvedType.symbol.asStruct();\r\n        var variables = symbol.variables;\r\n        assert(folded.childCount() == (1 + variables.length | 0));\r\n\r\n        // Extract the field from the constructor call\r\n        for (var i1 = 0, count3 = variables.length; i1 < count3; i1 = i1 + 1 | 0) {\r\n          var variable = in_List.get(variables, i1);\r\n\r\n          if (variable.name == name) {\r\n            return folded.childAt(1 + i1 | 0).remove();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldIndex = function(node) {\r\n    var foldedLeft = GLSLX.Folder.fold(node.binaryLeft());\r\n    var foldedRight = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    // Both children must also be constants\r\n    if (foldedLeft != null && foldedLeft.kind == GLSLX.NodeKind.CALL && foldedRight != null && foldedRight.kind == GLSLX.NodeKind.INT) {\r\n      var type = foldedLeft.resolvedType;\r\n\r\n      if (type.isVector()) {\r\n        var indexCount = type.indexCount();\r\n        var index = foldedRight.asInt();\r\n\r\n        // The index must be in range\r\n        if (0 <= index && index < indexCount) {\r\n          return foldedLeft.childAt(index + 1 | 0).remove();\r\n        }\r\n      }\r\n\r\n      // Indexing into a matrix creates a vector\r\n      else if (type.isMatrix()) {\r\n        var indexCount1 = type.indexCount();\r\n        var index1 = foldedRight.asInt();\r\n        assert(foldedLeft.childCount() == (1 + __imul(indexCount1, indexCount1) | 0));\r\n\r\n        // The index must be in range\r\n        if (0 <= index1 && index1 < indexCount1) {\r\n          var indexType = type.indexType();\r\n          var result = GLSLX.Node.createConstructorCall(indexType);\r\n          var before = foldedLeft.childAt(__imul(index1, indexCount1));\r\n\r\n          for (var i = 0, count = indexCount1; i < count; i = i + 1 | 0) {\r\n            result.appendChild(before.nextSibling().remove());\r\n          }\r\n\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldCall = function(node) {\r\n    var target = node.callTarget();\r\n\r\n    // Only constructor calls are considered constants\r\n    if (target.kind != GLSLX.NodeKind.TYPE) {\r\n      return null;\r\n    }\r\n\r\n    var type = target.resolvedType;\r\n    var componentType = type.componentType();\r\n    var matrixStride = 0;\r\n    var $arguments = [];\r\n    var count = 0;\r\n\r\n    // Make sure all arguments are constants\r\n    for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\r\n      var folded = GLSLX.Folder.fold(child);\r\n\r\n      if (folded == null) {\r\n        return null;\r\n      }\r\n\r\n      // Expand values inline from constructed native types\r\n      if (folded.kind == GLSLX.NodeKind.CALL && componentType != null && folded.callTarget().resolvedType.componentType() != null) {\r\n        for (var value = folded.callTarget().nextSibling(); value != null; value = value.nextSibling()) {\r\n          var casted = GLSLX.Folder._castValue(componentType, value);\r\n\r\n          if (casted == null) {\r\n            return null;\r\n          }\r\n\r\n          $arguments.push(casted);\r\n        }\r\n      }\r\n\r\n      // Auto-cast values for primitive types\r\n      else {\r\n        if (componentType != null) {\r\n          folded = GLSLX.Folder._castValue(componentType, folded);\r\n\r\n          if (folded == null) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n        $arguments.push(folded);\r\n      }\r\n\r\n      if (folded.resolvedType.isMatrix()) {\r\n        matrixStride = folded.resolvedType.indexCount();\r\n      }\r\n\r\n      count = count + 1 | 0;\r\n    }\r\n\r\n    // If a matrix argument is given to a matrix constructor, it is an error\r\n    // to have any other arguments\r\n    if (type.isMatrix() && matrixStride != 0 && count != 1) {\r\n      return null;\r\n    }\r\n\r\n    // Native component-based types\r\n    if (type.componentType() != null) {\r\n      return GLSLX.Folder._foldComponentConstructor($arguments, type, type.isMatrix() ? matrixStride : 0);\r\n    }\r\n\r\n    // User-defined struct types\r\n    if (type.symbol != null && type.symbol.isStruct()) {\r\n      return GLSLX.Folder._foldStruct($arguments, type);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._floatValues = function(node) {\r\n    var values = [];\r\n\r\n    for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\r\n      values.push(child.asFloat());\r\n    }\r\n\r\n    return values;\r\n  };\r\n\r\n  GLSLX.Folder._foldMultiply = function(node) {\r\n    var ref;\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n    var leftType = left != null ? left.resolvedType : null;\r\n    var rightType = right != null ? right.resolvedType : null;\r\n\r\n    if (left != null && right != null) {\r\n      // Vector-matrix multiply\r\n      if (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) {\r\n        var stride = leftType.indexCount();\r\n        var result = GLSLX.Node.createConstructorCall(leftType);\r\n        var leftValues = GLSLX.Folder._floatValues(left);\r\n        var rightValues = GLSLX.Folder._floatValues(right);\r\n\r\n        for (var i = 0, count1 = stride; i < count1; i = i + 1 | 0) {\r\n          var total = 0;\r\n\r\n          for (var col = 0, count = stride; col < count; col = col + 1 | 0) {\r\n            total += in_List.get(leftValues, col) * in_List.get(rightValues, col + __imul(i, stride) | 0);\r\n          }\r\n\r\n          result.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total).withType(GLSLX.Type.FLOAT));\r\n        }\r\n\r\n        return result;\r\n      }\r\n\r\n      // Matrix-vector multiply\r\n      if (leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) {\r\n        var stride1 = leftType.indexCount();\r\n        var result1 = GLSLX.Node.createConstructorCall(rightType);\r\n        var leftValues1 = GLSLX.Folder._floatValues(left);\r\n        var rightValues1 = GLSLX.Folder._floatValues(right);\r\n\r\n        for (var i1 = 0, count3 = stride1; i1 < count3; i1 = i1 + 1 | 0) {\r\n          var total1 = 0;\r\n\r\n          for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\r\n            total1 += in_List.get(leftValues1, i1 + __imul(row, stride1) | 0) * in_List.get(rightValues1, row);\r\n          }\r\n\r\n          result1.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total1).withType(GLSLX.Type.FLOAT));\r\n        }\r\n\r\n        return result1;\r\n      }\r\n\r\n      // Matrix-matrix multiply\r\n      if (leftType.isMatrix() && rightType == leftType) {\r\n        var stride2 = leftType.indexCount();\r\n        var result2 = GLSLX.Node.createConstructorCall(leftType);\r\n        var leftValues2 = GLSLX.Folder._floatValues(left);\r\n        var rightValues2 = GLSLX.Folder._floatValues(right);\r\n\r\n        for (var row1 = 0, count6 = stride2; row1 < count6; row1 = row1 + 1 | 0) {\r\n          for (var col1 = 0, count5 = stride2; col1 < count5; col1 = col1 + 1 | 0) {\r\n            var total2 = 0;\r\n\r\n            for (var i2 = 0, count4 = stride2; i2 < count4; i2 = i2 + 1 | 0) {\r\n              total2 += in_List.get(leftValues2, col1 + __imul(i2, stride2) | 0) * in_List.get(rightValues2, i2 + __imul(row1, stride2) | 0);\r\n            }\r\n\r\n            result2.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total2).withType(GLSLX.Type.FLOAT));\r\n          }\r\n        }\r\n\r\n        return result2;\r\n      }\r\n\r\n      return (ref = GLSLX.Folder._foldFloat2(left, right, function(a, b) {\r\n        return a * b;\r\n      })) != null ? ref : GLSLX.Folder._foldInt2(left, right, function(a, b) {\r\n        return __imul(a, b);\r\n      });\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._castValue = function(type, node) {\r\n    var value = 0;\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.BOOL: {\r\n        value = +node.asBool();\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.INT: {\r\n        value = node.asInt();\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FLOAT: {\r\n        value = node.asFloat();\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    switch (type) {\r\n      case GLSLX.Type.BOOL: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(!!value).withType(GLSLX.Type.BOOL);\r\n      }\r\n\r\n      case GLSLX.Type.INT: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(value | 0).withType(GLSLX.Type.INT);\r\n      }\r\n\r\n      case GLSLX.Type.FLOAT: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(value).withType(GLSLX.Type.FLOAT);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldComponentConstructor = function($arguments, type, matrixStride) {\r\n    var componentCount = type.componentCount();\r\n    var componentType = type.componentType();\r\n    var node = GLSLX.Node.createConstructorCall(type);\r\n    assert(componentCount > 0);\r\n\r\n    // Passing a single component as an argument always works\r\n    if ($arguments.length == 1) {\r\n      var argument = in_List.first($arguments);\r\n\r\n      if (argument.resolvedType != componentType) {\r\n        return null;\r\n      }\r\n\r\n      // When doing this with a matrix, only the diagonal is filled\r\n      var isMatrix = type.isMatrix();\r\n      var stride = type.indexCount();\r\n\r\n      // Fill the target by repeating the single component\r\n      for (var i = 0, count = componentCount; i < count; i = i + 1 | 0) {\r\n        var isOffMatrixDiagonal = isMatrix && (i % (stride + 1 | 0) | 0) != 0;\r\n        node.appendChild(isOffMatrixDiagonal ? new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(0).withType(GLSLX.Type.FLOAT) : argument.clone());\r\n      }\r\n    }\r\n\r\n    // If a matrix is constructed from a matrix, then each component (column i,\r\n    // row j) in the result that has a corresponding component (column i, row j)\r\n    // in the argument will be initialized from there. All other components will\r\n    // be initialized to the identity matrix.\r\n    else if (matrixStride != 0) {\r\n      var stride1 = type.indexCount();\r\n      assert(type.isMatrix());\r\n      assert(__imul(stride1, stride1) == componentCount);\r\n\r\n      for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\r\n        for (var col = 0, count1 = stride1; col < count1; col = col + 1 | 0) {\r\n          node.appendChild(col < matrixStride && row < matrixStride ? in_List.get($arguments, col + __imul(row, matrixStride) | 0) : new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(col == row ? 1 : 0).withType(GLSLX.Type.FLOAT));\r\n        }\r\n      }\r\n    }\r\n\r\n    // Multiple arguments are more involved\r\n    else {\r\n      // Extra arguments are ignored\r\n      if ($arguments.length < componentCount) {\r\n        return null;\r\n      }\r\n\r\n      // The constructed value is represented as a constructor call\r\n      for (var i1 = 0, count3 = componentCount; i1 < count3; i1 = i1 + 1 | 0) {\r\n        var argument1 = in_List.get($arguments, i1);\r\n\r\n        // All casts should be resolved by this point\r\n        if (argument1.resolvedType != componentType) {\r\n          return null;\r\n        }\r\n\r\n        node.appendChild(argument1);\r\n      }\r\n    }\r\n\r\n    // Don't wrap primitive types\r\n    if (type.indexType() == null) {\r\n      return node.lastChild().remove();\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n  GLSLX.Folder._foldStruct = function($arguments, type) {\r\n    var variables = type.symbol.asStruct().variables;\r\n    var node = GLSLX.Node.createConstructorCall(type);\r\n\r\n    // Structs can only be constructed with the exact number of arguments\r\n    if ($arguments.length != variables.length) {\r\n      return null;\r\n    }\r\n\r\n    // The constructed value is represented as a constructor call\r\n    for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n      if (in_List.get($arguments, i).resolvedType != in_List.get(variables, i).type.resolvedType) {\r\n        return null;\r\n      }\r\n\r\n      node.appendChild(in_List.get($arguments, i));\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryEquality = function(node) {\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    if (left != null && right != null) {\r\n      var value = left.looksTheSameAs(right);\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(node.kind == GLSLX.NodeKind.EQUAL ? value : !value).withType(GLSLX.Type.BOOL);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldComponentwiseUnary = function(node, componentType, argumentKind, op) {\r\n    if (node.kind == GLSLX.NodeKind.CALL && node.callTarget().kind == GLSLX.NodeKind.TYPE && node.callTarget().resolvedType.componentType() == componentType) {\r\n      var result = GLSLX.Node.createConstructorCall(node.callTarget().resolvedType);\r\n\r\n      for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\r\n        var folded = GLSLX.Folder.fold(child);\r\n\r\n        if (folded == null || folded.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result.appendChild(op(folded));\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldFloat1 = function(node, op) {\r\n    if (node.kind == GLSLX.NodeKind.FLOAT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(node.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(x) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(x.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldInt1 = function(node, op) {\r\n    if (node.kind == GLSLX.NodeKind.INT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(node.asInt())).withType(GLSLX.Type.INT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(x) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(x.asInt())).withType(GLSLX.Type.INT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldComponentwiseBinary = function(left, right, componentType, argumentKind, op) {\r\n    var leftHasComponents = left.kind == GLSLX.NodeKind.CALL && left.callTarget().kind == GLSLX.NodeKind.TYPE && left.callTarget().resolvedType.componentType() == componentType;\r\n    var rightHasComponents = right.kind == GLSLX.NodeKind.CALL && right.callTarget().kind == GLSLX.NodeKind.TYPE && right.callTarget().resolvedType.componentType() == componentType;\r\n\r\n    // Vector-vector binary operator\r\n    if (leftHasComponents && rightHasComponents && right.resolvedType == left.resolvedType) {\r\n      var result = GLSLX.Node.createConstructorCall(left.resolvedType);\r\n      var leftChild = left.callTarget().nextSibling();\r\n      var rightChild = right.callTarget().nextSibling();\r\n\r\n      while (leftChild != null && rightChild != null) {\r\n        var foldedLeft = GLSLX.Folder.fold(leftChild);\r\n        var foldedRight = GLSLX.Folder.fold(rightChild);\r\n\r\n        if (foldedLeft == null || foldedLeft.kind != argumentKind || foldedRight == null || foldedRight.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result.appendChild(op(foldedLeft, foldedRight));\r\n        leftChild = leftChild.nextSibling();\r\n        rightChild = rightChild.nextSibling();\r\n      }\r\n\r\n      if (leftChild == null && rightChild == null) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    // Vector-scalar binary operator\r\n    else if (leftHasComponents && right.kind == argumentKind) {\r\n      var result1 = GLSLX.Node.createConstructorCall(left.resolvedType);\r\n\r\n      for (var child = left.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\r\n        var folded = GLSLX.Folder.fold(child);\r\n\r\n        if (folded == null || folded.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result1.appendChild(op(folded, right));\r\n      }\r\n\r\n      return result1;\r\n    }\r\n\r\n    // Scalar-vector binary operator\r\n    else if (left.kind == argumentKind && rightHasComponents) {\r\n      var result2 = GLSLX.Node.createConstructorCall(right.resolvedType);\r\n\r\n      for (var child1 = right.callTarget().nextSibling(); child1 != null; child1 = child1.nextSibling()) {\r\n        var folded1 = GLSLX.Folder.fold(child1);\r\n\r\n        if (folded1 == null || folded1.kind != argumentKind) {\r\n          return null;\r\n        }\r\n\r\n        result2.appendChild(op(left, folded1));\r\n      }\r\n\r\n      return result2;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldFloat2 = function(left, right, op) {\r\n    if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(a, b) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(a.asFloat(), b.asFloat())).withType(GLSLX.Type.FLOAT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldInt2 = function(left, right, op) {\r\n    if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(left.asInt(), right.asInt())).withType(GLSLX.Type.INT);\r\n    }\r\n\r\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(a, b) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(a.asInt(), b.asInt())).withType(GLSLX.Type.INT);\r\n    });\r\n  };\r\n\r\n  GLSLX.Folder._foldUnaryBool = function(node, op) {\r\n    var value = GLSLX.Folder.fold(node.unaryValue());\r\n\r\n    if (value != null && value.kind == GLSLX.NodeKind.BOOL) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(value.asBool())).withType(GLSLX.Type.BOOL);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldUnaryFloatOrInt = function(node, floatOp, intOp) {\r\n    var ref;\r\n    var value = GLSLX.Folder.fold(node.unaryValue());\r\n\r\n    if (value != null) {\r\n      return (ref = GLSLX.Folder._foldFloat1(value, floatOp)) != null ? ref : GLSLX.Folder._foldInt1(value, intOp);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryBool = function(node, op) {\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    if (left != null && right != null && left.kind == GLSLX.NodeKind.BOOL && right.kind == GLSLX.NodeKind.BOOL) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asBool(), right.asBool())).withType(GLSLX.Type.BOOL);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryFloatOrInt = function(node, floatOp, intOp) {\r\n    var ref;\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    if (left != null && right != null) {\r\n      return (ref = GLSLX.Folder._foldFloat2(left, right, floatOp)) != null ? ref : GLSLX.Folder._foldInt2(left, right, intOp);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Folder._foldBinaryFloatOrIntToBool = function(node, op) {\r\n    var left = GLSLX.Folder.fold(node.binaryLeft());\r\n    var right = GLSLX.Folder.fold(node.binaryRight());\r\n\r\n    // The comparison operators only work on scalars in GLSL. To do comparisons\r\n    // on vectors, the functions greaterThan(), lessThan(), greaterThanEqual(),\r\n    // and lessThanEqual() must be used.\r\n    if (left != null && right != null) {\r\n      if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.BOOL);\r\n      }\r\n\r\n      if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asInt(), right.asInt())).withType(GLSLX.Type.BOOL);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.DiagnosticKind = {\r\n    ERROR: 0,\r\n    WARNING: 1\r\n  };\r\n\r\n  GLSLX.Diagnostic = function(kind, range, text) {\r\n    this.kind = kind;\r\n    this.range = range;\r\n    this.text = text;\r\n    this.noteRange = null;\r\n    this.noteText = '';\r\n  };\r\n\r\n  GLSLX.Log = function() {\r\n    this.diagnostics = [];\r\n    this.warningCount = 0;\r\n    this.errorCount = 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.hasErrors = function() {\r\n    return this.errorCount != 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.error = function(range, text) {\r\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.ERROR, range, text));\r\n    this.errorCount = this.errorCount + 1 | 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.warning = function(range, text) {\r\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.WARNING, range, text));\r\n    this.warningCount = this.warningCount + 1 | 0;\r\n  };\r\n\r\n  GLSLX.Log.prototype.note = function(range, text) {\r\n    var last = in_List.last(this.diagnostics);\r\n    last.noteRange = range;\r\n    last.noteText = text;\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxWarningUnknownExtension = function(range, name) {\r\n    this.warning(range, 'The extension \"' + name + '\" is not in the known list of valid WebGL extensions');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInvalidString = function(range) {\r\n    this.error(range, 'Invalid string literal');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorDisabledExtension = function(range, name, extension) {\r\n    this.error(range, 'Cannot use \"' + name + '\" from disabled extension \"' + extension + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorExtraData = function(range, text) {\r\n    this.error(range, 'Syntax error \"' + text + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorReservedWord = function(range) {\r\n    this.error(range, '\"' + range.toString() + '\" is a reserved word');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorUnexpectedToken = function(token) {\r\n    this.error(token.range, 'Unexpected ' + in_List.get(GLSLX.in_TokenKind._strings, token.kind));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorExpectedToken1 = function(range, expected) {\r\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorExpectedToken2 = function(range, found, expected) {\r\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected) + ' but found ' + in_List.get(GLSLX.in_TokenKind._strings, found));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorBadSymbolReference = function(range) {\r\n    this.error(range, 'There is no symbol called \"' + range.toString() + '\" in the current scope');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorDuplicateSymbolDefinition = function(range, previous) {\r\n    this.error(range, 'There is already a symbol called \"' + range.toString() + '\" in the current scope');\r\n    this.note(previous, 'The previous definition of \"' + previous.toString() + '\" is here');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorOutsideLoop = function(range) {\r\n    this.error(range, 'This statement cannot be used outside a loop');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorStructVariableInitializer = function(range) {\r\n    this.error(range, 'Cannot initialize struct variables');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInsideStruct = function(range) {\r\n    this.error(range, 'This statement cannot be used inside a struct');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInsideFunction = function(range) {\r\n    this.error(range, 'This statement cannot be used inside a function');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorOutsideFunction = function(range) {\r\n    this.error(range, 'This statement cannot be used outside a function');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorIncludeWithoutFileAccess = function(range) {\r\n    this.error(range, 'Cannot include files without access to a file system');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorIncludeBadPath = function(range, path) {\r\n    this.error(range, 'Cannot read the file ' + JSON.stringify(path));\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorDifferentReturnType = function(range, name, type, expected, previous) {\r\n    this.error(range, 'Cannot change the return type of \"' + name + '\" to type \"' + type.toString() + '\"');\r\n    this.note(previous, 'The forward declaration of \"' + name + '\" has a return type of \"' + expected.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorBadQualifier = function(range) {\r\n    this.error(range, 'Cannot use this qualifier here');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorConstantRequired = function(range) {\r\n    this.error(range, 'This value must be a compile-time constant');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInvalidArraySize = function(range, count) {\r\n    this.error(range, 'Cannot declare an array with a size of \"' + count.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorMissingArraySize = function(range) {\r\n    this.error(range, 'All array sizes must be specified');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorMultidimensionalArray = function(range) {\r\n    this.error(range, 'Multidimensional arrays are not a part of the language');\r\n  };\r\n\r\n  GLSLX.Log.prototype.syntaxErrorInvalidOperator = function(range) {\r\n    this.error(range, 'The operator \"' + range.toString() + '\" is reserved and cannot be used');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadConversion = function(range, from, to) {\r\n    this.error(range, 'Cannot convert from type \"' + from.toString() + '\" to type \"' + to.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorUnexpectedType = function(range, type) {\r\n    this.error(range, 'Unexpected type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadVariableType = function(range, type) {\r\n    this.error(range, 'Cannot create a variable of type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadMember = function(range, type, name) {\r\n    this.error(range, 'Cannot find \"' + name + '\" on type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadSwizzle = function(range, type, name) {\r\n    this.error(range, 'Invalid swizzle \"' + name + '\" on type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadSwizzleAssignment = function(range, field) {\r\n    this.error(range, 'The field \"' + field + '\" cannot be specified multiple times when used as a storage location');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorMustCallFunction = function(range, name) {\r\n    this.error(range, 'The function \"' + name + '\" must be called');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadCall = function(range, type) {\r\n    this.error(range, 'Cannot call type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadConstructorValue = function(range, type, $constructor) {\r\n    this.error(range, 'Cannot use value of type \"' + type.toString() + '\" when constructing type \"' + $constructor.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorExtraConstructorValue = function(range, type, count, total) {\r\n    this.error(range, 'The constructor for type \"' + type.toString() + '\" only takes ' + count.toString() + ' argument' + (count != 1 ? 's' : '') + ' and this argument would bring the total to ' + total.toString());\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadConstructorCount = function(range, type, count) {\r\n    this.error(range, 'Cannot construct type \"' + type.toString() + '\" with ' + count.toString() + ' argument' + (count != 1 ? 's' : ''));\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArgumentCountFunction = function(range, expected, found, name, $function) {\r\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when calling function \"' + name + '\"');\r\n\r\n    if ($function != null) {\r\n      this.note($function, 'The definition of function \"' + name + '\" is here');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArgumentCountConstructor = function(range, expected, found, name, struct) {\r\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when constructing type \"' + name + '\"');\r\n\r\n    if (struct != null) {\r\n      this.note(struct, 'The definition of struct \"' + name + '\" is here');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadOverloadMatch = function(range, name) {\r\n    this.error(range, 'No matching overload for function \"' + name + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadHookTypes = function(range, left, right) {\r\n    this.error(range, 'Cannot merge type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArrayHook = function(range, type) {\r\n    if (type.isArrayOf != null) {\r\n      this.error(range, 'Cannot use a conditional expression with array type \"' + type.toString() + '\"');\r\n    }\r\n\r\n    else {\r\n      this.error(range, 'Cannot use a conditional expression with type \"' + type.toString() + '\" because it contains an array');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorArrayAssignment = function(range, type) {\r\n    if (type.isArrayOf != null) {\r\n      this.error(range, 'Cannot assign to array type \"' + type.toString() + '\"');\r\n    }\r\n\r\n    else {\r\n      this.error(range, 'Cannot assign to type \"' + type.toString() + '\" because it contains an array');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadUnaryOperator = function(range, operator, type) {\r\n    this.error(range, 'No unary operator \"' + operator + '\" for type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadBinaryOperator = function(range, operator, left, right) {\r\n    if (left == right) {\r\n      this.error(range, 'There is no operator \"' + operator + '\" defined for type \"' + left.toString() + '\"');\r\n    }\r\n\r\n    else {\r\n      this.error(range, 'No binary operator \"' + operator + '\" for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\r\n    }\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadIndex = function(range, left, right) {\r\n    this.error(range, 'No index operator for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorOutOfBoundsIndex = function(range, value, type) {\r\n    this.error(range, 'Index \"' + value.toString() + '\" is out of bounds for type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadStorage = function(range) {\r\n    this.error(range, 'Cannot store to this location');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorUninitializedConstant = function(range) {\r\n    this.error(range, 'Constants must be initialized');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorMissingReturn = function(range, name, type) {\r\n    this.error(range, 'All control paths for \"' + name + '\" must return a value of type \"' + type.toString() + '\"');\r\n  };\r\n\r\n  GLSLX.Log.prototype.semanticErrorBadMatrixConstructor = function(range) {\r\n    this.error(range, 'If a matrix argument is given to a matrix constructor, it is an error to have any other arguments');\r\n  };\r\n\r\n  GLSLX.NodeKind = {\r\n    // Other\r\n    GLOBAL: 0,\r\n    STRUCT_BLOCK: 1,\r\n    VARIABLE: 2,\r\n\r\n    // Statements\r\n    BLOCK: 3,\r\n    BREAK: 4,\r\n    CONTINUE: 5,\r\n    DISCARD: 6,\r\n    DO_WHILE: 7,\r\n    EXPRESSION: 8,\r\n    EXTENSION: 9,\r\n    FOR: 10,\r\n    FUNCTION: 11,\r\n    IF: 12,\r\n    MODIFIER_BLOCK: 13,\r\n    PRECISION: 14,\r\n    RETURN: 15,\r\n    STRUCT: 16,\r\n    VARIABLES: 17,\r\n    VERSION: 18,\r\n    WHILE: 19,\r\n\r\n    // Expressions\r\n    CALL: 20,\r\n    DOT: 21,\r\n    HOOK: 22,\r\n    NAME: 23,\r\n    PARSE_ERROR: 24,\r\n    SEQUENCE: 25,\r\n    TYPE: 26,\r\n    UNKNOWN_CONSTANT: 27,\r\n\r\n    // Literals\r\n    BOOL: 28,\r\n    FLOAT: 29,\r\n    INT: 30,\r\n\r\n    // Unary prefix\r\n    NEGATIVE: 31,\r\n    NOT: 32,\r\n    POSITIVE: 33,\r\n\r\n    // Unary prefix assign\r\n    PREFIX_DECREMENT: 34,\r\n    PREFIX_INCREMENT: 35,\r\n\r\n    // Unary postfix assign\r\n    POSTFIX_DECREMENT: 36,\r\n    POSTFIX_INCREMENT: 37,\r\n\r\n    // Binary\r\n    ADD: 38,\r\n    DIVIDE: 39,\r\n    EQUAL: 40,\r\n    GREATER_THAN: 41,\r\n    GREATER_THAN_OR_EQUAL: 42,\r\n    INDEX: 43,\r\n    LESS_THAN: 44,\r\n    LESS_THAN_OR_EQUAL: 45,\r\n    LOGICAL_AND: 46,\r\n    LOGICAL_OR: 47,\r\n    LOGICAL_XOR: 48,\r\n    MULTIPLY: 49,\r\n    NOT_EQUAL: 50,\r\n    SUBTRACT: 51,\r\n\r\n    // Binary assignment\r\n    ASSIGN: 52,\r\n    ASSIGN_ADD: 53,\r\n    ASSIGN_DIVIDE: 54,\r\n    ASSIGN_MULTIPLY: 55,\r\n    ASSIGN_SUBTRACT: 56\r\n  };\r\n\r\n  GLSLX.Node = function(kind) {\r\n    this.id = GLSLX.Node._createID();\r\n    this.kind = kind;\r\n    this.range = null;\r\n    this.internalRange = null;\r\n    this.symbol = null;\r\n    this.resolvedType = null;\r\n    this._literal = 0;\r\n    this._text = null;\r\n    this._parent = null;\r\n    this._firstChild = null;\r\n    this._lastChild = null;\r\n    this._previousSibling = null;\r\n    this._nextSibling = null;\r\n    this.hasControlFlowAtEnd = false;\r\n  };\r\n\r\n  GLSLX.Node.prototype._copyMembersFrom = function(node) {\r\n    this.kind = node.kind;\r\n    this.range = node.range;\r\n    this.internalRange = node.internalRange;\r\n    this.symbol = node.symbol;\r\n    this.resolvedType = node.resolvedType;\r\n    this._literal = node._literal;\r\n    this._text = node._text;\r\n  };\r\n\r\n  GLSLX.Node.prototype.cloneWithoutChildren = function() {\r\n    var clone = new GLSLX.Node(this.kind);\r\n    clone._copyMembersFrom(this);\r\n    return clone;\r\n  };\r\n\r\n  GLSLX.Node.prototype.clone = function() {\r\n    var clone = this.cloneWithoutChildren();\r\n\r\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\r\n      clone.appendChild(child.clone());\r\n    }\r\n\r\n    return clone;\r\n  };\r\n\r\n  GLSLX.Node.prototype.parent = function() {\r\n    return this._parent;\r\n  };\r\n\r\n  GLSLX.Node.prototype.firstChild = function() {\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.lastChild = function() {\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.nextSibling = function() {\r\n    return this._nextSibling;\r\n  };\r\n\r\n  // This is cheaper than childCount == 0\r\n  GLSLX.Node.prototype.hasChildren = function() {\r\n    return this._firstChild != null;\r\n  };\r\n\r\n  GLSLX.Node.prototype.childCount = function() {\r\n    var count = 0;\r\n\r\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\r\n      count = count + 1 | 0;\r\n    }\r\n\r\n    return count;\r\n  };\r\n\r\n  GLSLX.Node.prototype.childAt = function(index) {\r\n    assert(0 <= index && index < this.childCount());\r\n    var child = this._firstChild;\r\n\r\n    while (index != 0) {\r\n      child = child._nextSibling;\r\n      index = index - 1 | 0;\r\n    }\r\n\r\n    return child;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withType = function(value) {\r\n    this.resolvedType = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withSymbol = function(value) {\r\n    this.symbol = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withBool = function(value) {\r\n    this._literal = +value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withInt = function(value) {\r\n    this._literal = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withFloat = function(value) {\r\n    this._literal = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withText = function(value) {\r\n    this._text = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withRange = function(value) {\r\n    this.range = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.withInternalRange = function(value) {\r\n    this.internalRange = value;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.appendChild = function(node) {\r\n    if (node == null) {\r\n      return this;\r\n    }\r\n\r\n    assert(node != this);\r\n    assert(node._parent == null);\r\n    assert(node._previousSibling == null);\r\n    assert(node._nextSibling == null);\r\n    node._parent = this;\r\n\r\n    if (this.hasChildren()) {\r\n      node._previousSibling = this._lastChild;\r\n      this._lastChild._nextSibling = node;\r\n      this._lastChild = node;\r\n    }\r\n\r\n    else {\r\n      this._lastChild = this._firstChild = node;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.remove = function() {\r\n    assert(this._parent != null);\r\n\r\n    if (this._previousSibling != null) {\r\n      assert(this._previousSibling._nextSibling == this);\r\n      this._previousSibling._nextSibling = this._nextSibling;\r\n    }\r\n\r\n    else {\r\n      assert(this._parent._firstChild == this);\r\n      this._parent._firstChild = this._nextSibling;\r\n    }\r\n\r\n    if (this._nextSibling != null) {\r\n      assert(this._nextSibling._previousSibling == this);\r\n      this._nextSibling._previousSibling = this._previousSibling;\r\n    }\r\n\r\n    else {\r\n      assert(this._parent._lastChild == this);\r\n      this._parent._lastChild = this._previousSibling;\r\n    }\r\n\r\n    this._parent = null;\r\n    this._previousSibling = null;\r\n    this._nextSibling = null;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.insertChildBefore = function(after, before) {\r\n    if (before == null) {\r\n      return this;\r\n    }\r\n\r\n    assert(before != after);\r\n    assert(before._parent == null);\r\n    assert(before._previousSibling == null);\r\n    assert(before._nextSibling == null);\r\n    assert(after == null || after._parent == this);\r\n\r\n    if (after == null) {\r\n      return this.appendChild(before);\r\n    }\r\n\r\n    before._parent = this;\r\n    before._previousSibling = after._previousSibling;\r\n    before._nextSibling = after;\r\n\r\n    if (after._previousSibling != null) {\r\n      assert(after == after._previousSibling._nextSibling);\r\n      after._previousSibling._nextSibling = before;\r\n    }\r\n\r\n    else {\r\n      assert(after == this._firstChild);\r\n      this._firstChild = before;\r\n    }\r\n\r\n    after._previousSibling = before;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.isTrue = function() {\r\n    return this.kind == GLSLX.NodeKind.BOOL && this.asBool();\r\n  };\r\n\r\n  GLSLX.Node.prototype.isFalse = function() {\r\n    return this.kind == GLSLX.NodeKind.BOOL && !this.asBool();\r\n  };\r\n\r\n  GLSLX.Node.prototype.isCallTarget = function() {\r\n    return this.parent() != null && this.parent().kind == GLSLX.NodeKind.CALL && this.parent().callTarget() == this;\r\n  };\r\n\r\n  GLSLX.Node.prototype.isAssignTarget = function() {\r\n    return this.parent() != null && (GLSLX.in_NodeKind.isUnaryAssign(this.parent().kind) || GLSLX.in_NodeKind.isBinaryAssign(this.parent().kind) && this.parent().binaryLeft() == this);\r\n  };\r\n\r\n  GLSLX.Node.prototype.isEmptySequence = function() {\r\n    return this.kind == GLSLX.NodeKind.SEQUENCE && !this.hasChildren();\r\n  };\r\n\r\n  GLSLX.Node.prototype.looksTheSameAs = function(node) {\r\n    if (this.kind == node.kind) {\r\n      switch (this.kind) {\r\n        case GLSLX.NodeKind.BOOL: {\r\n          return this.asBool() == node.asBool();\r\n        }\r\n\r\n        case GLSLX.NodeKind.FLOAT: {\r\n          return this.asFloat() == node.asFloat();\r\n        }\r\n\r\n        case GLSLX.NodeKind.INT: {\r\n          return this.asInt() == node.asInt();\r\n        }\r\n\r\n        case GLSLX.NodeKind.NAME: {\r\n          return this.symbol == node.symbol;\r\n        }\r\n\r\n        case GLSLX.NodeKind.TYPE: {\r\n          return this.resolvedType == node.resolvedType;\r\n        }\r\n\r\n        case GLSLX.NodeKind.DOT: {\r\n          return this.dotTarget().looksTheSameAs(node.dotTarget()) && this.symbol == node.symbol && this.asString() == node.asString();\r\n        }\r\n\r\n        case GLSLX.NodeKind.HOOK: {\r\n          return this.hookTest().looksTheSameAs(node.hookTest()) && this.hookTrue().looksTheSameAs(node.hookTrue()) && this.hookFalse().looksTheSameAs(node.hookFalse());\r\n        }\r\n\r\n        case GLSLX.NodeKind.CALL: {\r\n          var left = this.firstChild();\r\n          var right = node.firstChild();\r\n\r\n          while (left != null && right != null) {\r\n            if (!left.looksTheSameAs(right)) {\r\n              return false;\r\n            }\r\n\r\n            left = left.nextSibling();\r\n            right = right.nextSibling();\r\n          }\r\n\r\n          return left == null && right == null;\r\n        }\r\n\r\n        default: {\r\n          if (GLSLX.in_NodeKind.isUnary(this.kind)) {\r\n            return this.unaryValue().looksTheSameAs(node.unaryValue());\r\n          }\r\n\r\n          if (GLSLX.in_NodeKind.isBinary(this.kind)) {\r\n            return this.binaryLeft().looksTheSameAs(node.binaryLeft()) && this.binaryRight().looksTheSameAs(node.binaryRight());\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  GLSLX.Node.createDoWhile = function(body, test) {\r\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.DO_WHILE).appendChild(body).appendChild(test);\r\n  };\r\n\r\n  GLSLX.Node.createExpression = function(value) {\r\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.EXPRESSION).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createFor = function(setup, test, update, body) {\r\n    assert(setup == null || GLSLX.in_NodeKind.isExpression(setup.kind) || setup.kind == GLSLX.NodeKind.VARIABLES);\r\n    assert(test == null || GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(update == null || GLSLX.in_NodeKind.isExpression(update.kind));\r\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.FOR).appendChild(setup == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : setup).appendChild(test == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : test).appendChild(update == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : update).appendChild(body);\r\n  };\r\n\r\n  GLSLX.Node.createIf = function(test, yes, no) {\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(GLSLX.in_NodeKind.isStatement(yes.kind));\r\n    assert(no == null || GLSLX.in_NodeKind.isStatement(no.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.IF).appendChild(test).appendChild(yes).appendChild(no);\r\n  };\r\n\r\n  GLSLX.Node.createPrecision = function(flags, type) {\r\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.PRECISION).withInt(flags).appendChild(type);\r\n  };\r\n\r\n  GLSLX.Node.createReturn = function(value) {\r\n    assert(value == null || GLSLX.in_NodeKind.isExpression(value.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.RETURN).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createStruct = function(symbol, block, variables) {\r\n    assert(block.kind == GLSLX.NodeKind.STRUCT_BLOCK);\r\n    assert(variables == null || variables.kind == GLSLX.NodeKind.VARIABLES);\r\n    return new GLSLX.Node(GLSLX.NodeKind.STRUCT).withSymbol(symbol).appendChild(block).appendChild(variables);\r\n  };\r\n\r\n  GLSLX.Node.createVariables = function(flags, type) {\r\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.VARIABLES).withInt(flags).appendChild(type);\r\n  };\r\n\r\n  GLSLX.Node.createWhile = function(test, body) {\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.WHILE).appendChild(test).appendChild(body);\r\n  };\r\n\r\n  GLSLX.Node.createCall = function(value) {\r\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.CALL).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createConstructorCall = function(type) {\r\n    return GLSLX.Node.createCall(new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type)).withType(type);\r\n  };\r\n\r\n  GLSLX.Node.createDot = function(value, text) {\r\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\r\n    assert(text != null);\r\n    return new GLSLX.Node(GLSLX.NodeKind.DOT).appendChild(value).withText(text);\r\n  };\r\n\r\n  GLSLX.Node.createHook = function(test, yes, no) {\r\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\r\n    assert(GLSLX.in_NodeKind.isExpression(yes.kind));\r\n    assert(GLSLX.in_NodeKind.isExpression(no.kind));\r\n    return new GLSLX.Node(GLSLX.NodeKind.HOOK).appendChild(test).appendChild(yes).appendChild(no);\r\n  };\r\n\r\n  GLSLX.Node.createUnary = function(kind, value) {\r\n    assert(GLSLX.in_NodeKind.isUnary(kind));\r\n    return new GLSLX.Node(kind).appendChild(value);\r\n  };\r\n\r\n  GLSLX.Node.createBinary = function(kind, left, right) {\r\n    assert(GLSLX.in_NodeKind.isBinary(kind));\r\n    return new GLSLX.Node(kind).appendChild(left).appendChild(right);\r\n  };\r\n\r\n  GLSLX.Node.prototype.doWhileBody = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.doWhileTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.expressionValue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.EXPRESSION);\r\n    assert(this.childCount() == 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forSetup = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind) || this._firstChild.kind == GLSLX.NodeKind.VARIABLES);\r\n    return this._firstChild.isEmptySequence() ? null : this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind) || this._firstChild._nextSibling.kind == GLSLX.NodeKind.VARIABLES);\r\n    return this._firstChild._nextSibling.isEmptySequence() ? null : this._firstChild._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forUpdate = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild._previousSibling.kind));\r\n    return this._lastChild._previousSibling.isEmptySequence() ? null : this._lastChild._previousSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.forBody = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FOR);\r\n    assert(this.childCount() == 4);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.ifTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.IF);\r\n    assert(this.childCount() == 2 || this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.ifTrue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.IF);\r\n    assert(this.childCount() == 2 || this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling.kind));\r\n    return this._firstChild._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.ifFalse = function() {\r\n    assert(this.kind == GLSLX.NodeKind.IF);\r\n    assert(this.childCount() == 2 || this.childCount() == 3);\r\n    assert(this._firstChild._nextSibling._nextSibling == null || GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling._nextSibling.kind));\r\n    return this._firstChild._nextSibling._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.returnValue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.RETURN);\r\n    assert(this.childCount() <= 1);\r\n    assert(this._firstChild == null || GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.variablesType = function() {\r\n    assert(this.kind == GLSLX.NodeKind.VARIABLES);\r\n    assert(this.childCount() >= 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.whileTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.whileBody = function() {\r\n    assert(this.kind == GLSLX.NodeKind.WHILE);\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.callTarget = function() {\r\n    assert(this.kind == GLSLX.NodeKind.CALL);\r\n    assert(this.childCount() >= 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.dotTarget = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DOT);\r\n    assert(this.childCount() == 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.hookTest = function() {\r\n    assert(this.kind == GLSLX.NodeKind.HOOK);\r\n    assert(this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.hookTrue = function() {\r\n    assert(this.kind == GLSLX.NodeKind.HOOK);\r\n    assert(this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind));\r\n    return this._firstChild._nextSibling;\r\n  };\r\n\r\n  GLSLX.Node.prototype.hookFalse = function() {\r\n    assert(this.kind == GLSLX.NodeKind.HOOK);\r\n    assert(this.childCount() == 3);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asString = function() {\r\n    assert(this.kind == GLSLX.NodeKind.DOT);\r\n    assert(this._text != null);\r\n    return this._text;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asBool = function() {\r\n    assert(this.kind == GLSLX.NodeKind.BOOL);\r\n    return !!this._literal;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asFloat = function() {\r\n    assert(this.kind == GLSLX.NodeKind.FLOAT);\r\n    return this._literal;\r\n  };\r\n\r\n  GLSLX.Node.prototype.asInt = function() {\r\n    assert(this.kind == GLSLX.NodeKind.INT);\r\n    return this._literal | 0;\r\n  };\r\n\r\n  GLSLX.Node.prototype.unaryValue = function() {\r\n    assert(GLSLX.in_NodeKind.isUnary(this.kind));\r\n    assert(this.childCount() == 1);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.binaryLeft = function() {\r\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\r\n    return this._firstChild;\r\n  };\r\n\r\n  GLSLX.Node.prototype.binaryRight = function() {\r\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\r\n    assert(this.childCount() == 2);\r\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\r\n    return this._lastChild;\r\n  };\r\n\r\n  GLSLX.Node._createID = function() {\r\n    GLSLX.Node._nextID = GLSLX.Node._nextID + 1 | 0;\r\n    return GLSLX.Node._nextID;\r\n  };\r\n\r\n  GLSLX.Parser = {};\r\n\r\n  GLSLX.Parser.typeParselet = function(type) {\r\n    return function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.unaryPrefix = function(kind) {\r\n    assert(GLSLX.in_NodeKind.isUnaryPrefix(kind));\r\n    return function(context, token, value) {\r\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(token.range, value.range)).withInternalRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.unaryPostfix = function(kind) {\r\n    assert(GLSLX.in_NodeKind.isUnaryPostfix(kind));\r\n    return function(context, value, token) {\r\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(value.range, token.range)).withInternalRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.binaryParselet = function(kind) {\r\n    assert(GLSLX.in_NodeKind.isBinary(kind));\r\n    return function(context, left, token, right) {\r\n      return GLSLX.Node.createBinary(kind, left, right).withRange(GLSLX.Range.span(left.range, right.range)).withInternalRange(token.range);\r\n    };\r\n  };\r\n\r\n  GLSLX.Parser.parseInt = function(text) {\r\n    if (text.length > 1 && in_string.get1(text, 0) == 48 && (in_string.get1(text, 1) != 120 && in_string.get1(text, 1) != 88)) {\r\n      return parseInt(text, 8);\r\n    }\r\n\r\n    return text | 0;\r\n  };\r\n\r\n  GLSLX.Parser.createExpressionParser = function() {\r\n    var pratt = new GLSLX.Pratt();\r\n    var invalidUnaryOperator = function(context, token, value) {\r\n      context.log.syntaxErrorInvalidOperator(token.range);\r\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(token.range, value.range));\r\n    };\r\n    var invalidBinaryOperator = function(context, left, token, right) {\r\n      context.log.syntaxErrorInvalidOperator(token.range);\r\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(left.range, right.range));\r\n    };\r\n    pratt.literal(GLSLX.TokenKind.TRUE, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(true).withType(GLSLX.Type.BOOL).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.FALSE, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(false).withType(GLSLX.Type.BOOL).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.INT_LITERAL, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(GLSLX.Parser.parseInt(token.range.toString())).withType(GLSLX.Type.INT).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.FLOAT_LITERAL, function(context, token) {\r\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(+token.range.toString()).withType(GLSLX.Type.FLOAT).withRange(token.range);\r\n    });\r\n    pratt.literal(GLSLX.TokenKind.BOOL, GLSLX.Parser.typeParselet(GLSLX.Type.BOOL));\r\n    pratt.literal(GLSLX.TokenKind.BVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC2));\r\n    pratt.literal(GLSLX.TokenKind.BVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC3));\r\n    pratt.literal(GLSLX.TokenKind.BVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC4));\r\n    pratt.literal(GLSLX.TokenKind.FLOAT, GLSLX.Parser.typeParselet(GLSLX.Type.FLOAT));\r\n    pratt.literal(GLSLX.TokenKind.INT, GLSLX.Parser.typeParselet(GLSLX.Type.INT));\r\n    pratt.literal(GLSLX.TokenKind.IVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC2));\r\n    pratt.literal(GLSLX.TokenKind.IVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC3));\r\n    pratt.literal(GLSLX.TokenKind.IVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC4));\r\n    pratt.literal(GLSLX.TokenKind.MAT2, GLSLX.Parser.typeParselet(GLSLX.Type.MAT2));\r\n    pratt.literal(GLSLX.TokenKind.MAT3, GLSLX.Parser.typeParselet(GLSLX.Type.MAT3));\r\n    pratt.literal(GLSLX.TokenKind.MAT4, GLSLX.Parser.typeParselet(GLSLX.Type.MAT4));\r\n    pratt.literal(GLSLX.TokenKind.VEC2, GLSLX.Parser.typeParselet(GLSLX.Type.VEC2));\r\n    pratt.literal(GLSLX.TokenKind.VEC3, GLSLX.Parser.typeParselet(GLSLX.Type.VEC3));\r\n    pratt.literal(GLSLX.TokenKind.VEC4, GLSLX.Parser.typeParselet(GLSLX.Type.VEC4));\r\n    pratt.literal(GLSLX.TokenKind.VOID, GLSLX.Parser.typeParselet(GLSLX.Type.VOID));\r\n    pratt.prefix(GLSLX.TokenKind.COMPLEMENT, GLSLX.Precedence.UNARY_PREFIX, invalidUnaryOperator);\r\n    pratt.prefix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_DECREMENT));\r\n    pratt.prefix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_INCREMENT));\r\n    pratt.prefix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NEGATIVE));\r\n    pratt.prefix(GLSLX.TokenKind.NOT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NOT));\r\n    pratt.prefix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.POSITIVE));\r\n    pratt.postfix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_DECREMENT));\r\n    pratt.postfix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_INCREMENT));\r\n    pratt.infix(GLSLX.TokenKind.DIVIDE, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.DIVIDE));\r\n    pratt.infix(GLSLX.TokenKind.EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN));\r\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN_OR_EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.LESS_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN));\r\n    pratt.infix(GLSLX.TokenKind.LESS_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN_OR_EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.SUBTRACT));\r\n    pratt.infix(GLSLX.TokenKind.MULTIPLY, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.MULTIPLY));\r\n    pratt.infix(GLSLX.TokenKind.NOT_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.NOT_EQUAL));\r\n    pratt.infix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ADD));\r\n    pratt.infix(GLSLX.TokenKind.REMAINDER, GLSLX.Precedence.MULTIPLY, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.SHIFT_LEFT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.SHIFT_RIGHT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.LOGICAL_OR, GLSLX.Precedence.LOGICAL_OR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_OR));\r\n    pratt.infix(GLSLX.TokenKind.LOGICAL_XOR, GLSLX.Precedence.LOGICAL_XOR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_XOR));\r\n    pratt.infix(GLSLX.TokenKind.LOGICAL_AND, GLSLX.Precedence.LOGICAL_AND, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_AND));\r\n    pratt.infix(GLSLX.TokenKind.BITWISE_AND, GLSLX.Precedence.BITWISE_AND, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.BITWISE_OR, GLSLX.Precedence.BITWISE_OR, invalidBinaryOperator);\r\n    pratt.infix(GLSLX.TokenKind.BITWISE_XOR, GLSLX.Precedence.BITWISE_XOR, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_ADD, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_ADD));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_AND, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_OR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_XOR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_DIVIDE, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_DIVIDE));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_MULTIPLY, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_MULTIPLY));\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_REMAINDER, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_LEFT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\r\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SUBTRACT, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_SUBTRACT));\r\n\r\n    // Name\r\n    pratt.literal(GLSLX.TokenKind.IDENTIFIER, function(context, token) {\r\n      var name = token.range.toString();\r\n      var symbol = context.scope().find(name);\r\n\r\n      if (symbol == null) {\r\n        context.log.syntaxErrorBadSymbolReference(token.range);\r\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(token.range);\r\n      }\r\n\r\n      // Check extension usage\r\n      if (symbol.requiredExtension != null && context.compilationData.extensionBehavior(symbol.requiredExtension) == GLSLX.ExtensionBehavior.DISABLE) {\r\n        context.log.syntaxErrorDisabledExtension(token.range, name, symbol.requiredExtension);\r\n      }\r\n\r\n      return (symbol.isStruct() ? new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()) : new GLSLX.Node(GLSLX.NodeKind.NAME).withSymbol(symbol)).withRange(token.range);\r\n    });\r\n\r\n    // Sequence\r\n    pratt.infix(GLSLX.TokenKind.COMMA, GLSLX.Precedence.COMMA, function(context, left, token, right) {\r\n      if (left.kind != GLSLX.NodeKind.SEQUENCE) {\r\n        left = new GLSLX.Node(GLSLX.NodeKind.SEQUENCE).appendChild(left).withRange(left.range);\r\n      }\r\n\r\n      left.appendChild(right);\r\n      return left.withRange(context.spanSince(left.range));\r\n    });\r\n\r\n    // Dot\r\n    pratt.parselet(GLSLX.TokenKind.DOT, GLSLX.Precedence.MEMBER).infix = function(context, left) {\r\n      context.next();\r\n      var name = context.current().range;\r\n\r\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Node.createDot(left, name.toString()).withRange(context.spanSince(left.range)).withInternalRange(name);\r\n    };\r\n\r\n    // Group\r\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.LOWEST).prefix = function(context) {\r\n      var token = context.next();\r\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n\r\n      return value.withRange(context.spanSince(token.range));\r\n    };\r\n\r\n    // Call\r\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.UNARY_POSTFIX).infix = function(context, left) {\r\n      var token = context.next();\r\n      var node = GLSLX.Node.createCall(left);\r\n\r\n      if (!GLSLX.Parser.parseCommaSeparatedList(context, node, GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n\r\n      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\r\n    };\r\n\r\n    // Index\r\n    pratt.parselet(GLSLX.TokenKind.LEFT_BRACKET, GLSLX.Precedence.MEMBER).infix = function(context, left) {\r\n      var token = context.next();\r\n\r\n      // The \"[]\" syntax isn't valid but skip over it and recover\r\n      if (context.peek(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        context.unexpectedToken();\r\n        context.next();\r\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(context.spanSince(token.range));\r\n      }\r\n\r\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Node.createBinary(GLSLX.NodeKind.INDEX, left, value).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\r\n    };\r\n\r\n    // Hook\r\n    pratt.parselet(GLSLX.TokenKind.QUESTION, GLSLX.Precedence.ASSIGN).infix = function(context, left) {\r\n      context.next();\r\n      var middle = pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n      if (middle == null || !context.expect(GLSLX.TokenKind.COLON)) {\r\n        return null;\r\n      }\r\n\r\n      var right = pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n      if (right == null) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Node.createHook(left, middle, right).withRange(context.spanSince(left.range));\r\n    };\r\n    return pratt;\r\n  };\r\n\r\n  GLSLX.Parser.parseCommaSeparatedList = function(context, parent, stop) {\r\n    var isFirst = true;\r\n\r\n    while (!context.eat(stop)) {\r\n      if (!isFirst && !context.expect(GLSLX.TokenKind.COMMA)) {\r\n        return false;\r\n      }\r\n\r\n      var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n      if (value == null) {\r\n        return false;\r\n      }\r\n\r\n      parent.appendChild(value);\r\n      isFirst = false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseDoWhile = function(context) {\r\n    var token = context.next();\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\r\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (body == null || !context.expect(GLSLX.TokenKind.WHILE) || !context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (test == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createDoWhile(body, test));\r\n  };\r\n\r\n  GLSLX.Parser.parseExportOrImport = function(context) {\r\n    var token = context.next();\r\n    var old = context.flags;\r\n    context.flags |= token.kind == GLSLX.TokenKind.EXPORT ? GLSLX.SymbolFlags.EXPORTED : GLSLX.SymbolFlags.IMPORTED;\r\n\r\n    // Parse a modifier block\r\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\r\n      var node = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\r\n\r\n      if (!GLSLX.Parser.parseStatements(context, node, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n        return null;\r\n      }\r\n\r\n      context.flags = old;\r\n      return node.withRange(context.spanSince(token.range));\r\n    }\r\n\r\n    // Just parse a single statement\r\n    var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.GLOBAL);\r\n\r\n    if (statement == null) {\r\n      return null;\r\n    }\r\n\r\n    context.flags = old;\r\n    return statement;\r\n  };\r\n\r\n  GLSLX.Parser.parseExtension = function(context) {\r\n    var token = context.next();\r\n    var range = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n      return null;\r\n    }\r\n\r\n    var name = range.toString();\r\n\r\n    // Parse an extension block (a non-standard addition)\r\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\r\n      if (!(name in context.compilationData.currentExtensions)) {\r\n        // Silence warnings about this name\r\n        context.compilationData.currentExtensions[name] = GLSLX.ExtensionBehavior.DEFAULT;\r\n      }\r\n\r\n      var block = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\r\n\r\n      if (!GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n        return null;\r\n      }\r\n\r\n      for (var child = block.firstChild(); child != null; child = child.nextSibling()) {\r\n        if (child.kind == GLSLX.NodeKind.VARIABLES) {\r\n          for (var variable = child.variablesType().nextSibling(); variable != null; variable = variable.nextSibling()) {\r\n            variable.symbol.requiredExtension = name;\r\n          }\r\n        }\r\n\r\n        else if (child.symbol != null) {\r\n          child.symbol.requiredExtension = name;\r\n        }\r\n      }\r\n\r\n      return block.withRange(context.spanSince(token.range));\r\n    }\r\n\r\n    // Warn about typos\r\n    if (!(name in GLSLX.Parser._knownWebGLExtensions) && !(name in context.compilationData.currentExtensions)) {\r\n      context.log.syntaxWarningUnknownExtension(range, name);\r\n    }\r\n\r\n    // Parse a regular extension pragma\r\n    if (!context.expect(GLSLX.TokenKind.COLON)) {\r\n      return null;\r\n    }\r\n\r\n    var text = context.current().range.toString();\r\n\r\n    if (!(text in GLSLX.Parser._extensionBehaviors)) {\r\n      context.unexpectedToken();\r\n      return null;\r\n    }\r\n\r\n    context.next();\r\n\r\n    // Activate or deactivate the extension\r\n    var behavior = in_StringMap.get1(GLSLX.Parser._extensionBehaviors, text);\r\n    context.compilationData.currentExtensions[name] = behavior;\r\n    return new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(behavior).withRange(context.spanSince(token.range)).withInternalRange(range);\r\n  };\r\n\r\n  GLSLX.Parser.parseFor = function(context) {\r\n    var token = context.next();\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    // Setup\r\n    var setup = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\r\n      // Check for a type\r\n      var flags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.LOCAL);\r\n      var type = null;\r\n\r\n      if (flags != 0) {\r\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n        if (type == null) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      else {\r\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\r\n      }\r\n\r\n      // Try to parse a variable\r\n      if (type != null) {\r\n        setup = GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.AVOID_FUNCTIONS);\r\n\r\n        if (setup == null) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      else {\r\n        setup = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n        if (setup == null) {\r\n          return null;\r\n        }\r\n\r\n        if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Test\r\n    var test = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\r\n      test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (test == null) {\r\n        return null;\r\n      }\r\n\r\n      if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Update\r\n    var update = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      update = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (update == null) {\r\n        return null;\r\n      }\r\n\r\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Body\r\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (body == null) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return GLSLX.Node.createFor(setup, test, update, body).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseIf = function(context) {\r\n    var token = context.next();\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (test == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var yes = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (yes == null) {\r\n      return null;\r\n    }\r\n\r\n    var no = null;\r\n\r\n    if (context.eat(GLSLX.TokenKind.ELSE)) {\r\n      no = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n      if (no == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return GLSLX.Node.createIf(test, yes, no).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseVersion = function(context) {\r\n    var token = context.next();\r\n    var range = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.INT_LITERAL)) {\r\n      return null;\r\n    }\r\n\r\n    return new GLSLX.Node(GLSLX.NodeKind.VERSION).withInt(range.toString() | 0).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseWhile = function(context) {\r\n    var token = context.next();\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (test == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      return null;\r\n    }\r\n\r\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\r\n\r\n    if (body == null) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return GLSLX.Node.createWhile(test, body).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseReturn = function(context) {\r\n    var token = context.next();\r\n    var value = null;\r\n\r\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\r\n      value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n\r\n      context.expect(GLSLX.TokenKind.SEMICOLON);\r\n    }\r\n\r\n    return GLSLX.Node.createReturn(value).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parsePrecision = function(context) {\r\n    var token = context.next();\r\n    var flag = 0;\r\n\r\n    switch (context.current().kind) {\r\n      case GLSLX.TokenKind.LOWP: {\r\n        flag = GLSLX.SymbolFlags.LOWP;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MEDIUMP: {\r\n        flag = GLSLX.SymbolFlags.MEDIUMP;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.HIGHP: {\r\n        flag = GLSLX.SymbolFlags.HIGHP;\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        context.unexpectedToken();\r\n        return null;\r\n      }\r\n    }\r\n\r\n    context.next();\r\n    var type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n    if (type == null) {\r\n      return null;\r\n    }\r\n\r\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createPrecision(flag, type));\r\n  };\r\n\r\n  GLSLX.Parser.parseStruct = function(context, flags) {\r\n    var name = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n      return null;\r\n    }\r\n\r\n    var symbol = new GLSLX.StructSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.STRUCT, context.scope()));\r\n    symbol.flags |= context.flags | flags;\r\n\r\n    if (!GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol)) {\r\n      return null;\r\n    }\r\n\r\n    var range = context.current().range;\r\n    var block = new GLSLX.Node(GLSLX.NodeKind.STRUCT_BLOCK);\r\n    var variables = null;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE)) {\r\n      return null;\r\n    }\r\n\r\n    context.pushScope(symbol.scope);\r\n\r\n    while (!context.peek(GLSLX.TokenKind.RIGHT_BRACE) && !context.peek(GLSLX.TokenKind.END_OF_FILE)) {\r\n      var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.STRUCT);\r\n\r\n      if (statement == null) {\r\n        return null;\r\n      }\r\n\r\n      if (statement.kind != GLSLX.NodeKind.VARIABLES) {\r\n        context.log.syntaxErrorInsideStruct(statement.range);\r\n        continue;\r\n      }\r\n\r\n      block.appendChild(statement);\r\n\r\n      for (var child = statement.variablesType().nextSibling(); child != null; child = child.nextSibling()) {\r\n        var variable = child.symbol.asVariable();\r\n        symbol.variables.push(variable);\r\n\r\n        if (variable.value != null) {\r\n          context.log.syntaxErrorStructVariableInitializer(variable.value.range);\r\n        }\r\n      }\r\n    }\r\n\r\n    context.popScope();\r\n\r\n    if (!context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n      return null;\r\n    }\r\n\r\n    block.withRange(context.spanSince(range));\r\n\r\n    // Parse weird struct-variable hybrid things\r\n    //\r\n    //   struct S { int x; } y, z[2];\r\n    //\r\n    if (context.peek(GLSLX.TokenKind.IDENTIFIER)) {\r\n      variables = GLSLX.Parser.parseVariables(0, new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()), context.next().range, context);\r\n\r\n      if (variables == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    else {\r\n      context.expect(GLSLX.TokenKind.SEMICOLON);\r\n    }\r\n\r\n    return GLSLX.Node.createStruct(symbol, block, variables);\r\n  };\r\n\r\n  GLSLX.Parser.checkForLoopAndSemicolon = function(context, range, node) {\r\n    var found = false;\r\n\r\n    for (var scope = context.scope(); scope != null; scope = scope.parent) {\r\n      if (scope.kind == GLSLX.ScopeKind.LOOP) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!found) {\r\n      context.log.syntaxErrorOutsideLoop(range);\r\n    }\r\n\r\n    return GLSLX.Parser.checkForSemicolon(context, range, node);\r\n  };\r\n\r\n  GLSLX.Parser.checkForSemicolon = function(context, range, node) {\r\n    context.expect(GLSLX.TokenKind.SEMICOLON);\r\n    return node.withRange(context.spanSince(range));\r\n  };\r\n\r\n  GLSLX.Parser.parseAfterType = function(context, range, flags, type, allow) {\r\n    var name = context.current().range;\r\n\r\n    if (flags == 0 && !context.peek(GLSLX.TokenKind.IDENTIFIER)) {\r\n      var value = GLSLX.Parser.pratt.resume(context, GLSLX.Precedence.LOWEST, type);\r\n\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n\r\n      return GLSLX.Parser.checkForSemicolon(context, range, GLSLX.Node.createExpression(value));\r\n    }\r\n\r\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n      return null;\r\n    }\r\n\r\n    if (context.eat(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\r\n      return GLSLX.Parser.parseFunction(flags, type, name, context);\r\n    }\r\n\r\n    var variables = GLSLX.Parser.parseVariables(flags, type, name, context);\r\n\r\n    if (variables == null) {\r\n      return null;\r\n    }\r\n\r\n    return variables.withRange(context.spanSince(range));\r\n  };\r\n\r\n  GLSLX.Parser.parseStatement = function(context, mode) {\r\n    var token = context.current();\r\n\r\n    switch (token.kind) {\r\n      case GLSLX.TokenKind.BREAK: {\r\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.BREAK));\r\n      }\r\n\r\n      case GLSLX.TokenKind.CONTINUE: {\r\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.CONTINUE));\r\n      }\r\n\r\n      case GLSLX.TokenKind.DISCARD: {\r\n        return GLSLX.Parser.checkForSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.DISCARD));\r\n      }\r\n\r\n      case GLSLX.TokenKind.DO: {\r\n        return GLSLX.Parser.parseDoWhile(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.EXPORT:\r\n      case GLSLX.TokenKind.IMPORT: {\r\n        return GLSLX.Parser.parseExportOrImport(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.EXTENSION: {\r\n        return GLSLX.Parser.parseExtension(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.FOR: {\r\n        return GLSLX.Parser.parseFor(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.IF: {\r\n        return GLSLX.Parser.parseIf(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.LEFT_BRACE: {\r\n        return GLSLX.Parser.parseBlock(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.PRECISION: {\r\n        return GLSLX.Parser.parsePrecision(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.RETURN: {\r\n        return GLSLX.Parser.parseReturn(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.SEMICOLON: {\r\n        return new GLSLX.Node(GLSLX.NodeKind.BLOCK).withRange(context.next().range);\r\n      }\r\n\r\n      case GLSLX.TokenKind.VERSION: {\r\n        return GLSLX.Parser.parseVersion(context);\r\n      }\r\n\r\n      case GLSLX.TokenKind.WHILE: {\r\n        return GLSLX.Parser.parseWhile(context);\r\n      }\r\n    }\r\n\r\n    // Try to parse a variable or function\r\n    var flags = GLSLX.Parser.parseFlags(context, mode);\r\n    var type = null;\r\n\r\n    if (context.eat(GLSLX.TokenKind.STRUCT)) {\r\n      var struct = GLSLX.Parser.parseStruct(context, flags);\r\n\r\n      if (struct == null) {\r\n        return null;\r\n      }\r\n\r\n      return struct.withRange(context.spanSince(token.range));\r\n    }\r\n\r\n    if (flags != 0) {\r\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n      if (type == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    else {\r\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\r\n    }\r\n\r\n    if (type != null) {\r\n      return GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.ALLOW_FUNCTIONS);\r\n    }\r\n\r\n    // Parse an expression\r\n    var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n    if (value == null) {\r\n      return null;\r\n    }\r\n\r\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createExpression(value));\r\n  };\r\n\r\n  GLSLX.Parser.checkStatementLocation = function(context, node) {\r\n    if (node.kind == GLSLX.NodeKind.VARIABLES || node.kind == GLSLX.NodeKind.STRUCT) {\r\n      return;\r\n    }\r\n\r\n    var isOutsideFunction = context.scope().kind == GLSLX.ScopeKind.GLOBAL || context.scope().kind == GLSLX.ScopeKind.STRUCT;\r\n    var shouldBeOutsideFunction = node.kind == GLSLX.NodeKind.EXTENSION || node.kind == GLSLX.NodeKind.FUNCTION || node.kind == GLSLX.NodeKind.PRECISION || node.kind == GLSLX.NodeKind.VERSION;\r\n\r\n    if (shouldBeOutsideFunction && !isOutsideFunction) {\r\n      context.log.syntaxErrorInsideFunction(node.range);\r\n    }\r\n\r\n    else if (!shouldBeOutsideFunction && isOutsideFunction) {\r\n      context.log.syntaxErrorOutsideFunction(node.range);\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.parseInclude = function(context, parent) {\r\n    // See if there is a string literal\r\n    var range = context.current().range;\r\n\r\n    if (!context.expect(GLSLX.TokenKind.STRING_LITERAL)) {\r\n      return false;\r\n    }\r\n\r\n    // Decode the escapes\r\n    var path = null;\r\n\r\n    try {\r\n      path = JSON.parse(range.toString());\r\n    }\r\n\r\n    catch (e) {\r\n      context.log.syntaxErrorInvalidString(range);\r\n      return false;\r\n    }\r\n\r\n    // Must have access to the file system\r\n    var fileAccess = context.compilationData.fileAccess;\r\n\r\n    if (fileAccess == null) {\r\n      context.log.semanticErrorIncludeWithoutFileAccess(range);\r\n      return false;\r\n    }\r\n\r\n    // Must be able to read the file\r\n    var source = fileAccess(path, range.source.name);\r\n\r\n    if (source == null) {\r\n      context.log.semanticErrorIncludeBadPath(range, path);\r\n      return false;\r\n    }\r\n\r\n    // Parse the file and insert it into the parent\r\n    var tokens = GLSLX.Tokenizer.tokenize(context.log, source);\r\n    var nestedContext = new GLSLX.ParserContext(context.log, tokens, context.compilationData, context.resolver);\r\n    nestedContext.pushScope(context.scope());\r\n\r\n    if (!GLSLX.Parser.parseStatements(nestedContext, parent, GLSLX.VariableKind.GLOBAL) || !nestedContext.expect(GLSLX.TokenKind.END_OF_FILE)) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseBlock = function(context) {\r\n    var token = context.current();\r\n    var block = new GLSLX.Node(GLSLX.NodeKind.BLOCK);\r\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOCAL, context.scope()));\r\n\r\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE) || !GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.LOCAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n      return null;\r\n    }\r\n\r\n    context.popScope();\r\n    return block.withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseFlags = function(context, mode) {\r\n    var flags = 0;\r\n\r\n    while (true) {\r\n      var kind = context.current().kind;\r\n\r\n      switch (kind) {\r\n        case GLSLX.TokenKind.ATTRIBUTE: {\r\n          flags |= GLSLX.SymbolFlags.ATTRIBUTE;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.CONST: {\r\n          flags |= GLSLX.SymbolFlags.CONST;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.HIGHP: {\r\n          flags |= GLSLX.SymbolFlags.HIGHP;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.IN: {\r\n          flags |= GLSLX.SymbolFlags.IN;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.INOUT: {\r\n          flags |= GLSLX.SymbolFlags.INOUT;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.LOWP: {\r\n          flags |= GLSLX.SymbolFlags.LOWP;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.MEDIUMP: {\r\n          flags |= GLSLX.SymbolFlags.MEDIUMP;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.OUT: {\r\n          flags |= GLSLX.SymbolFlags.OUT;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.UNIFORM: {\r\n          flags |= GLSLX.SymbolFlags.UNIFORM;\r\n          break;\r\n        }\r\n\r\n        case GLSLX.TokenKind.VARYING: {\r\n          flags |= GLSLX.SymbolFlags.VARYING;\r\n          break;\r\n        }\r\n\r\n        default: {\r\n          return flags;\r\n        }\r\n      }\r\n\r\n      if (mode == GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.ATTRIBUTE || kind == GLSLX.TokenKind.UNIFORM || kind == GLSLX.TokenKind.VARYING) || mode == GLSLX.VariableKind.STRUCT && kind != GLSLX.TokenKind.LOWP && kind != GLSLX.TokenKind.MEDIUMP && kind != GLSLX.TokenKind.HIGHP || mode != GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.IN || kind == GLSLX.TokenKind.OUT || kind == GLSLX.TokenKind.INOUT)) {\r\n        context.log.syntaxErrorBadQualifier(context.current().range);\r\n      }\r\n\r\n      context.next();\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.parseType = function(context, mode) {\r\n    var token = context.current();\r\n    var type = null;\r\n\r\n    switch (token.kind) {\r\n      case GLSLX.TokenKind.BOOL: {\r\n        type = GLSLX.Type.BOOL;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.BVEC2: {\r\n        type = GLSLX.Type.BVEC2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.BVEC3: {\r\n        type = GLSLX.Type.BVEC3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.BVEC4: {\r\n        type = GLSLX.Type.BVEC4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.FLOAT: {\r\n        type = GLSLX.Type.FLOAT;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.INT: {\r\n        type = GLSLX.Type.INT;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IVEC2: {\r\n        type = GLSLX.Type.IVEC2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IVEC3: {\r\n        type = GLSLX.Type.IVEC3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IVEC4: {\r\n        type = GLSLX.Type.IVEC4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MAT2: {\r\n        type = GLSLX.Type.MAT2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MAT3: {\r\n        type = GLSLX.Type.MAT3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.MAT4: {\r\n        type = GLSLX.Type.MAT4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.SAMPLER2D: {\r\n        type = GLSLX.Type.SAMPLER2D;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.SAMPLERCUBE: {\r\n        type = GLSLX.Type.SAMPLERCUBE;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VEC2: {\r\n        type = GLSLX.Type.VEC2;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VEC3: {\r\n        type = GLSLX.Type.VEC3;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VEC4: {\r\n        type = GLSLX.Type.VEC4;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.VOID: {\r\n        type = GLSLX.Type.VOID;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.TokenKind.IDENTIFIER: {\r\n        var symbol = context.scope().find(token.range.toString());\r\n\r\n        if (symbol == null || !symbol.isStruct()) {\r\n          if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\r\n            context.unexpectedToken();\r\n          }\r\n\r\n          return null;\r\n        }\r\n\r\n        type = symbol.resolvedType();\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\r\n          context.unexpectedToken();\r\n        }\r\n\r\n        return null;\r\n      }\r\n    }\r\n\r\n    context.next();\r\n    return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(context.spanSince(token.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseFunction = function(flags, type, name, context) {\r\n    var originalScope = context.scope();\r\n    var $function = new GLSLX.FunctionSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.FUNCTION, originalScope));\r\n    $function.flags |= context.flags | flags | ($function.name == 'main' ? GLSLX.SymbolFlags.EXPORTED : 0);\r\n    $function.returnType = type;\r\n    context.pushScope($function.scope);\r\n\r\n    // Takes no arguments\r\n    if (context.eat(GLSLX.TokenKind.VOID)) {\r\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Takes arguments\r\n    else if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n      while (true) {\r\n        // Parse leading flags\r\n        var argumentFlags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.ARGUMENT);\r\n\r\n        // Parse the type\r\n        var argumentType = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\r\n\r\n        if (argumentType == null) {\r\n          return null;\r\n        }\r\n\r\n        // Parse the identifier\r\n        var argumentName = context.current().range;\r\n\r\n        if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n          return null;\r\n        }\r\n\r\n        // Create the argument\r\n        var argument = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), argumentName, argumentName.toString(), context.scope(), GLSLX.VariableKind.ARGUMENT);\r\n        argument.flags |= argumentFlags;\r\n        argument.type = argumentType;\r\n        $function.$arguments.push(argument);\r\n        GLSLX.Parser.tryToDefineUniquelyInScope(context, argument);\r\n\r\n        // Array size\r\n        if (!GLSLX.Parser.parseArraySize(context, argument)) {\r\n          return null;\r\n        }\r\n\r\n        // Parse another argument?\r\n        if (!context.eat(GLSLX.TokenKind.COMMA)) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var previous = in_StringMap.get(originalScope.symbols, name.toString(), null);\r\n    var hasBlock = !context.eat(GLSLX.TokenKind.SEMICOLON);\r\n\r\n    // Merge adjacent function symbols to support overloading\r\n    if (previous == null) {\r\n      originalScope.define($function);\r\n    }\r\n\r\n    else if (previous.isFunction()) {\r\n      for (var link = previous.asFunction(); link != null; link = link.previousOverload) {\r\n        if (!link.hasSameArgumentTypesAs($function)) {\r\n          continue;\r\n        }\r\n\r\n        // Overloading by return type is not allowed\r\n        if (link.returnType.resolvedType != $function.returnType.resolvedType) {\r\n          context.log.syntaxErrorDifferentReturnType($function.returnType.range, $function.name, $function.returnType.resolvedType, link.returnType.resolvedType, link.returnType.range);\r\n        }\r\n\r\n        // Defining a function more than once is not allowed\r\n        else if (link.block != null || !hasBlock) {\r\n          context.log.syntaxErrorDuplicateSymbolDefinition($function.range, link.range);\r\n        }\r\n\r\n        // Merge the function with its forward declaration\r\n        else {\r\n          assert(link.sibling == null);\r\n          assert($function.sibling == null);\r\n          link.sibling = $function;\r\n          $function.sibling = link;\r\n          $function.flags |= link.flags;\r\n          link.flags = $function.flags;\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      // Use a singly-linked list to store the function overloads\r\n      $function.previousOverload = previous.asFunction();\r\n      originalScope.redefine($function);\r\n    }\r\n\r\n    else {\r\n      context.log.syntaxErrorDuplicateSymbolDefinition(name, previous.range);\r\n      return null;\r\n    }\r\n\r\n    if (hasBlock) {\r\n      var old = context.flags;\r\n      context.flags &= ~(GLSLX.SymbolFlags.EXPORTED | GLSLX.SymbolFlags.IMPORTED);\r\n      $function.block = GLSLX.Parser.parseBlock(context);\r\n      context.flags &= old;\r\n\r\n      if ($function.block == null) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    context.popScope();\r\n    return new GLSLX.Node(GLSLX.NodeKind.FUNCTION).withSymbol($function).withRange(context.spanSince(type.range));\r\n  };\r\n\r\n  GLSLX.Parser.parseArraySize = function(context, variable) {\r\n    var token = context.current();\r\n\r\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACKET)) {\r\n      // The \"[]\" syntax isn't valid but skip over it and recover\r\n      if (context.eat(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        context.log.syntaxErrorMissingArraySize(context.spanSince(token.range));\r\n        return true;\r\n      }\r\n\r\n      variable.arrayCount = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\r\n\r\n      if (variable.arrayCount == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n        return false;\r\n      }\r\n\r\n      // The array size must be resolved immediately\r\n      var count = 0;\r\n      context.resolver.resolveNode(variable.arrayCount);\r\n      context.resolver.checkConversion(variable.arrayCount, GLSLX.Type.INT);\r\n\r\n      if (variable.arrayCount.resolvedType != GLSLX.Type.ERROR) {\r\n        var folded = GLSLX.Folder.fold(variable.arrayCount);\r\n\r\n        if (folded == null) {\r\n          context.log.syntaxErrorConstantRequired(variable.arrayCount.range);\r\n        }\r\n\r\n        else if (folded.kind == GLSLX.NodeKind.INT) {\r\n          var value = folded.asInt();\r\n\r\n          if (value < 1) {\r\n            context.log.syntaxErrorInvalidArraySize(variable.arrayCount.range, value);\r\n          }\r\n\r\n          else {\r\n            count = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Multidimensional arrays are not supported\r\n      while (context.peek(GLSLX.TokenKind.LEFT_BRACKET)) {\r\n        token = context.next();\r\n\r\n        if (!context.peek(GLSLX.TokenKind.RIGHT_BRACKET) && GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST) == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\r\n          return false;\r\n        }\r\n\r\n        context.log.syntaxErrorMultidimensionalArray(context.spanSince(token.range));\r\n      }\r\n\r\n      variable.type = new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(variable.type.resolvedType.arrayType(count)).withRange(variable.type.range);\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseVariables = function(flags, type, name, context) {\r\n    var variables = GLSLX.Node.createVariables(context.flags | flags, type);\r\n\r\n    while (true) {\r\n      var symbol = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), name, name.toString(), context.scope(), context.scope().kind == GLSLX.ScopeKind.GLOBAL ? GLSLX.VariableKind.GLOBAL : context.scope().kind == GLSLX.ScopeKind.STRUCT ? GLSLX.VariableKind.STRUCT : GLSLX.VariableKind.LOCAL);\r\n      symbol.flags |= context.flags | flags;\r\n      symbol.type = type;\r\n\r\n      // Array size\r\n      if (!GLSLX.Parser.parseArraySize(context, symbol)) {\r\n        return null;\r\n      }\r\n\r\n      // Initial value\r\n      var assign = context.current().range;\r\n\r\n      if (context.eat(GLSLX.TokenKind.ASSIGN)) {\r\n        symbol.value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\r\n\r\n        if (symbol.value == null) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      else {\r\n        assign = null;\r\n      }\r\n\r\n      // Constants must be resolved immediately\r\n      var variable = new GLSLX.Node(GLSLX.NodeKind.VARIABLE).withSymbol(symbol).withRange(context.spanSince(symbol.range)).withInternalRange(assign);\r\n\r\n      if (symbol.isConst()) {\r\n        context.resolver.resolveNode(variable);\r\n      }\r\n\r\n      variables.appendChild(variable);\r\n      GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol);\r\n\r\n      // Are there more variables in this statement?\r\n      if (!context.eat(GLSLX.TokenKind.COMMA)) {\r\n        context.expect(GLSLX.TokenKind.SEMICOLON);\r\n        return variables;\r\n      }\r\n\r\n      name = context.current().range;\r\n\r\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.tryToDefineUniquelyInScope = function(context, symbol) {\r\n    var previous = in_StringMap.get(context.scope().symbols, symbol.name, null);\r\n\r\n    if (previous != null) {\r\n      context.log.syntaxErrorDuplicateSymbolDefinition(symbol.range, previous.range);\r\n      return false;\r\n    }\r\n\r\n    context.scope().define(symbol);\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parseStatements = function(context, parent, mode) {\r\n    while (!context.peek(GLSLX.TokenKind.END_OF_FILE) && !context.peek(GLSLX.TokenKind.RIGHT_BRACE)) {\r\n      if (context.eat(GLSLX.TokenKind.INCLUDE)) {\r\n        if (!GLSLX.Parser.parseInclude(context, parent)) {\r\n          return false;\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      var statement = GLSLX.Parser.parseStatement(context, mode);\r\n\r\n      if (statement == null) {\r\n        return false;\r\n      }\r\n\r\n      // Extension blocks are temporary and don't exist in the parsed result\r\n      if (statement.kind == GLSLX.NodeKind.MODIFIER_BLOCK) {\r\n        while (statement.hasChildren()) {\r\n          var child = statement.firstChild().remove();\r\n          GLSLX.Parser.checkStatementLocation(context, child);\r\n          parent.appendChild(child);\r\n        }\r\n      }\r\n\r\n      else {\r\n        GLSLX.Parser.checkStatementLocation(context, statement);\r\n        parent.appendChild(statement);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.Parser.parse = function(log, tokens, global, data, scope, resolver) {\r\n    if (GLSLX.Parser.pratt == null) {\r\n      GLSLX.Parser.pratt = GLSLX.Parser.createExpressionParser();\r\n    }\r\n\r\n    var context = new GLSLX.ParserContext(log, tokens, data, resolver);\r\n    context.pushScope(scope);\r\n\r\n    if (GLSLX.Parser.parseStatements(context, global, GLSLX.VariableKind.GLOBAL)) {\r\n      context.expect(GLSLX.TokenKind.END_OF_FILE);\r\n    }\r\n  };\r\n\r\n  GLSLX.Parser.Allow = {\r\n    AVOID_FUNCTIONS: 0,\r\n    ALLOW_FUNCTIONS: 1\r\n  };\r\n\r\n  GLSLX.Parser.ParseTypeMode = {\r\n    IGNORE_ERRORS: 0,\r\n    REPORT_ERRORS: 1\r\n  };\r\n\r\n  // The same operator precedence as C for the most part\r\n  GLSLX.Precedence = {\r\n    LOWEST: 0,\r\n    COMMA: 1,\r\n    ASSIGN: 2,\r\n    LOGICAL_OR: 3,\r\n    LOGICAL_XOR: 4,\r\n    LOGICAL_AND: 5,\r\n    BITWISE_OR: 6,\r\n    BITWISE_XOR: 7,\r\n    BITWISE_AND: 8,\r\n    COMPARE: 10,\r\n    SHIFT: 11,\r\n    ADD: 12,\r\n    MULTIPLY: 13,\r\n    UNARY_PREFIX: 14,\r\n    UNARY_POSTFIX: 15,\r\n    MEMBER: 16\r\n  };\r\n\r\n  GLSLX.ParserContext = function(log, _tokens, compilationData, resolver) {\r\n    this.log = log;\r\n    this._tokens = _tokens;\r\n    this.compilationData = compilationData;\r\n    this.resolver = resolver;\r\n    this.flags = 0;\r\n    this._index = 0;\r\n    this._scope = null;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.current = function() {\r\n    return in_List.get(this._tokens, this._index);\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.next = function() {\r\n    var token = this.current();\r\n\r\n    if ((this._index + 1 | 0) < this._tokens.length) {\r\n      this._index = this._index + 1 | 0;\r\n    }\r\n\r\n    return token;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.spanSince = function(range) {\r\n    var previous = in_List.get(this._tokens, this._index > 0 ? this._index - 1 | 0 : 0);\r\n    return previous.range.end < range.start ? range : GLSLX.Range.span(range, previous.range);\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.peek = function(kind) {\r\n    return this.current().kind == kind;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.eat = function(kind) {\r\n    if (this.peek(kind)) {\r\n      this.next();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.expect = function(kind) {\r\n    if (this.eat(kind)) {\r\n      return true;\r\n    }\r\n\r\n    var token = this.current();\r\n    var range = token.range;\r\n    var previous = (this._index > 0 ? in_List.get(this._tokens, this._index - 1 | 0) : token).range;\r\n\r\n    // Put errors about missing semicolons and about tokens on the next line\r\n    // after the previous token instead of at the next token\r\n    if (kind == GLSLX.TokenKind.SEMICOLON || previous.lineColumn().line != range.lineColumn().line) {\r\n      this.log.syntaxErrorExpectedToken1(previous.rangeAtEnd(), kind);\r\n    }\r\n\r\n    else {\r\n      this.log.syntaxErrorExpectedToken2(range, token.kind, kind);\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.unexpectedToken = function() {\r\n    this.log.syntaxErrorUnexpectedToken(this.current());\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.scope = function() {\r\n    return this._scope;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.pushScope = function(newScope) {\r\n    assert(newScope.parent == this._scope);\r\n    this._scope = newScope;\r\n  };\r\n\r\n  GLSLX.ParserContext.prototype.popScope = function() {\r\n    assert(this._scope != null);\r\n    this._scope = this._scope.parent;\r\n  };\r\n\r\n  GLSLX.Parselet = function(precedence) {\r\n    this.precedence = precedence;\r\n    this.prefix = null;\r\n    this.infix = null;\r\n  };\r\n\r\n  // A Pratt parser is a parser that associates up to two operations per token,\r\n  // each with its own precedence. Pratt parsers excel at parsing expression\r\n  // trees with deeply nested precedence levels. For an excellent writeup, see:\r\n  //\r\n  //   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\r\n  //\r\n  GLSLX.Pratt = function() {\r\n    this._table = {};\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.parselet = function(kind, precedence) {\r\n    var parselet = in_IntMap.get(this._table, kind, null);\r\n\r\n    if (parselet == null) {\r\n      var created = new GLSLX.Parselet(precedence);\r\n      parselet = created;\r\n      this._table[kind] = created;\r\n    }\r\n\r\n    else if (precedence > parselet.precedence) {\r\n      parselet.precedence = precedence;\r\n    }\r\n\r\n    return parselet;\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.parse = function(context, precedence) {\r\n    var token = context.current();\r\n    var parselet = in_IntMap.get(this._table, token.kind, null);\r\n\r\n    if (parselet == null || parselet.prefix == null) {\r\n      context.unexpectedToken();\r\n      return null;\r\n    }\r\n\r\n    var node = this.resume(context, precedence, parselet.prefix(context));\r\n\r\n    // Parselets must set the range of every node\r\n    assert(node == null || node.range != null);\r\n    return node;\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.resume = function(context, precedence, left) {\r\n    while (left != null) {\r\n      var kind = context.current().kind;\r\n      var parselet = in_IntMap.get(this._table, kind, null);\r\n\r\n      if (parselet == null || parselet.infix == null || parselet.precedence <= precedence) {\r\n        break;\r\n      }\r\n\r\n      left = parselet.infix(context, left);\r\n\r\n      // Parselets must set the range of every node\r\n      assert(left == null || left.range != null);\r\n    }\r\n\r\n    return left;\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.literal = function(kind, callback) {\r\n    this.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\r\n      return callback(context, context.next());\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.prefix = function(kind, precedence, callback) {\r\n    var self = this;\r\n    self.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\r\n      var token = context.next();\r\n      var value = self.parse(context, precedence);\r\n      return value != null ? callback(context, token, value) : null;\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.postfix = function(kind, precedence, callback) {\r\n    this.parselet(kind, precedence).infix = function(context, left) {\r\n      return callback(context, left, context.next());\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.infix = function(kind, precedence, callback) {\r\n    var self = this;\r\n    self.parselet(kind, precedence).infix = function(context, left) {\r\n      var token = context.next();\r\n      var right = self.parse(context, precedence);\r\n      return right != null ? callback(context, left, token, right) : null;\r\n    };\r\n  };\r\n\r\n  GLSLX.Pratt.prototype.infixRight = function(kind, precedence, callback) {\r\n    var self = this;\r\n    self.parselet(kind, precedence).infix = function(context, left) {\r\n      var token = context.next();\r\n\r\n      // Subtract 1 for right-associativity\r\n      var right = self.parse(context, precedence - 1 | 0);\r\n      return right != null ? callback(context, left, token, right) : null;\r\n    };\r\n  };\r\n\r\n  GLSLX.Range = function(source, start, end) {\r\n    this.source = source;\r\n    this.start = start;\r\n    this.end = end;\r\n  };\r\n\r\n  GLSLX.Range.prototype.toString = function() {\r\n    return in_string.slice2(this.source.contents, this.start, this.end);\r\n  };\r\n\r\n  GLSLX.Range.prototype.slice = function(offsetStart, offsetEnd) {\r\n    assert(offsetStart >= 0 && offsetStart <= offsetEnd && offsetEnd <= (this.end - this.start | 0));\r\n    return new GLSLX.Range(this.source, this.start + offsetStart | 0, this.start + offsetEnd | 0);\r\n  };\r\n\r\n  GLSLX.Range.prototype.lineColumn = function() {\r\n    return this.source.indexToLineColumn(this.start);\r\n  };\r\n\r\n  GLSLX.Range.prototype.rangeAtEnd = function() {\r\n    return new GLSLX.Range(this.source, this.end, this.end);\r\n  };\r\n\r\n  GLSLX.Range.span = function(start, end) {\r\n    assert(start.source == end.source);\r\n    assert(start.start <= end.end);\r\n    return new GLSLX.Range(start.source, start.start, end.end);\r\n  };\r\n\r\n  GLSLX.Resolver = function(_log, _data) {\r\n    this._log = _log;\r\n    this._data = _data;\r\n    this._controlFlow = new GLSLX.ControlFlowAnalyzer();\r\n    this._versions = [];\r\n    this._generatedExtensions = Object.create(null);\r\n    this._returnType = null;\r\n  };\r\n\r\n  GLSLX.Resolver.prototype.resolveGlobal = function(global) {\r\n    this.resolveNode(global);\r\n\r\n    // Remove all version statements\r\n    for (var i = 0, list = this._versions, count = list.length; i < count; i = i + 1 | 0) {\r\n      var version = in_List.get(list, i);\r\n      version.remove();\r\n    }\r\n\r\n    // Re-insert the first version statement\r\n    var first = global.firstChild();\r\n\r\n    if (!(this._versions.length == 0)) {\r\n      global.insertChildBefore(first, in_List.first(this._versions));\r\n    }\r\n\r\n    // Insert all automatically generated extensions\r\n    for (var i1 = 0, list1 = in_StringMap.values(this._generatedExtensions), count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n      var extension = in_List.get(list1, i1);\r\n      global.insertChildBefore(first, extension);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype.resolveNode = function(node) {\r\n    if (node.resolvedType != null) {\r\n      return;\r\n    }\r\n\r\n    node.resolvedType = GLSLX.Type.ERROR;\r\n    var kind = node.kind;\r\n\r\n    switch (kind) {\r\n      case GLSLX.NodeKind.GLOBAL:\r\n      case GLSLX.NodeKind.STRUCT_BLOCK: {\r\n        this._resolveChildren(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.VARIABLE: {\r\n        var symbol = node.symbol.asVariable();\r\n        this.resolveNode(symbol.type);\r\n\r\n        // Variables must have a type\r\n        var type = symbol.type.resolvedType;\r\n\r\n        if (type == GLSLX.Type.VOID) {\r\n          this._log.semanticErrorBadVariableType(symbol.type.range, type);\r\n          type = GLSLX.Type.ERROR;\r\n        }\r\n\r\n        // Array size\r\n        if (symbol.arrayCount != null) {\r\n          this._resolveAsExpression(symbol.arrayCount);\r\n          this.checkConversion(symbol.arrayCount, GLSLX.Type.INT);\r\n        }\r\n\r\n        // Initial value\r\n        if (symbol.value != null) {\r\n          this._resolveAsExpression(symbol.value);\r\n          this.checkConversion(symbol.value, type);\r\n\r\n          if (type.containsArray) {\r\n            this._log.semanticErrorArrayAssignment(node.internalRange, type);\r\n          }\r\n        }\r\n\r\n        // Constants must be initialized\r\n        if (symbol.isConst()) {\r\n          if (symbol.value != null) {\r\n            if (symbol.value.resolvedType != GLSLX.Type.ERROR) {\r\n              var folded = GLSLX.Folder.fold(symbol.value);\r\n\r\n              if (folded == null) {\r\n                this._log.syntaxErrorConstantRequired(symbol.value.range);\r\n              }\r\n\r\n              else {\r\n                assert(folded.parent() == null);\r\n                assert(folded.resolvedType != null);\r\n                symbol.constantValue = folded;\r\n              }\r\n            }\r\n          }\r\n\r\n          else if (symbol.kind == GLSLX.VariableKind.LOCAL) {\r\n            this._log.semanticErrorUninitializedConstant(symbol.range);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.BLOCK: {\r\n        this._resolveBlockOrStatement(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.BREAK:\r\n      case GLSLX.NodeKind.CONTINUE:\r\n      case GLSLX.NodeKind.DISCARD: {\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.DO_WHILE: {\r\n        this._resolveBlockOrStatement(node.doWhileBody());\r\n        this.resolveNode(node.doWhileTest());\r\n        this.checkConversion(node.doWhileTest(), GLSLX.Type.BOOL);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.EXPRESSION: {\r\n        this.resolveNode(node.expressionValue());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.EXTENSION: {\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FOR: {\r\n        if (node.forSetup() != null) {\r\n          this._resolveAsExpression(node.forSetup());\r\n        }\r\n\r\n        if (node.forTest() != null) {\r\n          this._resolveAsExpression(node.forTest());\r\n          this.checkConversion(node.forTest(), GLSLX.Type.BOOL);\r\n        }\r\n\r\n        if (node.forUpdate() != null) {\r\n          this._resolveAsExpression(node.forUpdate());\r\n        }\r\n\r\n        this._resolveBlockOrStatement(node.forBody());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.FUNCTION: {\r\n        var symbol1 = node.symbol.asFunction();\r\n\r\n        for (var i = 0, list = symbol1.$arguments, count = list.length; i < count; i = i + 1 | 0) {\r\n          var argument = in_List.get(list, i);\r\n          this.resolveNode(argument.type);\r\n        }\r\n\r\n        this.resolveNode(symbol1.returnType);\r\n\r\n        if (symbol1.block != null) {\r\n          this._returnType = symbol1.returnType.resolvedType;\r\n          this._resolveBlockOrStatement(symbol1.block);\r\n\r\n          // Missing a return statement is an error\r\n          if (this._returnType != GLSLX.Type.VOID && symbol1.block.hasControlFlowAtEnd) {\r\n            this._log.semanticErrorMissingReturn(symbol1.range, symbol1.name, this._returnType);\r\n          }\r\n\r\n          this._returnType = null;\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.IF: {\r\n        this.resolveNode(node.ifTest());\r\n        this.checkConversion(node.ifTest(), GLSLX.Type.BOOL);\r\n        this._resolveBlockOrStatement(node.ifTrue());\r\n\r\n        if (node.ifFalse() != null) {\r\n          this._resolveBlockOrStatement(node.ifFalse());\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.PRECISION: {\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.RETURN: {\r\n        if (node.returnValue() != null) {\r\n          this.resolveNode(node.returnValue());\r\n          this.checkConversion(node.returnValue(), this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\r\n        }\r\n\r\n        else {\r\n          node.resolvedType = GLSLX.Type.VOID;\r\n          this.checkConversion(node, this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.STRUCT: {\r\n        this._resolveChildren(node);\r\n\r\n        // A struct loses operator \"==\" and \"!=\" when it contains a type without those operators\r\n        var resolvedType = node.symbol.resolvedType();\r\n\r\n        for (var i1 = 0, list1 = node.symbol.asStruct().variables, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n          var variable = in_List.get(list1, i1);\r\n          var type1 = variable.type.resolvedType;\r\n\r\n          if (type1.containsArray) {\r\n            resolvedType.containsArray = true;\r\n          }\r\n\r\n          if (type1.containsSampler) {\r\n            resolvedType.containsSampler = true;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.VARIABLES: {\r\n        this._resolveChildren(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.VERSION: {\r\n        this._versions.push(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.WHILE: {\r\n        this.resolveNode(node.whileTest());\r\n        this.checkConversion(node.whileTest(), GLSLX.Type.BOOL);\r\n        this._resolveBlockOrStatement(node.whileBody());\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.CALL: {\r\n        this._resolveCall(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.DOT: {\r\n        this._resolveDot(node);\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.HOOK: {\r\n        var test = node.hookTest();\r\n        var no = node.hookFalse();\r\n        var yes = node.hookTrue();\r\n        this._resolveAsExpression(test);\r\n        this.checkConversion(test, GLSLX.Type.BOOL);\r\n        this._resolveAsExpression(yes);\r\n        this._resolveAsExpression(no);\r\n\r\n        if (yes.resolvedType != no.resolvedType) {\r\n          this._log.semanticErrorBadHookTypes(GLSLX.Range.span(yes.range, no.range), yes.resolvedType, no.resolvedType);\r\n        }\r\n\r\n        else if (yes.resolvedType.containsArray) {\r\n          this._log.semanticErrorArrayHook(GLSLX.Range.span(yes.range, no.range), yes.resolvedType);\r\n        }\r\n\r\n        else {\r\n          node.resolvedType = yes.resolvedType;\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.NAME: {\r\n        var symbol2 = node.symbol;\r\n\r\n        if (symbol2.isVariable()) {\r\n          this.resolveNode(symbol2.asVariable().type);\r\n          node.resolvedType = symbol2.asVariable().type.resolvedType;\r\n        }\r\n\r\n        else if (symbol2.isFunction() && !node.isCallTarget()) {\r\n          this._log.semanticErrorMustCallFunction(node.range, symbol2.name);\r\n        }\r\n\r\n        else {\r\n          node.resolvedType = symbol2.resolvedType();\r\n        }\r\n\r\n        // Make sure the extension is enabled if it hasn't been specified\r\n        var name = symbol2.requiredExtension;\r\n\r\n        if (name != null && !(name in this._generatedExtensions) && this._data.extensionBehavior(name) == GLSLX.ExtensionBehavior.DEFAULT) {\r\n          this._generatedExtensions[name] = new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(GLSLX.ExtensionBehavior.ENABLE);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.SEQUENCE: {\r\n        for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n          this._resolveAsExpression(child);\r\n        }\r\n\r\n        node.resolvedType = node.lastChild().resolvedType;\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        if (GLSLX.in_NodeKind.isUnary(kind)) {\r\n          this._resolveUnary(node);\r\n        }\r\n\r\n        else if (GLSLX.in_NodeKind.isBinary(kind)) {\r\n          this._resolveBinary(node);\r\n        }\r\n\r\n        else {\r\n          assert(false);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    assert(node.resolvedType != null);\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveBlockOrStatement = function(node) {\r\n    assert(GLSLX.in_NodeKind.isStatement(node.kind));\r\n    this._controlFlow.pushBlock(node);\r\n\r\n    if (node.kind == GLSLX.NodeKind.BLOCK) {\r\n      for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n        this.resolveNode(child);\r\n        this._controlFlow.visitStatement(child);\r\n      }\r\n    }\r\n\r\n    else {\r\n      this.resolveNode(node);\r\n      this._controlFlow.visitStatement(node);\r\n    }\r\n\r\n    this._controlFlow.popBlock(node);\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveUnary = function(node) {\r\n    var value = node.unaryValue();\r\n    this._resolveAsExpression(value);\r\n\r\n    if (GLSLX.in_NodeKind.isUnaryAssign(node.kind)) {\r\n      this._checkStorage(value);\r\n    }\r\n\r\n    var valueType = value.resolvedType;\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.NEGATIVE:\r\n      case GLSLX.NodeKind.POSITIVE:\r\n      case GLSLX.NodeKind.PREFIX_DECREMENT:\r\n      case GLSLX.NodeKind.PREFIX_INCREMENT:\r\n      case GLSLX.NodeKind.POSTFIX_DECREMENT:\r\n      case GLSLX.NodeKind.POSTFIX_INCREMENT: {\r\n        node.resolvedType = valueType.isIntOrFloat() ? valueType : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.NOT: {\r\n        node.resolvedType = valueType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (node.resolvedType == GLSLX.Type.ERROR && valueType != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorBadUnaryOperator(node.internalRange, node.internalRange.toString(), valueType);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveBinary = function(node) {\r\n    var left = node.binaryLeft();\r\n    var right = node.binaryRight();\r\n    this._resolveAsExpression(left);\r\n    this._resolveAsExpression(right);\r\n\r\n    if (GLSLX.in_NodeKind.isBinaryAssign(node.kind)) {\r\n      this._checkStorage(left);\r\n    }\r\n\r\n    var leftType = left.resolvedType;\r\n    var rightType = right.resolvedType;\r\n    var isSame = leftType == rightType;\r\n\r\n    switch (node.kind) {\r\n      case GLSLX.NodeKind.ADD:\r\n      case GLSLX.NodeKind.SUBTRACT:\r\n      case GLSLX.NodeKind.MULTIPLY:\r\n      case GLSLX.NodeKind.DIVIDE: {\r\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : leftType == GLSLX.Type.FLOAT && rightType.hasFloatComponents() ? rightType : leftType == GLSLX.Type.INT && rightType.hasIntComponents() ? rightType : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2) ? GLSLX.Type.VEC2 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3) ? GLSLX.Type.VEC3 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) ? GLSLX.Type.VEC4 : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.EQUAL:\r\n      case GLSLX.NodeKind.NOT_EQUAL: {\r\n        node.resolvedType = isSame && leftType.canUseEqualityOperators() ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.LOGICAL_AND:\r\n      case GLSLX.NodeKind.LOGICAL_OR:\r\n      case GLSLX.NodeKind.LOGICAL_XOR: {\r\n        node.resolvedType = isSame && leftType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.LESS_THAN:\r\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL:\r\n      case GLSLX.NodeKind.GREATER_THAN:\r\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\r\n        node.resolvedType = isSame && (leftType == GLSLX.Type.FLOAT || leftType == GLSLX.Type.INT) ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.ASSIGN: {\r\n        node.resolvedType = leftType;\r\n\r\n        if (leftType.containsArray) {\r\n          this._log.semanticErrorArrayAssignment(node.internalRange, leftType);\r\n        }\r\n\r\n        this.checkConversion(right, leftType);\r\n        return;\r\n      }\r\n\r\n      case GLSLX.NodeKind.ASSIGN_ADD:\r\n      case GLSLX.NodeKind.ASSIGN_SUBTRACT:\r\n      case GLSLX.NodeKind.ASSIGN_MULTIPLY:\r\n      case GLSLX.NodeKind.ASSIGN_DIVIDE: {\r\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : node.kind == GLSLX.NodeKind.ASSIGN_MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) ? leftType : GLSLX.Type.ERROR;\r\n        break;\r\n      }\r\n\r\n      case GLSLX.NodeKind.INDEX: {\r\n        if (rightType == GLSLX.Type.INT) {\r\n          var indexType = leftType.indexType();\r\n\r\n          if (indexType != null) {\r\n            node.resolvedType = indexType;\r\n          }\r\n\r\n          // Run bounds checking on the constant-folded value\r\n          var folded = GLSLX.Folder.fold(right);\r\n\r\n          if (folded != null && folded.kind == GLSLX.NodeKind.INT) {\r\n            var value = folded.asInt();\r\n            var count = leftType.indexCount();\r\n\r\n            // Negative indices are always invalid even if the array size is unknown\r\n            if (value < 0 || count != 0 && value >= count) {\r\n              this._log.semanticErrorOutOfBoundsIndex(right.range, value, leftType);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If we get here, show an error about an invalid operator\r\n    if (node.resolvedType == GLSLX.Type.ERROR && leftType != GLSLX.Type.ERROR && rightType != GLSLX.Type.ERROR) {\r\n      if (node.kind == GLSLX.NodeKind.INDEX) {\r\n        this._log.semanticErrorBadIndex(node.internalRange, leftType, rightType);\r\n      }\r\n\r\n      else {\r\n        this._log.semanticErrorBadBinaryOperator(node.internalRange, node.internalRange.toString(), leftType, rightType);\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveCall = function(node) {\r\n    var callTarget = node.callTarget();\r\n    this.resolveNode(callTarget);\r\n    var type = callTarget.resolvedType;\r\n    var symbol = type.symbol;\r\n    var $arguments = [];\r\n    var hasError = false;\r\n\r\n    for (var child = callTarget.nextSibling(); child != null; child = child.nextSibling()) {\r\n      this._resolveAsExpression(child);\r\n      $arguments.push(child);\r\n\r\n      if (child.resolvedType == GLSLX.Type.ERROR) {\r\n        hasError = true;\r\n      }\r\n    }\r\n\r\n    if (hasError) {\r\n      return;\r\n    }\r\n\r\n    if (symbol != null) {\r\n      if (symbol.isFunction()) {\r\n        this._resolveFunctionOverloads(symbol.asFunction(), node, $arguments);\r\n        return;\r\n      }\r\n\r\n      if (symbol.isStruct()) {\r\n        this._resolveConstructor(type, node, $arguments);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (type != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorBadCall(callTarget.range, type);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveDot = function(node) {\r\n    var dotTarget = node.dotTarget();\r\n    var name = node.asString();\r\n    var range = node.internalRange;\r\n    this._resolveAsExpression(dotTarget);\r\n    var type = dotTarget.resolvedType;\r\n    var isAssignTarget = node.isAssignTarget();\r\n\r\n    switch (type) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.VEC4: {\r\n        node.resolvedType = this._validateSwizzle(range, type, name, isAssignTarget);\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        if (type.symbol != null && type.symbol.isStruct()) {\r\n          for (var i = 0, list = type.symbol.asStruct().variables, count = list.length; i < count; i = i + 1 | 0) {\r\n            var variable = in_List.get(list, i);\r\n\r\n            if (variable.name == name) {\r\n              node.symbol = variable;\r\n              this.resolveNode(variable.type);\r\n              node.resolvedType = variable.type.resolvedType;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (node.symbol == null) {\r\n          this._log.semanticErrorBadMember(range, type, name);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveFunctionOverloads = function(overloaded, node, $arguments) {\r\n    var overloads = [];\r\n\r\n    // Collect all relevant overloads but ignore forward-declared functions that also have an implementation\r\n    for (var overload = overloaded; overload != null; overload = overload.previousOverload) {\r\n      if (!(overloads.indexOf(overload.sibling) != -1)) {\r\n        overloads.push(overload);\r\n      }\r\n    }\r\n\r\n    // Narrow down by argument count\r\n    if (overloads.length != 1) {\r\n      overloads = overloads.slice();\r\n      in_List.removeIf(overloads, function(overload) {\r\n        return overload.$arguments.length != $arguments.length;\r\n      });\r\n\r\n      // Narrow down by argument types\r\n      if (overloads.length != 1) {\r\n        var overloadsBeforeTypeFilter = overloads.slice();\r\n        in_List.removeIf(overloads, function(overload) {\r\n          for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n            if (in_List.get(overload.$arguments, i).type.resolvedType != in_List.get($arguments, i).resolvedType) {\r\n              return true;\r\n            }\r\n          }\r\n\r\n          return false;\r\n        });\r\n\r\n        // Narrow down by argument types with \"conversions\" to get better error messages\r\n        if (overloads.length != 1) {\r\n          overloads = overloadsBeforeTypeFilter;\r\n          in_List.removeIf(overloads, function(overload) {\r\n            for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n              var from = in_List.get(overload.$arguments, i).type.resolvedType;\r\n              var to = in_List.get($arguments, i).resolvedType;\r\n              var fromSize = from.componentCount();\r\n              var toSize = to.componentCount();\r\n\r\n              if (from != to && (fromSize == 0 || toSize == 0 || fromSize != toSize)) {\r\n                return true;\r\n              }\r\n            }\r\n\r\n            return false;\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Match failure\r\n    if (overloads.length != 1) {\r\n      this._log.semanticErrorBadOverloadMatch(node.callTarget().range, overloaded.name);\r\n      return;\r\n    }\r\n\r\n    // Match success\r\n    var overload1 = in_List.first(overloads);\r\n\r\n    if (overload1.$arguments.length != $arguments.length) {\r\n      this._log.semanticErrorArgumentCountFunction(node.internalRange, overload1.$arguments.length, $arguments.length, overload1.name, overload1.range);\r\n    }\r\n\r\n    else {\r\n      for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\r\n        this.checkConversion(in_List.get($arguments, i), in_List.get(overload1.$arguments, i).type.resolvedType);\r\n      }\r\n    }\r\n\r\n    node.callTarget().symbol = overload1;\r\n    node.resolvedType = overload1.returnType.resolvedType;\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveConstructor = function(type, node, $arguments) {\r\n    node.resolvedType = type;\r\n\r\n    if (type == GLSLX.Type.ERROR) {\r\n      return;\r\n    }\r\n\r\n    if (type.componentType() != null) {\r\n      var count = type.componentCount();\r\n      var hasMatrixArgument = false;\r\n\r\n      // Visit each argument and make sure it's useful toward construction\r\n      var providedCount = 0;\r\n\r\n      for (var i1 = 0, list = $arguments, count1 = list.length; i1 < count1; i1 = i1 + 1 | 0) {\r\n        var argument = in_List.get(list, i1);\r\n        var argumentType = argument.resolvedType;\r\n        var deltaCount = argumentType.componentCount();\r\n\r\n        // Each type in a component-based types must be able to itself be unpacked into components\r\n        if (argumentType.componentType() == null) {\r\n          if (argumentType != GLSLX.Type.ERROR) {\r\n            this._log.semanticErrorBadConstructorValue(argument.range, argumentType, type);\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // Passing extra values to a constructor is allowed sometimes\r\n        //\r\n        // Allowed:\r\n        //\r\n        //   vec3(vec4(1.0));\r\n        //   vec3(1.0, vec4(1.0));\r\n        //\r\n        // Not allowed:\r\n        //\r\n        //   vec3(vec4(1.0), 1.0);\r\n        //   vec3(vec3(1.0), vec3(1.0));\r\n        //\r\n        if (providedCount >= count) {\r\n          this._log.semanticErrorExtraConstructorValue(argument.range, type, count, providedCount + deltaCount | 0);\r\n        }\r\n\r\n        if (argumentType.isMatrix()) {\r\n          hasMatrixArgument = true;\r\n        }\r\n\r\n        providedCount = providedCount + deltaCount | 0;\r\n      }\r\n\r\n      // If a matrix argument is given to a matrix constructor, it is an error\r\n      // to have any other arguments\r\n      var isMatrixMatrixConstructor = type.isMatrix() && hasMatrixArgument;\r\n\r\n      if (isMatrixMatrixConstructor && $arguments.length != 1) {\r\n        this._log.semanticErrorBadMatrixConstructor(node.internalRange);\r\n      }\r\n\r\n      // Validate the count (constructing a matrix using a matrix should always work)\r\n      else if (providedCount < count && providedCount != 1 && !isMatrixMatrixConstructor) {\r\n        this._log.semanticErrorBadConstructorCount(node.internalRange, type, providedCount);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    var symbol = type.symbol.asStruct();\r\n    var variables = symbol.variables;\r\n    var variableCount = variables.length;\r\n    var argumentCount = $arguments.length;\r\n\r\n    // Validate argument count\r\n    if (variableCount != argumentCount) {\r\n      this._log.semanticErrorArgumentCountConstructor(node.internalRange, variableCount, argumentCount, symbol.name, symbol.range);\r\n      return;\r\n    }\r\n\r\n    // Validate argument types\r\n    for (var i = 0, count2 = variableCount; i < count2; i = i + 1 | 0) {\r\n      this.checkConversion(in_List.get($arguments, i), in_List.get(variables, i).type.resolvedType);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._validateSwizzle = function(range, type, name, isAssignTarget) {\r\n    var count = name.length;\r\n\r\n    if (count > 4) {\r\n      this._log.semanticErrorBadSwizzle(range, type, name);\r\n      return GLSLX.Type.ERROR;\r\n    }\r\n\r\n    var componentCount = type.componentCount();\r\n\r\n    for (var i1 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i1 < count2; i1 = i1 + 1 | 0) {\r\n      var set = in_List.get(list, i1);\r\n\r\n      if (set.indexOf(in_string.get(name, 0)) != -1) {\r\n        for (var i = 1, count1 = count; i < count1; i = i + 1 | 0) {\r\n          if (!(set.indexOf(in_string.get(name, i)) != -1)) {\r\n            this._log.semanticErrorBadSwizzle(range, type, name);\r\n            return GLSLX.Type.ERROR;\r\n          }\r\n\r\n          if (isAssignTarget && in_string.slice2(name, 0, i).indexOf(in_string.get(name, i)) != -1) {\r\n            this._log.semanticErrorBadSwizzleAssignment(range.slice(i, i + 1 | 0), in_string.get(name, i));\r\n            return GLSLX.Type.ERROR;\r\n          }\r\n        }\r\n\r\n        return GLSLX.Swizzle.type(type.componentType(), count);\r\n      }\r\n    }\r\n\r\n    this._log.semanticErrorBadSwizzle(range, type, name);\r\n    return GLSLX.Type.ERROR;\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveAsExpression = function(node) {\r\n    this.resolveNode(node);\r\n\r\n    if (node.kind == GLSLX.NodeKind.TYPE && node.resolvedType != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorUnexpectedType(node.range, node.resolvedType);\r\n      node.resolvedType = GLSLX.Type.ERROR;\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._resolveChildren = function(node) {\r\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\r\n      this.resolveNode(child);\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype._checkStorage = function(node) {\r\n    var n = node;\r\n    assert(GLSLX.in_NodeKind.isExpression(node.kind));\r\n\r\n    label: while (true) {\r\n      if (n.resolvedType == GLSLX.Type.ERROR) {\r\n        break;\r\n      }\r\n\r\n      switch (n.kind) {\r\n        case GLSLX.NodeKind.NAME: {\r\n          if (n.symbol.isConst()) {\r\n            this._log.semanticErrorBadStorage(node.range);\r\n          }\r\n\r\n          break label;\r\n        }\r\n\r\n        case GLSLX.NodeKind.DOT: {\r\n          n = n.dotTarget();\r\n          break;\r\n        }\r\n\r\n        case GLSLX.NodeKind.INDEX: {\r\n          n = n.binaryLeft();\r\n          break;\r\n        }\r\n\r\n        default: {\r\n          this._log.semanticErrorBadStorage(node.range);\r\n          break label;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Resolver.prototype.checkConversion = function(node, type) {\r\n    if (node.resolvedType != type && node.resolvedType != GLSLX.Type.ERROR && type != GLSLX.Type.ERROR) {\r\n      this._log.semanticErrorBadConversion(node.range, node.resolvedType, type);\r\n      node.resolvedType = GLSLX.Type.ERROR;\r\n    }\r\n  };\r\n\r\n  GLSLX.ScopeKind = {\r\n    FUNCTION: 0,\r\n    GLOBAL: 1,\r\n    LOCAL: 2,\r\n    LOOP: 3,\r\n    STRUCT: 4\r\n  };\r\n\r\n  GLSLX.Scope = function(kind, parent) {\r\n    this.kind = kind;\r\n    this.parent = parent;\r\n    this.symbols = Object.create(null);\r\n  };\r\n\r\n  GLSLX.Scope.prototype.define = function(symbol) {\r\n    assert(!(symbol.name in this.symbols));\r\n    this.symbols[symbol.name] = symbol;\r\n  };\r\n\r\n  GLSLX.Scope.prototype.redefine = function(symbol) {\r\n    assert(symbol.name in this.symbols);\r\n    assert(in_StringMap.get1(this.symbols, symbol.name) != symbol);\r\n    this.symbols[symbol.name] = symbol;\r\n  };\r\n\r\n  GLSLX.Scope.prototype.find = function(name) {\r\n    var symbol = in_StringMap.get(this.symbols, name, null);\r\n\r\n    if (symbol != null) {\r\n      return symbol;\r\n    }\r\n\r\n    if (this.parent != null) {\r\n      return this.parent.find(name);\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GLSLX.LineColumn = function(line, column) {\r\n    this.line = line;\r\n    this.column = column;\r\n  };\r\n\r\n  GLSLX.Source = function(name, contents) {\r\n    this.name = name;\r\n    this.contents = contents;\r\n    this.tokens = null;\r\n    this._lineOffsets = null;\r\n  };\r\n\r\n  GLSLX.Source.prototype.indexToLineColumn = function(index) {\r\n    this._computeLineOffsets();\r\n\r\n    // Binary search to find the line\r\n    var count = this._lineOffsets.length;\r\n    var line = 0;\r\n\r\n    while (count > 0) {\r\n      var step = count / 2 | 0;\r\n      var i = line + step | 0;\r\n\r\n      if (in_List.get(this._lineOffsets, i) <= index) {\r\n        line = i + 1 | 0;\r\n        count = (count - step | 0) - 1 | 0;\r\n      }\r\n\r\n      else {\r\n        count = step;\r\n      }\r\n    }\r\n\r\n    // Use the line to compute the column\r\n    var column = line > 0 ? index - in_List.get(this._lineOffsets, line - 1 | 0) | 0 : index;\r\n    return new GLSLX.LineColumn(line - 1 | 0, column);\r\n  };\r\n\r\n  GLSLX.Source.prototype._computeLineOffsets = function() {\r\n    if (this._lineOffsets == null) {\r\n      this._lineOffsets = [0];\r\n\r\n      for (var i = 0, count = this.contents.length; i < count; i = i + 1 | 0) {\r\n        if (in_string.get1(this.contents, i) == 10) {\r\n          this._lineOffsets.push(i + 1 | 0);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Swizzle = {};\r\n\r\n  GLSLX.Swizzle.strings = function(componentCount) {\r\n    switch (componentCount) {\r\n      case 2: {\r\n        return GLSLX.Swizzle._STRINGS_2;\r\n      }\r\n\r\n      case 3: {\r\n        return GLSLX.Swizzle._STRINGS_3;\r\n      }\r\n\r\n      case 4: {\r\n        return GLSLX.Swizzle._STRINGS_4;\r\n      }\r\n    }\r\n\r\n    assert(false);\r\n    return null;\r\n  };\r\n\r\n  GLSLX.Swizzle.type = function(comonentType, componentCount) {\r\n    switch (comonentType) {\r\n      case GLSLX.Type.BOOL: {\r\n        switch (componentCount) {\r\n          case 1: {\r\n            return GLSLX.Type.BOOL;\r\n          }\r\n\r\n          case 2: {\r\n            return GLSLX.Type.BVEC2;\r\n          }\r\n\r\n          case 3: {\r\n            return GLSLX.Type.BVEC3;\r\n          }\r\n\r\n          case 4: {\r\n            return GLSLX.Type.BVEC4;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.Type.FLOAT: {\r\n        switch (componentCount) {\r\n          case 1: {\r\n            return GLSLX.Type.FLOAT;\r\n          }\r\n\r\n          case 2: {\r\n            return GLSLX.Type.VEC2;\r\n          }\r\n\r\n          case 3: {\r\n            return GLSLX.Type.VEC3;\r\n          }\r\n\r\n          case 4: {\r\n            return GLSLX.Type.VEC4;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case GLSLX.Type.INT: {\r\n        switch (componentCount) {\r\n          case 1: {\r\n            return GLSLX.Type.INT;\r\n          }\r\n\r\n          case 2: {\r\n            return GLSLX.Type.IVEC2;\r\n          }\r\n\r\n          case 3: {\r\n            return GLSLX.Type.IVEC3;\r\n          }\r\n\r\n          case 4: {\r\n            return GLSLX.Type.IVEC4;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    assert(false);\r\n    return null;\r\n  };\r\n\r\n  GLSLX.SymbolFlags = {\r\n    // Keyword modifiers\r\n    ATTRIBUTE: 1,\r\n    CONST: 2,\r\n    HIGHP: 4,\r\n    IN: 8,\r\n    INOUT: 16,\r\n    LOWP: 32,\r\n    MEDIUMP: 64,\r\n    OUT: 128,\r\n    UNIFORM: 256,\r\n    VARYING: 512,\r\n\r\n    // Internal compiler flags\r\n    EXPORTED: 1024,\r\n    IMPORTED: 2048\r\n  };\r\n\r\n  GLSLX.Symbol = function(id, range, name, scope) {\r\n    this.id = id;\r\n    this.range = range;\r\n    this.name = name;\r\n    this.scope = scope;\r\n    this.flags = 0;\r\n    this.constantValue = null;\r\n    this.requiredExtension = null;\r\n    this._resolvedType = null;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isConst = function() {\r\n    return (GLSLX.SymbolFlags.CONST & this.flags) != 0;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isStruct = function() {\r\n    return this instanceof GLSLX.StructSymbol;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isFunction = function() {\r\n    return this instanceof GLSLX.FunctionSymbol;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.isVariable = function() {\r\n    return this instanceof GLSLX.VariableSymbol;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.asStruct = function() {\r\n    assert(this.isStruct());\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.asFunction = function() {\r\n    assert(this.isFunction());\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.asVariable = function() {\r\n    assert(this.isVariable());\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Symbol.prototype.resolvedType = function() {\r\n    if (this._resolvedType == null) {\r\n      this._resolvedType = new GLSLX.Type(this, null, 0);\r\n    }\r\n\r\n    return this._resolvedType;\r\n  };\r\n\r\n  GLSLX.StructSymbol = function(id, range, name, scope) {\r\n    GLSLX.Symbol.call(this, id, range, name, scope);\r\n    this.variables = [];\r\n  };\r\n\r\n  __extends(GLSLX.StructSymbol, GLSLX.Symbol);\r\n\r\n  GLSLX.FunctionSymbol = function(id, range, name, scope) {\r\n    GLSLX.Symbol.call(this, id, range, name, scope);\r\n    this.$arguments = [];\r\n    this.returnType = null;\r\n    this.block = null;\r\n    this.previousOverload = null;\r\n    this.sibling = null;\r\n  };\r\n\r\n  __extends(GLSLX.FunctionSymbol, GLSLX.Symbol);\r\n\r\n  GLSLX.FunctionSymbol.prototype.hasSameArgumentTypesAs = function($function) {\r\n    if (this.$arguments.length != $function.$arguments.length) {\r\n      return false;\r\n    }\r\n\r\n    for (var i = 0, count = this.$arguments.length; i < count; i = i + 1 | 0) {\r\n      if (in_List.get(this.$arguments, i).type.resolvedType != in_List.get($function.$arguments, i).type.resolvedType) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  GLSLX.VariableKind = {\r\n    ARGUMENT: 0,\r\n    GLOBAL: 1,\r\n    LOCAL: 2,\r\n    STRUCT: 3\r\n  };\r\n\r\n  GLSLX.VariableSymbol = function(id, range, name, scope, kind) {\r\n    GLSLX.Symbol.call(this, id, range, name, scope);\r\n    this.kind = kind;\r\n    this.type = null;\r\n    this.value = null;\r\n    this.arrayCount = null;\r\n  };\r\n\r\n  __extends(GLSLX.VariableSymbol, GLSLX.Symbol);\r\n\r\n  GLSLX.TokenKind = {\r\n    // Standard keywords\r\n    ATTRIBUTE: 0,\r\n    BOOL: 1,\r\n    BREAK: 2,\r\n    BVEC2: 3,\r\n    BVEC3: 4,\r\n    BVEC4: 5,\r\n    CONST: 6,\r\n    CONTINUE: 7,\r\n    DISCARD: 8,\r\n    DO: 9,\r\n    ELSE: 10,\r\n    FALSE: 11,\r\n    FLOAT: 12,\r\n    FOR: 13,\r\n    HIGHP: 14,\r\n    IF: 15,\r\n    IN: 16,\r\n    INOUT: 17,\r\n    INT: 18,\r\n    INVARIANT: 19,\r\n    IVEC2: 20,\r\n    IVEC3: 21,\r\n    IVEC4: 22,\r\n    LOWP: 23,\r\n    MAT2: 24,\r\n    MAT3: 25,\r\n    MAT4: 26,\r\n    MEDIUMP: 27,\r\n    OUT: 28,\r\n    PRECISION: 29,\r\n    RETURN: 30,\r\n    SAMPLER2D: 31,\r\n    SAMPLERCUBE: 32,\r\n    STRUCT: 33,\r\n    TRUE: 34,\r\n    UNIFORM: 35,\r\n    VARYING: 36,\r\n    VEC2: 37,\r\n    VEC3: 38,\r\n    VEC4: 39,\r\n    VOID: 40,\r\n    WHILE: 41,\r\n\r\n    // Non-standard keywords\r\n    EXPORT: 42,\r\n    IMPORT: 43,\r\n\r\n    // Unary\r\n    COMPLEMENT: 44,\r\n    DECREMENT: 45,\r\n    INCREMENT: 46,\r\n    NOT: 47,\r\n\r\n    // Binary\r\n    BITWISE_AND: 48,\r\n    BITWISE_OR: 49,\r\n    BITWISE_XOR: 50,\r\n    DIVIDE: 51,\r\n    EQUAL: 52,\r\n    GREATER_THAN: 53,\r\n    GREATER_THAN_OR_EQUAL: 54,\r\n    LESS_THAN: 55,\r\n    LESS_THAN_OR_EQUAL: 56,\r\n    LOGICAL_AND: 57,\r\n    LOGICAL_OR: 58,\r\n    LOGICAL_XOR: 59,\r\n    MINUS: 60,\r\n    MULTIPLY: 61,\r\n    NOT_EQUAL: 62,\r\n    PLUS: 63,\r\n    REMAINDER: 64,\r\n    SHIFT_LEFT: 65,\r\n    SHIFT_RIGHT: 66,\r\n\r\n    // Binary assignment\r\n    ASSIGN: 67,\r\n    ASSIGN_ADD: 68,\r\n    ASSIGN_BITWISE_AND: 69,\r\n    ASSIGN_BITWISE_OR: 70,\r\n    ASSIGN_BITWISE_XOR: 71,\r\n    ASSIGN_DIVIDE: 72,\r\n    ASSIGN_MULTIPLY: 73,\r\n    ASSIGN_REMAINDER: 74,\r\n    ASSIGN_SHIFT_LEFT: 75,\r\n    ASSIGN_SHIFT_RIGHT: 76,\r\n    ASSIGN_SUBTRACT: 77,\r\n\r\n    // Other operators\r\n    COLON: 78,\r\n    COMMA: 79,\r\n    DOT: 80,\r\n    LEFT_BRACE: 81,\r\n    LEFT_BRACKET: 82,\r\n    LEFT_PARENTHESIS: 83,\r\n    QUESTION: 84,\r\n    RIGHT_BRACE: 85,\r\n    RIGHT_BRACKET: 86,\r\n    RIGHT_PARENTHESIS: 87,\r\n    SEMICOLON: 88,\r\n\r\n    // Pragmas\r\n    EXTENSION: 89,\r\n    VERSION: 90,\r\n    INCLUDE: 91,\r\n\r\n    // Literals\r\n    FLOAT_LITERAL: 92,\r\n    IDENTIFIER: 93,\r\n    INT_LITERAL: 94,\r\n    STRING_LITERAL: 95,\r\n\r\n    // This is always at the end of the token stream\r\n    END_OF_FILE: 96\r\n  };\r\n\r\n  GLSLX.Token = function(range, kind) {\r\n    this.range = range;\r\n    this.kind = kind;\r\n  };\r\n\r\n  GLSLX.Tokenizer = {};\r\n\r\n  GLSLX.Tokenizer.tokenize = function(log, source) {\r\n    var parts = source.contents.split(GLSLX.Tokenizer._tokenRegex);\r\n    var tokens = [];\r\n    var start = 0;\r\n\r\n    for (var i = 0, count1 = parts.length; i < count1; i = i + 1 | 0) {\r\n      var part = in_List.get(parts, i);\r\n      var count = part.length;\r\n      var end = start + count | 0;\r\n      var range = new GLSLX.Range(source, start, end);\r\n\r\n      if (i % 2 != 0) {\r\n        var c = in_string.get1(part, 0);\r\n\r\n        // Identifier\r\n        if (c >= 65 && c <= 90 || c >= 97 && c <= 122 || c == 95) {\r\n          var keyword = in_StringMap.get(GLSLX.Tokenizer.keywords, part, GLSLX.TokenKind.END_OF_FILE);\r\n\r\n          if (keyword != GLSLX.TokenKind.END_OF_FILE) {\r\n            tokens.push(new GLSLX.Token(range, keyword));\r\n          }\r\n\r\n          else if (part in GLSLX.Tokenizer.reservedWords) {\r\n            log.syntaxErrorReservedWord(range);\r\n          }\r\n\r\n          else {\r\n            tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.IDENTIFIER));\r\n          }\r\n        }\r\n\r\n        // Number\r\n        else if (c >= 48 && c <= 57 || c == 46 && count > 1) {\r\n          tokens.push(new GLSLX.Token(range, GLSLX.Tokenizer._intRegex.test(part) ? GLSLX.TokenKind.INT_LITERAL : GLSLX.TokenKind.FLOAT_LITERAL));\r\n        }\r\n\r\n        // Pragma\r\n        else if (c == 35) {\r\n          tokens.push(new GLSLX.Token(range, in_string.get1(part, 1) == 118 ? GLSLX.TokenKind.VERSION : in_string.get1(part, 1) == 101 ? GLSLX.TokenKind.EXTENSION : GLSLX.TokenKind.INCLUDE));\r\n        }\r\n\r\n        // String literal\r\n        else if (c == 34) {\r\n          tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.STRING_LITERAL));\r\n        }\r\n\r\n        // Operator\r\n        else {\r\n          var kind = in_StringMap.get(GLSLX.Tokenizer.operators, part, GLSLX.TokenKind.END_OF_FILE);\r\n\r\n          if (kind != GLSLX.TokenKind.END_OF_FILE) {\r\n            tokens.push(new GLSLX.Token(range, kind));\r\n          }\r\n        }\r\n      }\r\n\r\n      else if (part != '') {\r\n        log.syntaxErrorExtraData(range, part);\r\n        break;\r\n      }\r\n\r\n      start = end;\r\n    }\r\n\r\n    tokens.push(new GLSLX.Token(new GLSLX.Range(source, start, start), GLSLX.TokenKind.END_OF_FILE));\r\n    return tokens;\r\n  };\r\n\r\n  GLSLX.Type = function(symbol, isArrayOf, arrayCount) {\r\n    this.symbol = symbol;\r\n    this.isArrayOf = isArrayOf;\r\n    this.arrayCount = arrayCount;\r\n    this.containsArray = false;\r\n    this.containsSampler = false;\r\n    this._arrayTypes = null;\r\n  };\r\n\r\n  // A count of \"0\" means an array with an unknown size\r\n  GLSLX.Type.prototype.arrayType = function(count) {\r\n    assert(count >= 0);\r\n\r\n    if (this._arrayTypes == null) {\r\n      this._arrayTypes = {};\r\n    }\r\n\r\n    var arrayType = in_IntMap.get(this._arrayTypes, count, null);\r\n\r\n    if (arrayType == null) {\r\n      this._arrayTypes[count] = arrayType = new GLSLX.Type(null, this, count);\r\n      arrayType.containsArray = true;\r\n      arrayType.containsSampler = this.containsSampler;\r\n    }\r\n\r\n    return arrayType;\r\n  };\r\n\r\n  GLSLX.Type.prototype.toString = function() {\r\n    if (this.isArrayOf != null) {\r\n      return this.arrayCount != 0 ? this.isArrayOf.toString() + '[' + this.arrayCount.toString() + ']' : this.isArrayOf.toString() + '[]';\r\n    }\r\n\r\n    return this.symbol.name;\r\n  };\r\n\r\n  // For index expressions where \"0 <= index < indexCount\" (so indexCount == 0 means this type is un-indexable)\r\n  GLSLX.Type.prototype.indexCount = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.MAT2: {\r\n        return 2;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.MAT3: {\r\n        return 3;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.VEC4:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.MAT4: {\r\n        return 4;\r\n      }\r\n\r\n      default: {\r\n        return this.arrayCount;\r\n      }\r\n    }\r\n  };\r\n\r\n  // For index expressions\r\n  GLSLX.Type.prototype.indexType = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.BVEC4: {\r\n        return GLSLX.Type.BOOL;\r\n      }\r\n\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4: {\r\n        return GLSLX.Type.FLOAT;\r\n      }\r\n\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4: {\r\n        return GLSLX.Type.INT;\r\n      }\r\n\r\n      case GLSLX.Type.MAT2: {\r\n        return GLSLX.Type.VEC2;\r\n      }\r\n\r\n      case GLSLX.Type.MAT3: {\r\n        return GLSLX.Type.VEC3;\r\n      }\r\n\r\n      case GLSLX.Type.MAT4: {\r\n        return GLSLX.Type.VEC4;\r\n      }\r\n\r\n      default: {\r\n        return this.isArrayOf;\r\n      }\r\n    }\r\n  };\r\n\r\n  // For constructor expressions, returns the number of required elements\r\n  GLSLX.Type.prototype.componentCount = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BOOL:\r\n      case GLSLX.Type.FLOAT:\r\n      case GLSLX.Type.INT: {\r\n        return 1;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.IVEC2: {\r\n        return 2;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.IVEC3: {\r\n        return 3;\r\n      }\r\n\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.VEC4:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.MAT2: {\r\n        return 4;\r\n      }\r\n\r\n      case GLSLX.Type.MAT3: {\r\n        return 9;\r\n      }\r\n\r\n      case GLSLX.Type.MAT4: {\r\n        return 16;\r\n      }\r\n\r\n      default: {\r\n        return 0;\r\n      }\r\n    }\r\n  };\r\n\r\n  // For constructor expressions, returns the base element type corresponding to componentCount\r\n  GLSLX.Type.prototype.componentType = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BOOL:\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.BVEC4: {\r\n        return GLSLX.Type.BOOL;\r\n      }\r\n\r\n      case GLSLX.Type.FLOAT:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4:\r\n      case GLSLX.Type.MAT2:\r\n      case GLSLX.Type.MAT3:\r\n      case GLSLX.Type.MAT4: {\r\n        return GLSLX.Type.FLOAT;\r\n      }\r\n\r\n      case GLSLX.Type.INT:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4: {\r\n        return GLSLX.Type.INT;\r\n      }\r\n\r\n      default: {\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Vector types are the only ones with swizzles\r\n  GLSLX.Type.prototype.isVector = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.BVEC2:\r\n      case GLSLX.Type.BVEC3:\r\n      case GLSLX.Type.BVEC4:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.isMatrix = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.MAT2:\r\n      case GLSLX.Type.MAT3:\r\n      case GLSLX.Type.MAT4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.hasIntComponents = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.INT:\r\n      case GLSLX.Type.IVEC2:\r\n      case GLSLX.Type.IVEC3:\r\n      case GLSLX.Type.IVEC4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.hasFloatComponents = function() {\r\n    switch (this) {\r\n      case GLSLX.Type.FLOAT:\r\n      case GLSLX.Type.VEC2:\r\n      case GLSLX.Type.VEC3:\r\n      case GLSLX.Type.VEC4: {\r\n        return true;\r\n      }\r\n\r\n      case GLSLX.Type.MAT2:\r\n      case GLSLX.Type.MAT3:\r\n      case GLSLX.Type.MAT4: {\r\n        return true;\r\n      }\r\n\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  };\r\n\r\n  GLSLX.Type.prototype.isIntOrFloat = function() {\r\n    return this.hasIntComponents() || this.hasFloatComponents();\r\n  };\r\n\r\n  GLSLX.Type.prototype.canUseEqualityOperators = function() {\r\n    return !this.containsSampler && !this.containsArray;\r\n  };\r\n\r\n  GLSLX.Type.prototype._setContainsSampler = function() {\r\n    this.containsSampler = true;\r\n    return this;\r\n  };\r\n\r\n  GLSLX.Exports = {};\r\n\r\n  GLSLX.Exports.sourcesFromInput = function(input) {\r\n    if (__isString(input)) {\r\n      return [new GLSLX.Source('<stdin>', input)];\r\n    }\r\n\r\n    if (input instanceof Array) {\r\n      var sources = [];\r\n\r\n      for (var i = 0, count = input.length; i < count; i = i + 1 | 0) {\r\n        sources.push(new GLSLX.Source(input[i].name, input[i].contents));\r\n      }\r\n\r\n      return sources;\r\n    }\r\n\r\n    return [new GLSLX.Source(input.name, input.contents)];\r\n  };\r\n\r\n  GLSLX.Exports.main = function() {\r\n    var $this = (function() {\r\n      return this;\r\n    })();\r\n    var root = typeof exports !== 'undefined' ? exports : $this.GLSLX = {};\r\n\r\n    // API exports\r\n    root.check = GLSLX.Exports.check;\r\n  };\r\n\r\n  GLSLX.Exports.check = function(input, args) {\r\n    args = args || {};\r\n    var sources = GLSLX.Exports.sourcesFromInput(input);\r\n    var log = new GLSLX.Log();\r\n    var options = new GLSLX.CompilerOptions();\r\n\r\n    if (args.disableRewriting) {\r\n      options.compactSyntaxTree = false;\r\n    }\r\n\r\n    if (args.prettyPrint) {\r\n      options.removeWhitespace = false;\r\n    }\r\n\r\n    if (args.keepSymbols) {\r\n      options.trimSymbols = false;\r\n    }\r\n\r\n    if (args.globals) {\r\n      options.globals = args.globals;\r\n    }\r\n\r\n    var result = GLSLX.Compiler.typeCheck(log, sources, options);\r\n    return {'log': log, 'result': result};\r\n  };\r\n\r\n  GLSLX.in_NodeKind = {};\r\n\r\n  GLSLX.in_NodeKind.isStatement = function(self) {\r\n    return self >= GLSLX.NodeKind.BLOCK && self <= GLSLX.NodeKind.WHILE;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isExpression = function(self) {\r\n    return self >= GLSLX.NodeKind.CALL && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnary = function(self) {\r\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnaryPrefix = function(self) {\r\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.PREFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnaryPostfix = function(self) {\r\n    return self >= GLSLX.NodeKind.POSTFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isUnaryAssign = function(self) {\r\n    return self >= GLSLX.NodeKind.PREFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isBinary = function(self) {\r\n    return self >= GLSLX.NodeKind.ADD && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isBinaryAssign = function(self) {\r\n    return self >= GLSLX.NodeKind.ASSIGN && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\r\n  };\r\n\r\n  GLSLX.in_NodeKind.isLoop = function(self) {\r\n    return self == GLSLX.NodeKind.DO_WHILE || self == GLSLX.NodeKind.FOR || self == GLSLX.NodeKind.WHILE;\r\n  };\r\n\r\n  GLSLX.in_TokenKind = {};\r\n  var in_string = {};\r\n\r\n  in_string.slice2 = function(self, start, end) {\r\n    assert(0 <= start && start <= end && end <= self.length);\r\n    return self.slice(start, end);\r\n  };\r\n\r\n  in_string.get1 = function(self, index) {\r\n    assert(0 <= index && index < self.length);\r\n    return self.charCodeAt(index);\r\n  };\r\n\r\n  in_string.get = function(self, index) {\r\n    assert(0 <= index && index < self.length);\r\n    return self[index];\r\n  };\r\n\r\n  var in_List = {};\r\n\r\n  in_List.setLast = function(self, x) {\r\n    return in_List.set(self, self.length - 1 | 0, x);\r\n  };\r\n\r\n  in_List.get = function(self, index) {\r\n    assert(0 <= index && index < self.length);\r\n    return self[index];\r\n  };\r\n\r\n  in_List.set = function(self, index, value) {\r\n    assert(0 <= index && index < self.length);\r\n    return self[index] = value;\r\n  };\r\n\r\n  in_List.first = function(self) {\r\n    assert(!(self.length == 0));\r\n    return in_List.get(self, 0);\r\n  };\r\n\r\n  in_List.last = function(self) {\r\n    assert(!(self.length == 0));\r\n    return in_List.get(self, self.length - 1 | 0);\r\n  };\r\n\r\n  in_List.removeLast = function(self) {\r\n    assert(!(self.length == 0));\r\n    self.pop();\r\n  };\r\n\r\n  in_List.takeLast = function(self) {\r\n    assert(!(self.length == 0));\r\n    return self.pop();\r\n  };\r\n\r\n  in_List.removeIf = function(self, callback) {\r\n    var index = 0;\r\n\r\n    // Remove elements in place\r\n    for (var i = 0, count1 = self.length; i < count1; i = i + 1 | 0) {\r\n      if (!callback(in_List.get(self, i))) {\r\n        if (index < i) {\r\n          in_List.set(self, index, in_List.get(self, i));\r\n        }\r\n\r\n        index = index + 1 | 0;\r\n      }\r\n    }\r\n\r\n    // Shrink the array to the correct size\r\n    while (index < self.length) {\r\n      in_List.removeLast(self);\r\n    }\r\n  };\r\n\r\n  var in_StringMap = {};\r\n\r\n  in_StringMap.get1 = function(self, key) {\r\n    assert(key in self);\r\n    return self[key];\r\n  };\r\n\r\n  in_StringMap.insert = function(self, key, value) {\r\n    self[key] = value;\r\n    return self;\r\n  };\r\n\r\n  in_StringMap.get = function(self, key, defaultValue) {\r\n    var value = self[key];\r\n\r\n    // Compare against undefined so the key is only hashed once for speed\r\n    return value !== void 0 ? value : defaultValue;\r\n  };\r\n\r\n  in_StringMap.values = function(self) {\r\n    var values = [];\r\n\r\n    for (var key in self) {\r\n      values.push(in_StringMap.get1(self, key));\r\n    }\r\n\r\n    return values;\r\n  };\r\n\r\n  var in_IntMap = {};\r\n\r\n  in_IntMap.get = function(self, key, defaultValue) {\r\n    var value = self[key];\r\n\r\n    // Compare against undefined so the key is only hashed once for speed\r\n    return value !== void 0 ? value : defaultValue;\r\n  };\r\n\r\n  var RELEASE = false;\r\n\r\n  // This is from https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\r\n  GLSLX.API = '\\nimport {\\n  highp vec4 gl_Position; // should be written to\\n  mediump float gl_PointSize; // may be written to\\n\\n  const int gl_MaxVertexAttribs;\\n  const int gl_MaxVertexUniformVectors;\\n  const int gl_MaxVaryingVectors;\\n  const int gl_MaxVertexTextureImageUnits;\\n  const int gl_MaxCombinedTextureImageUnits;\\n  const int gl_MaxTextureImageUnits;\\n  const int gl_MaxFragmentUniformVectors;\\n  const int gl_MaxDrawBuffers;\\n\\n  const bool gl_FrontFacing;\\n  const mediump vec2 gl_PointCoord;\\n  const mediump vec4 gl_FragCoord;\\n  mediump vec4 gl_FragColor;\\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\\n\\n  struct gl_DepthRangeParameters {\\n    float near; // n\\n    float far; // f\\n    float diff; // f - n\\n  };\\n\\n  uniform gl_DepthRangeParameters gl_DepthRange;\\n\\n  // Angle and Trigonometry Functions\\n  float acos(float x);\\n  float asin(float x);\\n  float atan(float y, float x);\\n  float atan(float y_over_x);\\n  float cos(float angle);\\n  float degrees(float radians);\\n  float radians(float degrees);\\n  float sin(float angle);\\n  float tan(float angle);\\n  vec2 acos(vec2 x);\\n  vec2 asin(vec2 x);\\n  vec2 atan(vec2 y, vec2 x);\\n  vec2 atan(vec2 y_over_x);\\n  vec2 cos(vec2 angle);\\n  vec2 degrees(vec2 radians);\\n  vec2 radians(vec2 degrees);\\n  vec2 sin(vec2 angle);\\n  vec2 tan(vec2 angle);\\n  vec3 acos(vec3 x);\\n  vec3 asin(vec3 x);\\n  vec3 atan(vec3 y, vec3 x);\\n  vec3 atan(vec3 y_over_x);\\n  vec3 cos(vec3 angle);\\n  vec3 degrees(vec3 radians);\\n  vec3 radians(vec3 degrees);\\n  vec3 sin(vec3 angle);\\n  vec3 tan(vec3 angle);\\n  vec4 acos(vec4 x);\\n  vec4 asin(vec4 x);\\n  vec4 atan(vec4 y, vec4 x);\\n  vec4 atan(vec4 y_over_x);\\n  vec4 cos(vec4 angle);\\n  vec4 sin(vec4 angle);\\n  vec4 tan(vec4 angle);\\n\\n  // Exponential Functions\\n  float exp(float x);\\n  float exp2(float x);\\n  float inversesqrt(float x);\\n  float log(float x);\\n  float log2(float x);\\n  float pow(float x, float y);\\n  float sqrt(float x);\\n  vec2 exp(vec2 x);\\n  vec2 exp2(vec2 x);\\n  vec2 inversesqrt(vec2 x);\\n  vec2 log(vec2 x);\\n  vec2 log2(vec2 x);\\n  vec2 pow(vec2 x, vec2 y);\\n  vec2 sqrt(vec2 x);\\n  vec3 exp(vec3 x);\\n  vec3 exp2(vec3 x);\\n  vec3 inversesqrt(vec3 x);\\n  vec3 log(vec3 x);\\n  vec3 log2(vec3 x);\\n  vec3 pow(vec3 x, vec3 y);\\n  vec3 sqrt(vec3 x);\\n  vec4 exp(vec4 x);\\n  vec4 exp2(vec4 x);\\n  vec4 inversesqrt(vec4 x);\\n  vec4 log(vec4 x);\\n  vec4 log2(vec4 x);\\n  vec4 pow(vec4 x, vec4 y);\\n  vec4 sqrt(vec4 x);\\n\\n  // Common Functions\\n  float abs(float x);\\n  float ceil(float x);\\n  float clamp(float x, float minVal, float maxVal);\\n  float floor(float x);\\n  float fract(float x);\\n  float max(float x, float y);\\n  float min(float x, float y);\\n  float mix(float x, float y, float a);\\n  float mod(float x, float y);\\n  float sign(float x);\\n  float smoothstep(float edge0, float edge1, float x);\\n  float step(float edge, float x);\\n  vec2 abs(vec2 x);\\n  vec2 ceil(vec2 x);\\n  vec2 clamp(vec2 x, float minVal, float maxVal);\\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\\n  vec2 floor(vec2 x);\\n  vec2 fract(vec2 x);\\n  vec2 max(vec2 x, float y);\\n  vec2 max(vec2 x, vec2 y);\\n  vec2 min(vec2 x, float y);\\n  vec2 min(vec2 x, vec2 y);\\n  vec2 mix(vec2 x, vec2 y, float a);\\n  vec2 mix(vec2 x, vec2 y, vec2 a);\\n  vec2 mod(vec2 x, float y);\\n  vec2 mod(vec2 x, vec2 y);\\n  vec2 sign(vec2 x);\\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\\n  vec2 step(float edge, vec2 x);\\n  vec2 step(vec2 edge, vec2 x);\\n  vec3 abs(vec3 x);\\n  vec3 ceil(vec3 x);\\n  vec3 clamp(vec3 x, float minVal, float maxVal);\\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\\n  vec3 floor(vec3 x);\\n  vec3 fract(vec3 x);\\n  vec3 max(vec3 x, float y);\\n  vec3 max(vec3 x, vec3 y);\\n  vec3 min(vec3 x, float y);\\n  vec3 min(vec3 x, vec3 y);\\n  vec3 mix(vec3 x, vec3 y, float a);\\n  vec3 mix(vec3 x, vec3 y, vec3 a);\\n  vec3 mod(vec3 x, float y);\\n  vec3 mod(vec3 x, vec3 y);\\n  vec3 sign(vec3 x);\\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\\n  vec3 step(float edge, vec3 x);\\n  vec3 step(vec3 edge, vec3 x);\\n  vec4 abs(vec4 x);\\n  vec4 ceil(vec4 x);\\n  vec4 clamp(vec4 x, float minVal, float maxVal);\\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\\n  vec4 floor(vec4 x);\\n  vec4 fract(vec4 x);\\n  vec4 max(vec4 x, float y);\\n  vec4 max(vec4 x, vec4 y);\\n  vec4 min(vec4 x, float y);\\n  vec4 min(vec4 x, vec4 y);\\n  vec4 mix(vec4 x, vec4 y, float a);\\n  vec4 mix(vec4 x, vec4 y, vec4 a);\\n  vec4 mod(vec4 x, float y);\\n  vec4 mod(vec4 x, vec4 y);\\n  vec4 sign(vec4 x);\\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\\n  vec4 step(float edge, vec4 x);\\n  vec4 step(vec4 edge, vec4 x);\\n\\n  // Geometric Functions\\n  float distance(float p0, float p1);\\n  float distance(vec2 p0, vec2 p1);\\n  float distance(vec3 p0, vec3 p1);\\n  float distance(vec4 p0, vec4 p1);\\n  float dot(float x, float y);\\n  float dot(vec2 x, vec2 y);\\n  float dot(vec3 x, vec3 y);\\n  float dot(vec4 x, vec4 y);\\n  float faceforward(float N, float I, float Nref);\\n  float length(float x);\\n  float length(vec2 x);\\n  float length(vec3 x);\\n  float length(vec4 x);\\n  float normalize(float x);\\n  float reflect(float I, float N);\\n  float refract(float I, float N, float eta);\\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\\n  vec2 normalize(vec2 x);\\n  vec2 reflect(vec2 I, vec2 N);\\n  vec2 refract(vec2 I, vec2 N, float eta);\\n  vec3 cross(vec3 x, vec3 y);\\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\\n  vec3 normalize(vec3 x);\\n  vec3 reflect(vec3 I, vec3 N);\\n  vec3 refract(vec3 I, vec3 N, float eta);\\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\\n  vec4 normalize(vec4 x);\\n  vec4 reflect(vec4 I, vec4 N);\\n  vec4 refract(vec4 I, vec4 N, float eta);\\n\\n  // Matrix Functions\\n  mat2 matrixCompMult(mat2 x, mat2 y);\\n  mat3 matrixCompMult(mat3 x, mat3 y);\\n  mat4 matrixCompMult(mat4 x, mat4 y);\\n\\n  // Vector Relational Functions\\n  bool all(bvec2 x);\\n  bool all(bvec3 x);\\n  bool all(bvec4 x);\\n  bool any(bvec2 x);\\n  bool any(bvec3 x);\\n  bool any(bvec4 x);\\n  bvec2 equal(bvec2 x, bvec2 y);\\n  bvec2 equal(ivec2 x, ivec2 y);\\n  bvec2 equal(vec2 x, vec2 y);\\n  bvec2 greaterThan(ivec2 x, ivec2 y);\\n  bvec2 greaterThan(vec2 x, vec2 y);\\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\\n  bvec2 lessThan(ivec2 x, ivec2 y);\\n  bvec2 lessThan(vec2 x, vec2 y);\\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\\n  bvec2 lessThanEqual(vec2 x, vec2 y);\\n  bvec2 not(bvec2 x);\\n  bvec2 notEqual(bvec2 x, bvec2 y);\\n  bvec2 notEqual(ivec2 x, ivec2 y);\\n  bvec2 notEqual(vec2 x, vec2 y);\\n  bvec3 equal(bvec3 x, bvec3 y);\\n  bvec3 equal(ivec3 x, ivec3 y);\\n  bvec3 equal(vec3 x, vec3 y);\\n  bvec3 greaterThan(ivec3 x, ivec3 y);\\n  bvec3 greaterThan(vec3 x, vec3 y);\\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\\n  bvec3 lessThan(ivec3 x, ivec3 y);\\n  bvec3 lessThan(vec3 x, vec3 y);\\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\\n  bvec3 lessThanEqual(vec3 x, vec3 y);\\n  bvec3 not(bvec3 x);\\n  bvec3 notEqual(bvec3 x, bvec3 y);\\n  bvec3 notEqual(ivec3 x, ivec3 y);\\n  bvec3 notEqual(vec3 x, vec3 y);\\n  bvec4 equal(bvec4 x, bvec4 y);\\n  bvec4 equal(ivec4 x, ivec4 y);\\n  bvec4 equal(vec4 x, vec4 y);\\n  bvec4 greaterThan(ivec4 x, ivec4 y);\\n  bvec4 greaterThan(vec4 x, vec4 y);\\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\\n  bvec4 lessThan(ivec4 x, ivec4 y);\\n  bvec4 lessThan(vec4 x, vec4 y);\\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\\n  bvec4 lessThanEqual(vec4 x, vec4 y);\\n  bvec4 not(bvec4 x);\\n  bvec4 notEqual(bvec4 x, bvec4 y);\\n  bvec4 notEqual(ivec4 x, ivec4 y);\\n  bvec4 notEqual(vec4 x, vec4 y);\\n\\n  // Texture Lookup Functions\\n  vec4 texture2D(sampler2D sampler, vec2 coord);\\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\\n  vec4 textureCube(samplerCube sampler, vec3 coord);\\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\\n\\n  #extension GL_OES_standard_derivatives {\\n    float dFdx(float v);\\n    float dFdy(float v);\\n    float fwidth(float v);\\n    vec2 dFdx(vec2 v);\\n    vec2 dFdy(vec2 v);\\n    vec2 fwidth(vec2 v);\\n    vec3 dFdx(vec3 v);\\n    vec3 dFdy(vec3 v);\\n    vec3 fwidth(vec3 v);\\n    vec4 dFdx(vec4 v);\\n    vec4 dFdy(vec4 v);\\n    vec4 fwidth(vec4 v);\\n  }\\n\\n  #extension GL_EXT_frag_depth {\\n    float gl_FragDepthEXT;\\n  }\\n\\n  #extension GL_EXT_shader_texture_lod {\\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\\n  }\\n}\\n';\r\n  GLSLX.Node._nextID = 0;\r\n  GLSLX.Parser.pratt = null;\r\n  GLSLX.Parser._extensionBehaviors = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'disable', GLSLX.ExtensionBehavior.DISABLE), 'enable', GLSLX.ExtensionBehavior.ENABLE), 'require', GLSLX.ExtensionBehavior.REQUIRE), 'warn', GLSLX.ExtensionBehavior.WARN);\r\n\r\n  // From https://www.khronos.org/registry/webgl/extensions/\r\n  GLSLX.Parser._knownWebGLExtensions = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'GL_OES_standard_derivatives', 0), 'GL_EXT_frag_depth', 0), 'GL_EXT_draw_buffers', 0), 'GL_EXT_shader_texture_lod', 0);\r\n  GLSLX.Swizzle._STRINGS_2 = ['xy', 'st', 'rg'];\r\n  GLSLX.Swizzle._STRINGS_3 = ['xyz', 'stp', 'rgb'];\r\n  GLSLX.Swizzle._STRINGS_4 = ['xyzw', 'stpq', 'rgba'];\r\n\r\n  // The order matters here due to greedy matching\r\n  GLSLX.Tokenizer._tokenRegex = new RegExp('(' + '\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.|' + '[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[1-9][0-9]*\\\\b|' + '0[0-7]*\\\\b|' + '0[xX][0-9A-Fa-f]+\\\\b|' + '[ \\t\\r\\n]|' + '/\\\\*(?:.|\\r\\n|\\n)*?\\\\*/|' + '//.*|' + '&&|\\\\|\\\\||\\\\^\\\\^|\\\\+\\\\+|--|<<=?|>>=?|[()[\\\\]{}\\\\.,?:;]|[+\\\\-*/%=!<>&|^~]=?|' + '[A-Za-z_][A-Za-z0-9_]*\\\\b|' + '#(?:version|extension|include)\\\\b|' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')');\r\n  GLSLX.Tokenizer._intRegex = new RegExp('^(' + '[1-9][0-9]*|' + '0[0-7]*|' + '0[xX][0-9A-Fa-f]+' + ')$');\r\n  GLSLX.Tokenizer.keywords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'attribute', GLSLX.TokenKind.ATTRIBUTE), 'bool', GLSLX.TokenKind.BOOL), 'break', GLSLX.TokenKind.BREAK), 'bvec2', GLSLX.TokenKind.BVEC2), 'bvec3', GLSLX.TokenKind.BVEC3), 'bvec4', GLSLX.TokenKind.BVEC4), 'const', GLSLX.TokenKind.CONST), 'continue', GLSLX.TokenKind.CONTINUE), 'discard', GLSLX.TokenKind.DISCARD), 'do', GLSLX.TokenKind.DO), 'else', GLSLX.TokenKind.ELSE), 'false', GLSLX.TokenKind.FALSE), 'float', GLSLX.TokenKind.FLOAT), 'for', GLSLX.TokenKind.FOR), 'highp', GLSLX.TokenKind.HIGHP), 'if', GLSLX.TokenKind.IF), 'in', GLSLX.TokenKind.IN), 'inout', GLSLX.TokenKind.INOUT), 'int', GLSLX.TokenKind.INT), 'invariant', GLSLX.TokenKind.INVARIANT), 'ivec2', GLSLX.TokenKind.IVEC2), 'ivec3', GLSLX.TokenKind.IVEC3), 'ivec4', GLSLX.TokenKind.IVEC4), 'lowp', GLSLX.TokenKind.LOWP), 'mat2', GLSLX.TokenKind.MAT2), 'mat3', GLSLX.TokenKind.MAT3), 'mat4', GLSLX.TokenKind.MAT4), 'mediump', GLSLX.TokenKind.MEDIUMP), 'out', GLSLX.TokenKind.OUT), 'precision', GLSLX.TokenKind.PRECISION), 'return', GLSLX.TokenKind.RETURN), 'sampler2D', GLSLX.TokenKind.SAMPLER2D), 'samplerCube', GLSLX.TokenKind.SAMPLERCUBE), 'struct', GLSLX.TokenKind.STRUCT), 'true', GLSLX.TokenKind.TRUE), 'uniform', GLSLX.TokenKind.UNIFORM), 'varying', GLSLX.TokenKind.VARYING), 'vec2', GLSLX.TokenKind.VEC2), 'vec3', GLSLX.TokenKind.VEC3), 'vec4', GLSLX.TokenKind.VEC4), 'void', GLSLX.TokenKind.VOID), 'while', GLSLX.TokenKind.WHILE), 'export', GLSLX.TokenKind.EXPORT), 'import', GLSLX.TokenKind.IMPORT);\r\n  GLSLX.Tokenizer.operators = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), '~', GLSLX.TokenKind.COMPLEMENT), '--', GLSLX.TokenKind.DECREMENT), '++', GLSLX.TokenKind.INCREMENT), '!', GLSLX.TokenKind.NOT), '&', GLSLX.TokenKind.BITWISE_AND), '|', GLSLX.TokenKind.BITWISE_OR), '^', GLSLX.TokenKind.BITWISE_XOR), '/', GLSLX.TokenKind.DIVIDE), '==', GLSLX.TokenKind.EQUAL), '>', GLSLX.TokenKind.GREATER_THAN), '>=', GLSLX.TokenKind.GREATER_THAN_OR_EQUAL), '<', GLSLX.TokenKind.LESS_THAN), '<=', GLSLX.TokenKind.LESS_THAN_OR_EQUAL), '&&', GLSLX.TokenKind.LOGICAL_AND), '||', GLSLX.TokenKind.LOGICAL_OR), '^^', GLSLX.TokenKind.LOGICAL_XOR), '-', GLSLX.TokenKind.MINUS), '*', GLSLX.TokenKind.MULTIPLY), '!=', GLSLX.TokenKind.NOT_EQUAL), '+', GLSLX.TokenKind.PLUS), '%', GLSLX.TokenKind.REMAINDER), '<<', GLSLX.TokenKind.SHIFT_LEFT), '>>', GLSLX.TokenKind.SHIFT_RIGHT), '=', GLSLX.TokenKind.ASSIGN), '+=', GLSLX.TokenKind.ASSIGN_ADD), '&=', GLSLX.TokenKind.ASSIGN_BITWISE_AND), '|=', GLSLX.TokenKind.ASSIGN_BITWISE_OR), '^=', GLSLX.TokenKind.ASSIGN_BITWISE_XOR), '/=', GLSLX.TokenKind.ASSIGN_DIVIDE), '*=', GLSLX.TokenKind.ASSIGN_MULTIPLY), '%=', GLSLX.TokenKind.ASSIGN_REMAINDER), '<<=', GLSLX.TokenKind.ASSIGN_SHIFT_LEFT), '>>=', GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT), '-=', GLSLX.TokenKind.ASSIGN_SUBTRACT), ':', GLSLX.TokenKind.COLON), ',', GLSLX.TokenKind.COMMA), '.', GLSLX.TokenKind.DOT), '{', GLSLX.TokenKind.LEFT_BRACE), '[', GLSLX.TokenKind.LEFT_BRACKET), '(', GLSLX.TokenKind.LEFT_PARENTHESIS), '?', GLSLX.TokenKind.QUESTION), '}', GLSLX.TokenKind.RIGHT_BRACE), ']', GLSLX.TokenKind.RIGHT_BRACKET), ')', GLSLX.TokenKind.RIGHT_PARENTHESIS), ';', GLSLX.TokenKind.SEMICOLON);\r\n  GLSLX.Tokenizer.reservedWords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'asm', 0), 'cast', 0), 'class', 0), 'default', 0), 'double', 0), 'dvec2', 0), 'dvec3', 0), 'dvec4', 0), 'enum', 0), 'extern', 0), 'external', 0), 'fixed', 0), 'flat', 0), 'fvec2', 0), 'fvec3', 0), 'fvec4', 0), 'goto', 0), 'half', 0), 'hvec2', 0), 'hvec3', 0), 'hvec4', 0), 'inline', 0), 'input', 0), 'interface', 0), 'long', 0), 'namespace', 0), 'noinline', 0), 'output', 0), 'packed', 0), 'public', 0), 'sampler1D', 0), 'sampler1DShadow', 0), 'sampler2DRect', 0), 'sampler2DRectShadow', 0), 'sampler2DShadow', 0), 'sampler3D', 0), 'sampler3DRect', 0), 'short', 0), 'sizeof', 0), 'static', 0), 'superp', 0), 'switch', 0), 'template', 0), 'this', 0), 'typedef', 0), 'union', 0), 'unsigned', 0), 'using', 0), 'volatile', 0);\r\n  GLSLX.Type.BOOL = new GLSLX.StructSymbol(-1, null, 'bool', null).resolvedType();\r\n  GLSLX.Type.BVEC2 = new GLSLX.StructSymbol(-2, null, 'bvec2', null).resolvedType();\r\n  GLSLX.Type.BVEC3 = new GLSLX.StructSymbol(-3, null, 'bvec3', null).resolvedType();\r\n  GLSLX.Type.BVEC4 = new GLSLX.StructSymbol(-4, null, 'bvec4', null).resolvedType();\r\n  GLSLX.Type.ERROR = new GLSLX.StructSymbol(-5, null, '<error>', null).resolvedType();\r\n  GLSLX.Type.FLOAT = new GLSLX.StructSymbol(-6, null, 'float', null).resolvedType();\r\n  GLSLX.Type.INT = new GLSLX.StructSymbol(-7, null, 'int', null).resolvedType();\r\n  GLSLX.Type.IVEC2 = new GLSLX.StructSymbol(-8, null, 'ivec2', null).resolvedType();\r\n  GLSLX.Type.IVEC3 = new GLSLX.StructSymbol(-9, null, 'ivec3', null).resolvedType();\r\n  GLSLX.Type.IVEC4 = new GLSLX.StructSymbol(-10, null, 'ivec4', null).resolvedType();\r\n  GLSLX.Type.MAT2 = new GLSLX.StructSymbol(-11, null, 'mat2', null).resolvedType();\r\n  GLSLX.Type.MAT3 = new GLSLX.StructSymbol(-12, null, 'mat3', null).resolvedType();\r\n  GLSLX.Type.MAT4 = new GLSLX.StructSymbol(-13, null, 'mat4', null).resolvedType();\r\n  GLSLX.Type.SAMPLER2D = new GLSLX.StructSymbol(-14, null, 'sampler2D', null).resolvedType()._setContainsSampler();\r\n  GLSLX.Type.SAMPLERCUBE = new GLSLX.StructSymbol(-15, null, 'samplerCube', null).resolvedType()._setContainsSampler();\r\n  GLSLX.Type.VEC2 = new GLSLX.StructSymbol(-16, null, 'vec2', null).resolvedType();\r\n  GLSLX.Type.VEC3 = new GLSLX.StructSymbol(-17, null, 'vec3', null).resolvedType();\r\n  GLSLX.Type.VEC4 = new GLSLX.StructSymbol(-18, null, 'vec4', null).resolvedType();\r\n  GLSLX.Type.VOID = new GLSLX.StructSymbol(-19, null, 'void', null).resolvedType();\r\n  GLSLX.in_TokenKind._strings = ['ATTRIBUTE', 'BOOL', 'BREAK', 'BVEC2', 'BVEC3', 'BVEC4', 'CONST', 'CONTINUE', 'DISCARD', 'DO', 'ELSE', 'FALSE', 'FLOAT', 'FOR', 'HIGHP', 'IF', 'IN', 'INOUT', 'INT', 'INVARIANT', 'IVEC2', 'IVEC3', 'IVEC4', 'LOWP', 'MAT2', 'MAT3', 'MAT4', 'MEDIUMP', 'OUT', 'PRECISION', 'RETURN', 'SAMPLER2D', 'SAMPLERCUBE', 'STRUCT', 'TRUE', 'UNIFORM', 'VARYING', 'VEC2', 'VEC3', 'VEC4', 'VOID', 'WHILE', 'EXPORT', 'IMPORT', 'COMPLEMENT', 'DECREMENT', 'INCREMENT', 'NOT', 'BITWISE_AND', 'BITWISE_OR', 'BITWISE_XOR', 'DIVIDE', 'EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'LOGICAL_AND', 'LOGICAL_OR', 'LOGICAL_XOR', 'MINUS', 'MULTIPLY', 'NOT_EQUAL', 'PLUS', 'REMAINDER', 'SHIFT_LEFT', 'SHIFT_RIGHT', 'ASSIGN', 'ASSIGN_ADD', 'ASSIGN_BITWISE_AND', 'ASSIGN_BITWISE_OR', 'ASSIGN_BITWISE_XOR', 'ASSIGN_DIVIDE', 'ASSIGN_MULTIPLY', 'ASSIGN_REMAINDER', 'ASSIGN_SHIFT_LEFT', 'ASSIGN_SHIFT_RIGHT', 'ASSIGN_SUBTRACT', 'COLON', 'COMMA', 'DOT', 'LEFT_BRACE', 'LEFT_BRACKET', 'LEFT_PARENTHESIS', 'QUESTION', 'RIGHT_BRACE', 'RIGHT_BRACKET', 'RIGHT_PARENTHESIS', 'SEMICOLON', 'EXTENSION', 'VERSION', 'INCLUDE', 'FLOAT_LITERAL', 'IDENTIFIER', 'INT_LITERAL', 'STRING_LITERAL', 'END_OF_FILE'];\r\n\r\n  GLSLX.Exports.main();\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/glsl-parser/parser.js\n// module id = TFw8\n// module chunks = 2"],"sourceRoot":""}